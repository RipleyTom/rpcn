// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum BinAttrOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinAttr<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinAttr<'a> {
  type Inner = BinAttr<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinAttr<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinAttr { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinAttrArgs<'args>
  ) -> flatbuffers::WIPOffset<BinAttr<'bldr>> {
    let mut builder = BinAttrBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(BinAttr::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(BinAttr::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for BinAttr<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct BinAttrArgs<'a> {
    pub id: u16,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BinAttrArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinAttrArgs {
      id: 0,
      data: None,
    }
  }
}

pub struct BinAttrBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinAttrBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(BinAttr::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinAttr::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinAttrBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinAttrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinAttr<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinAttr<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinAttr");
      ds.field("id", &self.id());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum IntAttrOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntAttr<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntAttr<'a> {
  type Inner = IntAttr<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IntAttr<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NUM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IntAttr { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntAttrArgs
  ) -> flatbuffers::WIPOffset<IntAttr<'bldr>> {
    let mut builder = IntAttrBuilder::new(_fbb);
    builder.add_num(args.num);
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(IntAttr::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn num(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(IntAttr::VT_NUM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for IntAttr<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("id", Self::VT_ID, false)?
     .visit_field::<u32>("num", Self::VT_NUM, false)?
     .finish();
    Ok(())
  }
}
pub struct IntAttrArgs {
    pub id: u16,
    pub num: u32,
}
impl<'a> Default for IntAttrArgs {
  #[inline]
  fn default() -> Self {
    IntAttrArgs {
      id: 0,
      num: 0,
    }
  }
}

pub struct IntAttrBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntAttrBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(IntAttr::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_num(&mut self, num: u32) {
    self.fbb_.push_slot::<u32>(IntAttr::VT_NUM, num, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntAttrBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntAttrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntAttr<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IntAttr<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IntAttr");
      ds.field("id", &self.id());
      ds.field("num", &self.num());
      ds.finish()
  }
}
pub enum RoomMemberBinAttrInternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomMemberBinAttrInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMemberBinAttrInternal<'a> {
  type Inner = RoomMemberBinAttrInternal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomMemberBinAttrInternal<'a> {
  pub const VT_UPDATEDATE: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomMemberBinAttrInternal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomMemberBinAttrInternalArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomMemberBinAttrInternal<'bldr>> {
    let mut builder = RoomMemberBinAttrInternalBuilder::new(_fbb);
    builder.add_updateDate(args.updateDate);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn updateDate(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RoomMemberBinAttrInternal::VT_UPDATEDATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<BinAttr<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinAttr>>(RoomMemberBinAttrInternal::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for RoomMemberBinAttrInternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("updateDate", Self::VT_UPDATEDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinAttr>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomMemberBinAttrInternalArgs<'a> {
    pub updateDate: u64,
    pub data: Option<flatbuffers::WIPOffset<BinAttr<'a>>>,
}
impl<'a> Default for RoomMemberBinAttrInternalArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomMemberBinAttrInternalArgs {
      updateDate: 0,
      data: None,
    }
  }
}

pub struct RoomMemberBinAttrInternalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomMemberBinAttrInternalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_updateDate(&mut self, updateDate: u64) {
    self.fbb_.push_slot::<u64>(RoomMemberBinAttrInternal::VT_UPDATEDATE, updateDate, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<BinAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinAttr>>(RoomMemberBinAttrInternal::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomMemberBinAttrInternalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomMemberBinAttrInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMemberBinAttrInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomMemberBinAttrInternal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomMemberBinAttrInternal");
      ds.field("updateDate", &self.updateDate());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum BinAttrInternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinAttrInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinAttrInternal<'a> {
  type Inner = BinAttrInternal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinAttrInternal<'a> {
  pub const VT_UPDATEDATE: flatbuffers::VOffsetT = 4;
  pub const VT_UPDATEMEMBERID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinAttrInternal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinAttrInternalArgs<'args>
  ) -> flatbuffers::WIPOffset<BinAttrInternal<'bldr>> {
    let mut builder = BinAttrInternalBuilder::new(_fbb);
    builder.add_updateDate(args.updateDate);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_updateMemberId(args.updateMemberId);
    builder.finish()
  }


  #[inline]
  pub fn updateDate(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BinAttrInternal::VT_UPDATEDATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn updateMemberId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(BinAttrInternal::VT_UPDATEMEMBERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<BinAttr<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinAttr>>(BinAttrInternal::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for BinAttrInternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("updateDate", Self::VT_UPDATEDATE, false)?
     .visit_field::<u16>("updateMemberId", Self::VT_UPDATEMEMBERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinAttr>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct BinAttrInternalArgs<'a> {
    pub updateDate: u64,
    pub updateMemberId: u16,
    pub data: Option<flatbuffers::WIPOffset<BinAttr<'a>>>,
}
impl<'a> Default for BinAttrInternalArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinAttrInternalArgs {
      updateDate: 0,
      updateMemberId: 0,
      data: None,
    }
  }
}

pub struct BinAttrInternalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinAttrInternalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_updateDate(&mut self, updateDate: u64) {
    self.fbb_.push_slot::<u64>(BinAttrInternal::VT_UPDATEDATE, updateDate, 0);
  }
  #[inline]
  pub fn add_updateMemberId(&mut self, updateMemberId: u16) {
    self.fbb_.push_slot::<u16>(BinAttrInternal::VT_UPDATEMEMBERID, updateMemberId, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<BinAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinAttr>>(BinAttrInternal::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinAttrInternalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinAttrInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinAttrInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinAttrInternal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinAttrInternal");
      ds.field("updateDate", &self.updateDate());
      ds.field("updateMemberId", &self.updateMemberId());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum OptParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OptParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OptParam<'a> {
  type Inner = OptParam<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OptParam<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_FLAG: flatbuffers::VOffsetT = 6;
  pub const VT_HUBMEMBERID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OptParam { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OptParamArgs
  ) -> flatbuffers::WIPOffset<OptParam<'bldr>> {
    let mut builder = OptParamBuilder::new(_fbb);
    builder.add_hubMemberId(args.hubMemberId);
    builder.add_flag(args.flag);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(OptParam::VT_TYPE_, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flag(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(OptParam::VT_FLAG, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hubMemberId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(OptParam::VT_HUBMEMBERID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OptParam<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_", Self::VT_TYPE_, false)?
     .visit_field::<u8>("flag", Self::VT_FLAG, false)?
     .visit_field::<u16>("hubMemberId", Self::VT_HUBMEMBERID, false)?
     .finish();
    Ok(())
  }
}
pub struct OptParamArgs {
    pub type_: u8,
    pub flag: u8,
    pub hubMemberId: u16,
}
impl<'a> Default for OptParamArgs {
  #[inline]
  fn default() -> Self {
    OptParamArgs {
      type_: 0,
      flag: 0,
      hubMemberId: 0,
    }
  }
}

pub struct OptParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OptParamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: u8) {
    self.fbb_.push_slot::<u8>(OptParam::VT_TYPE_, type_, 0);
  }
  #[inline]
  pub fn add_flag(&mut self, flag: u8) {
    self.fbb_.push_slot::<u8>(OptParam::VT_FLAG, flag, 0);
  }
  #[inline]
  pub fn add_hubMemberId(&mut self, hubMemberId: u16) {
    self.fbb_.push_slot::<u16>(OptParam::VT_HUBMEMBERID, hubMemberId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OptParamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OptParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OptParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OptParam<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OptParam");
      ds.field("type_", &self.type_());
      ds.field("flag", &self.flag());
      ds.field("hubMemberId", &self.hubMemberId());
      ds.finish()
  }
}
pub enum GroupConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GroupConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GroupConfig<'a> {
  type Inner = GroupConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GroupConfig<'a> {
  pub const VT_SLOTNUM: flatbuffers::VOffsetT = 4;
  pub const VT_WITHLABEL: flatbuffers::VOffsetT = 6;
  pub const VT_LABEL: flatbuffers::VOffsetT = 8;
  pub const VT_WITHPASSWORD: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GroupConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GroupConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<GroupConfig<'bldr>> {
    let mut builder = GroupConfigBuilder::new(_fbb);
    if let Some(x) = args.label { builder.add_label(x); }
    builder.add_slotNum(args.slotNum);
    builder.add_withPassword(args.withPassword);
    builder.add_withLabel(args.withLabel);
    builder.finish()
  }


  #[inline]
  pub fn slotNum(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GroupConfig::VT_SLOTNUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn withLabel(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroupConfig::VT_WITHLABEL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn label(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GroupConfig::VT_LABEL, None)}
  }
  #[inline]
  pub fn withPassword(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroupConfig::VT_WITHPASSWORD, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GroupConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("slotNum", Self::VT_SLOTNUM, false)?
     .visit_field::<bool>("withLabel", Self::VT_WITHLABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("label", Self::VT_LABEL, false)?
     .visit_field::<bool>("withPassword", Self::VT_WITHPASSWORD, false)?
     .finish();
    Ok(())
  }
}
pub struct GroupConfigArgs<'a> {
    pub slotNum: u32,
    pub withLabel: bool,
    pub label: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub withPassword: bool,
}
impl<'a> Default for GroupConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    GroupConfigArgs {
      slotNum: 0,
      withLabel: false,
      label: None,
      withPassword: false,
    }
  }
}

pub struct GroupConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GroupConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_slotNum(&mut self, slotNum: u32) {
    self.fbb_.push_slot::<u32>(GroupConfig::VT_SLOTNUM, slotNum, 0);
  }
  #[inline]
  pub fn add_withLabel(&mut self, withLabel: bool) {
    self.fbb_.push_slot::<bool>(GroupConfig::VT_WITHLABEL, withLabel, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroupConfig::VT_LABEL, label);
  }
  #[inline]
  pub fn add_withPassword(&mut self, withPassword: bool) {
    self.fbb_.push_slot::<bool>(GroupConfig::VT_WITHPASSWORD, withPassword, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GroupConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GroupConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GroupConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GroupConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GroupConfig");
      ds.field("slotNum", &self.slotNum());
      ds.field("withLabel", &self.withLabel());
      ds.field("label", &self.label());
      ds.field("withPassword", &self.withPassword());
      ds.finish()
  }
}
pub enum UserInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UserInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UserInfo<'a> {
  type Inner = UserInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UserInfo<'a> {
  pub const VT_NPID: flatbuffers::VOffsetT = 4;
  pub const VT_ONLINENAME: flatbuffers::VOffsetT = 6;
  pub const VT_AVATARURL: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UserInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UserInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<UserInfo<'bldr>> {
    let mut builder = UserInfoBuilder::new(_fbb);
    if let Some(x) = args.avatarUrl { builder.add_avatarUrl(x); }
    if let Some(x) = args.onlineName { builder.add_onlineName(x); }
    if let Some(x) = args.npId { builder.add_npId(x); }
    builder.finish()
  }


  #[inline]
  pub fn npId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserInfo::VT_NPID, None)}
  }
  #[inline]
  pub fn onlineName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserInfo::VT_ONLINENAME, None)}
  }
  #[inline]
  pub fn avatarUrl(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserInfo::VT_AVATARURL, None)}
  }
}

impl flatbuffers::Verifiable for UserInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("npId", Self::VT_NPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onlineName", Self::VT_ONLINENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avatarUrl", Self::VT_AVATARURL, false)?
     .finish();
    Ok(())
  }
}
pub struct UserInfoArgs<'a> {
    pub npId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onlineName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatarUrl: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UserInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    UserInfoArgs {
      npId: None,
      onlineName: None,
      avatarUrl: None,
    }
  }
}

pub struct UserInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UserInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_npId(&mut self, npId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInfo::VT_NPID, npId);
  }
  #[inline]
  pub fn add_onlineName(&mut self, onlineName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInfo::VT_ONLINENAME, onlineName);
  }
  #[inline]
  pub fn add_avatarUrl(&mut self, avatarUrl: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInfo::VT_AVATARURL, avatarUrl);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UserInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UserInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UserInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UserInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UserInfo");
      ds.field("npId", &self.npId());
      ds.field("onlineName", &self.onlineName());
      ds.field("avatarUrl", &self.avatarUrl());
      ds.finish()
  }
}
pub enum RoomMemberDataInternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomMemberDataInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMemberDataInternal<'a> {
  type Inner = RoomMemberDataInternal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomMemberDataInternal<'a> {
  pub const VT_USERINFO: flatbuffers::VOffsetT = 4;
  pub const VT_JOINDATE: flatbuffers::VOffsetT = 6;
  pub const VT_MEMBERID: flatbuffers::VOffsetT = 8;
  pub const VT_TEAMID: flatbuffers::VOffsetT = 10;
  pub const VT_ROOMGROUP: flatbuffers::VOffsetT = 12;
  pub const VT_NATTYPE: flatbuffers::VOffsetT = 14;
  pub const VT_FLAGATTR: flatbuffers::VOffsetT = 16;
  pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomMemberDataInternal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomMemberDataInternalArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomMemberDataInternal<'bldr>> {
    let mut builder = RoomMemberDataInternalBuilder::new(_fbb);
    builder.add_joinDate(args.joinDate);
    if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
    builder.add_flagAttr(args.flagAttr);
    if let Some(x) = args.roomGroup { builder.add_roomGroup(x); }
    if let Some(x) = args.userInfo { builder.add_userInfo(x); }
    builder.add_memberId(args.memberId);
    builder.add_natType(args.natType);
    builder.add_teamId(args.teamId);
    builder.finish()
  }


  #[inline]
  pub fn userInfo(&self) -> Option<UserInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo>>(RoomMemberDataInternal::VT_USERINFO, None)}
  }
  #[inline]
  pub fn joinDate(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RoomMemberDataInternal::VT_JOINDATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn memberId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomMemberDataInternal::VT_MEMBERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RoomMemberDataInternal::VT_TEAMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomGroup(&self) -> Option<RoomGroup<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RoomGroup>>(RoomMemberDataInternal::VT_ROOMGROUP, None)}
  }
  #[inline]
  pub fn natType(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RoomMemberDataInternal::VT_NATTYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomMemberDataInternal::VT_FLAGATTR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberBinAttrInternal<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberBinAttrInternal>>>>(RoomMemberDataInternal::VT_ROOMMEMBERBINATTRINTERNAL, None)}
  }
}

impl flatbuffers::Verifiable for RoomMemberDataInternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<UserInfo>>("userInfo", Self::VT_USERINFO, false)?
     .visit_field::<u64>("joinDate", Self::VT_JOINDATE, false)?
     .visit_field::<u16>("memberId", Self::VT_MEMBERID, false)?
     .visit_field::<u8>("teamId", Self::VT_TEAMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RoomGroup>>("roomGroup", Self::VT_ROOMGROUP, false)?
     .visit_field::<u8>("natType", Self::VT_NATTYPE, false)?
     .visit_field::<u32>("flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomMemberBinAttrInternal>>>>("roomMemberBinAttrInternal", Self::VT_ROOMMEMBERBINATTRINTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomMemberDataInternalArgs<'a> {
    pub userInfo: Option<flatbuffers::WIPOffset<UserInfo<'a>>>,
    pub joinDate: u64,
    pub memberId: u16,
    pub teamId: u8,
    pub roomGroup: Option<flatbuffers::WIPOffset<RoomGroup<'a>>>,
    pub natType: u8,
    pub flagAttr: u32,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberBinAttrInternal<'a>>>>>,
}
impl<'a> Default for RoomMemberDataInternalArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomMemberDataInternalArgs {
      userInfo: None,
      joinDate: 0,
      memberId: 0,
      teamId: 0,
      roomGroup: None,
      natType: 0,
      flagAttr: 0,
      roomMemberBinAttrInternal: None,
    }
  }
}

pub struct RoomMemberDataInternalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomMemberDataInternalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_userInfo(&mut self, userInfo: flatbuffers::WIPOffset<UserInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo>>(RoomMemberDataInternal::VT_USERINFO, userInfo);
  }
  #[inline]
  pub fn add_joinDate(&mut self, joinDate: u64) {
    self.fbb_.push_slot::<u64>(RoomMemberDataInternal::VT_JOINDATE, joinDate, 0);
  }
  #[inline]
  pub fn add_memberId(&mut self, memberId: u16) {
    self.fbb_.push_slot::<u16>(RoomMemberDataInternal::VT_MEMBERID, memberId, 0);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternal::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn add_roomGroup(&mut self, roomGroup: flatbuffers::WIPOffset<RoomGroup<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RoomGroup>>(RoomMemberDataInternal::VT_ROOMGROUP, roomGroup);
  }
  #[inline]
  pub fn add_natType(&mut self, natType: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternal::VT_NATTYPE, natType, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomMemberDataInternal::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomMemberBinAttrInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMemberDataInternal::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomMemberDataInternalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomMemberDataInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMemberDataInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomMemberDataInternal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomMemberDataInternal");
      ds.field("userInfo", &self.userInfo());
      ds.field("joinDate", &self.joinDate());
      ds.field("memberId", &self.memberId());
      ds.field("teamId", &self.teamId());
      ds.field("roomGroup", &self.roomGroup());
      ds.field("natType", &self.natType());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomMemberBinAttrInternal", &self.roomMemberBinAttrInternal());
      ds.finish()
  }
}
pub enum RoomGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomGroup<'a> {
  type Inner = RoomGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomGroup<'a> {
  pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
  pub const VT_WITHPASSWORD: flatbuffers::VOffsetT = 6;
  pub const VT_WITHLABEL: flatbuffers::VOffsetT = 8;
  pub const VT_LABEL: flatbuffers::VOffsetT = 10;
  pub const VT_SLOTNUM: flatbuffers::VOffsetT = 12;
  pub const VT_CURGROUPMEMBERNUM: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomGroupArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomGroup<'bldr>> {
    let mut builder = RoomGroupBuilder::new(_fbb);
    builder.add_curGroupMemberNum(args.curGroupMemberNum);
    builder.add_slotNum(args.slotNum);
    if let Some(x) = args.label { builder.add_label(x); }
    builder.add_withLabel(args.withLabel);
    builder.add_withPassword(args.withPassword);
    builder.add_groupId(args.groupId);
    builder.finish()
  }


  #[inline]
  pub fn groupId(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RoomGroup::VT_GROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn withPassword(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RoomGroup::VT_WITHPASSWORD, Some(false)).unwrap()}
  }
  #[inline]
  pub fn withLabel(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RoomGroup::VT_WITHLABEL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn label(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomGroup::VT_LABEL, None)}
  }
  #[inline]
  pub fn slotNum(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomGroup::VT_SLOTNUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn curGroupMemberNum(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomGroup::VT_CURGROUPMEMBERNUM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RoomGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("groupId", Self::VT_GROUPID, false)?
     .visit_field::<bool>("withPassword", Self::VT_WITHPASSWORD, false)?
     .visit_field::<bool>("withLabel", Self::VT_WITHLABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("label", Self::VT_LABEL, false)?
     .visit_field::<u32>("slotNum", Self::VT_SLOTNUM, false)?
     .visit_field::<u32>("curGroupMemberNum", Self::VT_CURGROUPMEMBERNUM, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomGroupArgs<'a> {
    pub groupId: u8,
    pub withPassword: bool,
    pub withLabel: bool,
    pub label: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub slotNum: u32,
    pub curGroupMemberNum: u32,
}
impl<'a> Default for RoomGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomGroupArgs {
      groupId: 0,
      withPassword: false,
      withLabel: false,
      label: None,
      slotNum: 0,
      curGroupMemberNum: 0,
    }
  }
}

pub struct RoomGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomGroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_groupId(&mut self, groupId: u8) {
    self.fbb_.push_slot::<u8>(RoomGroup::VT_GROUPID, groupId, 0);
  }
  #[inline]
  pub fn add_withPassword(&mut self, withPassword: bool) {
    self.fbb_.push_slot::<bool>(RoomGroup::VT_WITHPASSWORD, withPassword, false);
  }
  #[inline]
  pub fn add_withLabel(&mut self, withLabel: bool) {
    self.fbb_.push_slot::<bool>(RoomGroup::VT_WITHLABEL, withLabel, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomGroup::VT_LABEL, label);
  }
  #[inline]
  pub fn add_slotNum(&mut self, slotNum: u32) {
    self.fbb_.push_slot::<u32>(RoomGroup::VT_SLOTNUM, slotNum, 0);
  }
  #[inline]
  pub fn add_curGroupMemberNum(&mut self, curGroupMemberNum: u32) {
    self.fbb_.push_slot::<u32>(RoomGroup::VT_CURGROUPMEMBERNUM, curGroupMemberNum, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomGroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomGroup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomGroup");
      ds.field("groupId", &self.groupId());
      ds.field("withPassword", &self.withPassword());
      ds.field("withLabel", &self.withLabel());
      ds.field("label", &self.label());
      ds.field("slotNum", &self.slotNum());
      ds.field("curGroupMemberNum", &self.curGroupMemberNum());
      ds.finish()
  }
}
pub enum RoomDataInternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomDataInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomDataInternal<'a> {
  type Inner = RoomDataInternal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomDataInternal<'a> {
  pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
  pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
  pub const VT_LOBBYID: flatbuffers::VOffsetT = 8;
  pub const VT_ROOMID: flatbuffers::VOffsetT = 10;
  pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 12;
  pub const VT_MAXSLOT: flatbuffers::VOffsetT = 14;
  pub const VT_MEMBERLIST: flatbuffers::VOffsetT = 16;
  pub const VT_OWNERID: flatbuffers::VOffsetT = 18;
  pub const VT_ROOMGROUP: flatbuffers::VOffsetT = 20;
  pub const VT_FLAGATTR: flatbuffers::VOffsetT = 22;
  pub const VT_ROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomDataInternal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomDataInternalArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomDataInternal<'bldr>> {
    let mut builder = RoomDataInternalBuilder::new(_fbb);
    builder.add_passwordSlotMask(args.passwordSlotMask);
    builder.add_roomId(args.roomId);
    builder.add_lobbyId(args.lobbyId);
    if let Some(x) = args.roomBinAttrInternal { builder.add_roomBinAttrInternal(x); }
    builder.add_flagAttr(args.flagAttr);
    if let Some(x) = args.roomGroup { builder.add_roomGroup(x); }
    if let Some(x) = args.memberList { builder.add_memberList(x); }
    builder.add_maxSlot(args.maxSlot);
    builder.add_worldId(args.worldId);
    builder.add_ownerId(args.ownerId);
    builder.add_serverId(args.serverId);
    builder.finish()
  }


  #[inline]
  pub fn serverId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomDataInternal::VT_SERVERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomDataInternal::VT_WORLDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RoomDataInternal::VT_LOBBYID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RoomDataInternal::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RoomDataInternal::VT_PASSWORDSLOTMASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn maxSlot(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomDataInternal::VT_MAXSLOT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn memberList(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>>>(RoomDataInternal::VT_MEMBERLIST, None)}
  }
  #[inline]
  pub fn ownerId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomDataInternal::VT_OWNERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomGroup(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup>>>>(RoomDataInternal::VT_ROOMGROUP, None)}
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomDataInternal::VT_FLAGATTR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttrInternal<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttrInternal>>>>(RoomDataInternal::VT_ROOMBINATTRINTERNAL, None)}
  }
}

impl flatbuffers::Verifiable for RoomDataInternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("serverId", Self::VT_SERVERID, false)?
     .visit_field::<u32>("worldId", Self::VT_WORLDID, false)?
     .visit_field::<u64>("lobbyId", Self::VT_LOBBYID, false)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<u64>("passwordSlotMask", Self::VT_PASSWORDSLOTMASK, false)?
     .visit_field::<u32>("maxSlot", Self::VT_MAXSLOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>>>("memberList", Self::VT_MEMBERLIST, false)?
     .visit_field::<u16>("ownerId", Self::VT_OWNERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomGroup>>>>("roomGroup", Self::VT_ROOMGROUP, false)?
     .visit_field::<u32>("flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttrInternal>>>>("roomBinAttrInternal", Self::VT_ROOMBINATTRINTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomDataInternalArgs<'a> {
    pub serverId: u16,
    pub worldId: u32,
    pub lobbyId: u64,
    pub roomId: u64,
    pub passwordSlotMask: u64,
    pub maxSlot: u32,
    pub memberList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'a>>>>>,
    pub ownerId: u16,
    pub roomGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>>>,
    pub flagAttr: u32,
    pub roomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttrInternal<'a>>>>>,
}
impl<'a> Default for RoomDataInternalArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomDataInternalArgs {
      serverId: 0,
      worldId: 0,
      lobbyId: 0,
      roomId: 0,
      passwordSlotMask: 0,
      maxSlot: 0,
      memberList: None,
      ownerId: 0,
      roomGroup: None,
      flagAttr: 0,
      roomBinAttrInternal: None,
    }
  }
}

pub struct RoomDataInternalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomDataInternalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(RoomDataInternal::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternal::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternal::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternal::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternal::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_maxSlot(&mut self, maxSlot: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternal::VT_MAXSLOT, maxSlot, 0);
  }
  #[inline]
  pub fn add_memberList(&mut self, memberList: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternal::VT_MEMBERLIST, memberList);
  }
  #[inline]
  pub fn add_ownerId(&mut self, ownerId: u16) {
    self.fbb_.push_slot::<u16>(RoomDataInternal::VT_OWNERID, ownerId, 0);
  }
  #[inline]
  pub fn add_roomGroup(&mut self, roomGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternal::VT_ROOMGROUP, roomGroup);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternal::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomBinAttrInternal(&mut self, roomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttrInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternal::VT_ROOMBINATTRINTERNAL, roomBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomDataInternalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomDataInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomDataInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomDataInternal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomDataInternal");
      ds.field("serverId", &self.serverId());
      ds.field("worldId", &self.worldId());
      ds.field("lobbyId", &self.lobbyId());
      ds.field("roomId", &self.roomId());
      ds.field("passwordSlotMask", &self.passwordSlotMask());
      ds.field("maxSlot", &self.maxSlot());
      ds.field("memberList", &self.memberList());
      ds.field("ownerId", &self.ownerId());
      ds.field("roomGroup", &self.roomGroup());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomBinAttrInternal", &self.roomBinAttrInternal());
      ds.finish()
  }
}
pub enum RoomDataExternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomDataExternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomDataExternal<'a> {
  type Inner = RoomDataExternal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomDataExternal<'a> {
  pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
  pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
  pub const VT_PUBLICSLOTNUM: flatbuffers::VOffsetT = 8;
  pub const VT_PRIVATESLOTNUM: flatbuffers::VOffsetT = 10;
  pub const VT_LOBBYID: flatbuffers::VOffsetT = 12;
  pub const VT_ROOMID: flatbuffers::VOffsetT = 14;
  pub const VT_OPENPUBLICSLOTNUM: flatbuffers::VOffsetT = 16;
  pub const VT_MAXSLOT: flatbuffers::VOffsetT = 18;
  pub const VT_OPENPRIVATESLOTNUM: flatbuffers::VOffsetT = 20;
  pub const VT_CURMEMBERNUM: flatbuffers::VOffsetT = 22;
  pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 24;
  pub const VT_OWNER: flatbuffers::VOffsetT = 26;
  pub const VT_ROOMGROUP: flatbuffers::VOffsetT = 28;
  pub const VT_FLAGATTR: flatbuffers::VOffsetT = 30;
  pub const VT_ROOMSEARCHABLEINTATTREXTERNAL: flatbuffers::VOffsetT = 32;
  pub const VT_ROOMSEARCHABLEBINATTREXTERNAL: flatbuffers::VOffsetT = 34;
  pub const VT_ROOMBINATTREXTERNAL: flatbuffers::VOffsetT = 36;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomDataExternal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomDataExternalArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomDataExternal<'bldr>> {
    let mut builder = RoomDataExternalBuilder::new(_fbb);
    builder.add_passwordSlotMask(args.passwordSlotMask);
    builder.add_roomId(args.roomId);
    builder.add_lobbyId(args.lobbyId);
    if let Some(x) = args.roomBinAttrExternal { builder.add_roomBinAttrExternal(x); }
    if let Some(x) = args.roomSearchableBinAttrExternal { builder.add_roomSearchableBinAttrExternal(x); }
    if let Some(x) = args.roomSearchableIntAttrExternal { builder.add_roomSearchableIntAttrExternal(x); }
    builder.add_flagAttr(args.flagAttr);
    if let Some(x) = args.roomGroup { builder.add_roomGroup(x); }
    if let Some(x) = args.owner { builder.add_owner(x); }
    builder.add_worldId(args.worldId);
    builder.add_curMemberNum(args.curMemberNum);
    builder.add_openPrivateSlotNum(args.openPrivateSlotNum);
    builder.add_maxSlot(args.maxSlot);
    builder.add_openPublicSlotNum(args.openPublicSlotNum);
    builder.add_privateSlotNum(args.privateSlotNum);
    builder.add_publicSlotNum(args.publicSlotNum);
    builder.add_serverId(args.serverId);
    builder.finish()
  }


  #[inline]
  pub fn serverId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomDataExternal::VT_SERVERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomDataExternal::VT_WORLDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn publicSlotNum(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomDataExternal::VT_PUBLICSLOTNUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn privateSlotNum(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomDataExternal::VT_PRIVATESLOTNUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RoomDataExternal::VT_LOBBYID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RoomDataExternal::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn openPublicSlotNum(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomDataExternal::VT_OPENPUBLICSLOTNUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn maxSlot(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomDataExternal::VT_MAXSLOT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn openPrivateSlotNum(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomDataExternal::VT_OPENPRIVATESLOTNUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn curMemberNum(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RoomDataExternal::VT_CURMEMBERNUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RoomDataExternal::VT_PASSWORDSLOTMASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn owner(&self) -> Option<UserInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo>>(RoomDataExternal::VT_OWNER, None)}
  }
  #[inline]
  pub fn roomGroup(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup>>>>(RoomDataExternal::VT_ROOMGROUP, None)}
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomDataExternal::VT_FLAGATTR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomSearchableIntAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr>>>>(RoomDataExternal::VT_ROOMSEARCHABLEINTATTREXTERNAL, None)}
  }
  #[inline]
  pub fn roomSearchableBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(RoomDataExternal::VT_ROOMSEARCHABLEBINATTREXTERNAL, None)}
  }
  #[inline]
  pub fn roomBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(RoomDataExternal::VT_ROOMBINATTREXTERNAL, None)}
  }
}

impl flatbuffers::Verifiable for RoomDataExternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("serverId", Self::VT_SERVERID, false)?
     .visit_field::<u32>("worldId", Self::VT_WORLDID, false)?
     .visit_field::<u16>("publicSlotNum", Self::VT_PUBLICSLOTNUM, false)?
     .visit_field::<u16>("privateSlotNum", Self::VT_PRIVATESLOTNUM, false)?
     .visit_field::<u64>("lobbyId", Self::VT_LOBBYID, false)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<u16>("openPublicSlotNum", Self::VT_OPENPUBLICSLOTNUM, false)?
     .visit_field::<u16>("maxSlot", Self::VT_MAXSLOT, false)?
     .visit_field::<u16>("openPrivateSlotNum", Self::VT_OPENPRIVATESLOTNUM, false)?
     .visit_field::<u16>("curMemberNum", Self::VT_CURMEMBERNUM, false)?
     .visit_field::<u64>("passwordSlotMask", Self::VT_PASSWORDSLOTMASK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<UserInfo>>("owner", Self::VT_OWNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomGroup>>>>("roomGroup", Self::VT_ROOMGROUP, false)?
     .visit_field::<u32>("flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntAttr>>>>("roomSearchableIntAttrExternal", Self::VT_ROOMSEARCHABLEINTATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomSearchableBinAttrExternal", Self::VT_ROOMSEARCHABLEBINATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomBinAttrExternal", Self::VT_ROOMBINATTREXTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomDataExternalArgs<'a> {
    pub serverId: u16,
    pub worldId: u32,
    pub publicSlotNum: u16,
    pub privateSlotNum: u16,
    pub lobbyId: u64,
    pub roomId: u64,
    pub openPublicSlotNum: u16,
    pub maxSlot: u16,
    pub openPrivateSlotNum: u16,
    pub curMemberNum: u16,
    pub passwordSlotMask: u64,
    pub owner: Option<flatbuffers::WIPOffset<UserInfo<'a>>>,
    pub roomGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>>>,
    pub flagAttr: u32,
    pub roomSearchableIntAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>>>,
    pub roomSearchableBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
}
impl<'a> Default for RoomDataExternalArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomDataExternalArgs {
      serverId: 0,
      worldId: 0,
      publicSlotNum: 0,
      privateSlotNum: 0,
      lobbyId: 0,
      roomId: 0,
      openPublicSlotNum: 0,
      maxSlot: 0,
      openPrivateSlotNum: 0,
      curMemberNum: 0,
      passwordSlotMask: 0,
      owner: None,
      roomGroup: None,
      flagAttr: 0,
      roomSearchableIntAttrExternal: None,
      roomSearchableBinAttrExternal: None,
      roomBinAttrExternal: None,
    }
  }
}

pub struct RoomDataExternalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomDataExternalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(RoomDataExternal::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_publicSlotNum(&mut self, publicSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_PUBLICSLOTNUM, publicSlotNum, 0);
  }
  #[inline]
  pub fn add_privateSlotNum(&mut self, privateSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_PRIVATESLOTNUM, privateSlotNum, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataExternal::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataExternal::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_openPublicSlotNum(&mut self, openPublicSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_OPENPUBLICSLOTNUM, openPublicSlotNum, 0);
  }
  #[inline]
  pub fn add_maxSlot(&mut self, maxSlot: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_MAXSLOT, maxSlot, 0);
  }
  #[inline]
  pub fn add_openPrivateSlotNum(&mut self, openPrivateSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_OPENPRIVATESLOTNUM, openPrivateSlotNum, 0);
  }
  #[inline]
  pub fn add_curMemberNum(&mut self, curMemberNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_CURMEMBERNUM, curMemberNum, 0);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(RoomDataExternal::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_owner(&mut self, owner: flatbuffers::WIPOffset<UserInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo>>(RoomDataExternal::VT_OWNER, owner);
  }
  #[inline]
  pub fn add_roomGroup(&mut self, roomGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMGROUP, roomGroup);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomDataExternal::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomSearchableIntAttrExternal(&mut self, roomSearchableIntAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMSEARCHABLEINTATTREXTERNAL, roomSearchableIntAttrExternal);
  }
  #[inline]
  pub fn add_roomSearchableBinAttrExternal(&mut self, roomSearchableBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMSEARCHABLEBINATTREXTERNAL, roomSearchableBinAttrExternal);
  }
  #[inline]
  pub fn add_roomBinAttrExternal(&mut self, roomBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMBINATTREXTERNAL, roomBinAttrExternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomDataExternalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomDataExternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomDataExternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomDataExternal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomDataExternal");
      ds.field("serverId", &self.serverId());
      ds.field("worldId", &self.worldId());
      ds.field("publicSlotNum", &self.publicSlotNum());
      ds.field("privateSlotNum", &self.privateSlotNum());
      ds.field("lobbyId", &self.lobbyId());
      ds.field("roomId", &self.roomId());
      ds.field("openPublicSlotNum", &self.openPublicSlotNum());
      ds.field("maxSlot", &self.maxSlot());
      ds.field("openPrivateSlotNum", &self.openPrivateSlotNum());
      ds.field("curMemberNum", &self.curMemberNum());
      ds.field("passwordSlotMask", &self.passwordSlotMask());
      ds.field("owner", &self.owner());
      ds.field("roomGroup", &self.roomGroup());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomSearchableIntAttrExternal", &self.roomSearchableIntAttrExternal());
      ds.field("roomSearchableBinAttrExternal", &self.roomSearchableBinAttrExternal());
      ds.field("roomBinAttrExternal", &self.roomBinAttrExternal());
      ds.finish()
  }
}
pub enum IntSearchFilterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntSearchFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntSearchFilter<'a> {
  type Inner = IntSearchFilter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IntSearchFilter<'a> {
  pub const VT_SEARCHOPERATOR: flatbuffers::VOffsetT = 4;
  pub const VT_ATTR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IntSearchFilter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntSearchFilterArgs<'args>
  ) -> flatbuffers::WIPOffset<IntSearchFilter<'bldr>> {
    let mut builder = IntSearchFilterBuilder::new(_fbb);
    if let Some(x) = args.attr { builder.add_attr(x); }
    builder.add_searchOperator(args.searchOperator);
    builder.finish()
  }


  #[inline]
  pub fn searchOperator(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(IntSearchFilter::VT_SEARCHOPERATOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn attr(&self) -> Option<IntAttr<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IntAttr>>(IntSearchFilter::VT_ATTR, None)}
  }
}

impl flatbuffers::Verifiable for IntSearchFilter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("searchOperator", Self::VT_SEARCHOPERATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntAttr>>("attr", Self::VT_ATTR, false)?
     .finish();
    Ok(())
  }
}
pub struct IntSearchFilterArgs<'a> {
    pub searchOperator: u8,
    pub attr: Option<flatbuffers::WIPOffset<IntAttr<'a>>>,
}
impl<'a> Default for IntSearchFilterArgs<'a> {
  #[inline]
  fn default() -> Self {
    IntSearchFilterArgs {
      searchOperator: 0,
      attr: None,
    }
  }
}

pub struct IntSearchFilterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntSearchFilterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_searchOperator(&mut self, searchOperator: u8) {
    self.fbb_.push_slot::<u8>(IntSearchFilter::VT_SEARCHOPERATOR, searchOperator, 0);
  }
  #[inline]
  pub fn add_attr(&mut self, attr: flatbuffers::WIPOffset<IntAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntAttr>>(IntSearchFilter::VT_ATTR, attr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntSearchFilterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntSearchFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntSearchFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IntSearchFilter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IntSearchFilter");
      ds.field("searchOperator", &self.searchOperator());
      ds.field("attr", &self.attr());
      ds.finish()
  }
}
pub enum BinSearchFilterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinSearchFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinSearchFilter<'a> {
  type Inner = BinSearchFilter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinSearchFilter<'a> {
  pub const VT_SEARCHOPERATOR: flatbuffers::VOffsetT = 4;
  pub const VT_ATTR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinSearchFilter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinSearchFilterArgs<'args>
  ) -> flatbuffers::WIPOffset<BinSearchFilter<'bldr>> {
    let mut builder = BinSearchFilterBuilder::new(_fbb);
    if let Some(x) = args.attr { builder.add_attr(x); }
    builder.add_searchOperator(args.searchOperator);
    builder.finish()
  }


  #[inline]
  pub fn searchOperator(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(BinSearchFilter::VT_SEARCHOPERATOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn attr(&self) -> Option<BinAttr<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinAttr>>(BinSearchFilter::VT_ATTR, None)}
  }
}

impl flatbuffers::Verifiable for BinSearchFilter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("searchOperator", Self::VT_SEARCHOPERATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinAttr>>("attr", Self::VT_ATTR, false)?
     .finish();
    Ok(())
  }
}
pub struct BinSearchFilterArgs<'a> {
    pub searchOperator: u8,
    pub attr: Option<flatbuffers::WIPOffset<BinAttr<'a>>>,
}
impl<'a> Default for BinSearchFilterArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinSearchFilterArgs {
      searchOperator: 0,
      attr: None,
    }
  }
}

pub struct BinSearchFilterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinSearchFilterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_searchOperator(&mut self, searchOperator: u8) {
    self.fbb_.push_slot::<u8>(BinSearchFilter::VT_SEARCHOPERATOR, searchOperator, 0);
  }
  #[inline]
  pub fn add_attr(&mut self, attr: flatbuffers::WIPOffset<BinAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinAttr>>(BinSearchFilter::VT_ATTR, attr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinSearchFilterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinSearchFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinSearchFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinSearchFilter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinSearchFilter");
      ds.field("searchOperator", &self.searchOperator());
      ds.field("attr", &self.attr());
      ds.finish()
  }
}
pub enum PresenceOptionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PresenceOptionData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PresenceOptionData<'a> {
  type Inner = PresenceOptionData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PresenceOptionData<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;
  pub const VT_LEN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PresenceOptionData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PresenceOptionDataArgs<'args>
  ) -> flatbuffers::WIPOffset<PresenceOptionData<'bldr>> {
    let mut builder = PresenceOptionDataBuilder::new(_fbb);
    builder.add_len(args.len);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PresenceOptionData::VT_DATA, None)}
  }
  #[inline]
  pub fn len(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PresenceOptionData::VT_LEN, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PresenceOptionData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .visit_field::<u32>("len", Self::VT_LEN, false)?
     .finish();
    Ok(())
  }
}
pub struct PresenceOptionDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub len: u32,
}
impl<'a> Default for PresenceOptionDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    PresenceOptionDataArgs {
      data: None,
      len: 0,
    }
  }
}

pub struct PresenceOptionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PresenceOptionDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PresenceOptionData::VT_DATA, data);
  }
  #[inline]
  pub fn add_len(&mut self, len: u32) {
    self.fbb_.push_slot::<u32>(PresenceOptionData::VT_LEN, len, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PresenceOptionDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PresenceOptionDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PresenceOptionData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PresenceOptionData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PresenceOptionData");
      ds.field("data", &self.data());
      ds.field("len", &self.len());
      ds.finish()
  }
}
pub enum RoomGroupPasswordConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomGroupPasswordConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomGroupPasswordConfig<'a> {
  type Inner = RoomGroupPasswordConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomGroupPasswordConfig<'a> {
  pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
  pub const VT_WITHPASSWORD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomGroupPasswordConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomGroupPasswordConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomGroupPasswordConfig<'bldr>> {
    let mut builder = RoomGroupPasswordConfigBuilder::new(_fbb);
    if let Some(x) = args.groupId { builder.add_groupId(x); }
    builder.add_withPassword(args.withPassword);
    builder.finish()
  }


  #[inline]
  pub fn groupId(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomGroupPasswordConfig::VT_GROUPID, None)}
  }
  #[inline]
  pub fn withPassword(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RoomGroupPasswordConfig::VT_WITHPASSWORD, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RoomGroupPasswordConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("groupId", Self::VT_GROUPID, false)?
     .visit_field::<bool>("withPassword", Self::VT_WITHPASSWORD, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomGroupPasswordConfigArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub withPassword: bool,
}
impl<'a> Default for RoomGroupPasswordConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomGroupPasswordConfigArgs {
      groupId: None,
      withPassword: false,
    }
  }
}

pub struct RoomGroupPasswordConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomGroupPasswordConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomGroupPasswordConfig::VT_GROUPID, groupId);
  }
  #[inline]
  pub fn add_withPassword(&mut self, withPassword: bool) {
    self.fbb_.push_slot::<bool>(RoomGroupPasswordConfig::VT_WITHPASSWORD, withPassword, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomGroupPasswordConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomGroupPasswordConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomGroupPasswordConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomGroupPasswordConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomGroupPasswordConfig");
      ds.field("groupId", &self.groupId());
      ds.field("withPassword", &self.withPassword());
      ds.finish()
  }
}
pub enum SearchRoomRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SearchRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SearchRoomRequest<'a> {
  type Inner = SearchRoomRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SearchRoomRequest<'a> {
  pub const VT_OPTION: flatbuffers::VOffsetT = 4;
  pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
  pub const VT_LOBBYID: flatbuffers::VOffsetT = 8;
  pub const VT_RANGEFILTER_STARTINDEX: flatbuffers::VOffsetT = 10;
  pub const VT_RANGEFILTER_MAX: flatbuffers::VOffsetT = 12;
  pub const VT_FLAGFILTER: flatbuffers::VOffsetT = 14;
  pub const VT_FLAGATTR: flatbuffers::VOffsetT = 16;
  pub const VT_INTFILTER: flatbuffers::VOffsetT = 18;
  pub const VT_BINFILTER: flatbuffers::VOffsetT = 20;
  pub const VT_ATTRID: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SearchRoomRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SearchRoomRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SearchRoomRequest<'bldr>> {
    let mut builder = SearchRoomRequestBuilder::new(_fbb);
    builder.add_lobbyId(args.lobbyId);
    if let Some(x) = args.attrId { builder.add_attrId(x); }
    if let Some(x) = args.binFilter { builder.add_binFilter(x); }
    if let Some(x) = args.intFilter { builder.add_intFilter(x); }
    builder.add_flagAttr(args.flagAttr);
    builder.add_flagFilter(args.flagFilter);
    builder.add_rangeFilter_max(args.rangeFilter_max);
    builder.add_rangeFilter_startIndex(args.rangeFilter_startIndex);
    builder.add_worldId(args.worldId);
    builder.add_option(args.option);
    builder.finish()
  }


  #[inline]
  pub fn option(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SearchRoomRequest::VT_OPTION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SearchRoomRequest::VT_WORLDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SearchRoomRequest::VT_LOBBYID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rangeFilter_startIndex(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SearchRoomRequest::VT_RANGEFILTER_STARTINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rangeFilter_max(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SearchRoomRequest::VT_RANGEFILTER_MAX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flagFilter(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SearchRoomRequest::VT_FLAGFILTER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SearchRoomRequest::VT_FLAGATTR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn intFilter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntSearchFilter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntSearchFilter>>>>(SearchRoomRequest::VT_INTFILTER, None)}
  }
  #[inline]
  pub fn binFilter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinSearchFilter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinSearchFilter>>>>(SearchRoomRequest::VT_BINFILTER, None)}
  }
  #[inline]
  pub fn attrId(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SearchRoomRequest::VT_ATTRID, None)}
  }
}

impl flatbuffers::Verifiable for SearchRoomRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("option", Self::VT_OPTION, false)?
     .visit_field::<u32>("worldId", Self::VT_WORLDID, false)?
     .visit_field::<u64>("lobbyId", Self::VT_LOBBYID, false)?
     .visit_field::<u32>("rangeFilter_startIndex", Self::VT_RANGEFILTER_STARTINDEX, false)?
     .visit_field::<u32>("rangeFilter_max", Self::VT_RANGEFILTER_MAX, false)?
     .visit_field::<u32>("flagFilter", Self::VT_FLAGFILTER, false)?
     .visit_field::<u32>("flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntSearchFilter>>>>("intFilter", Self::VT_INTFILTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinSearchFilter>>>>("binFilter", Self::VT_BINFILTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("attrId", Self::VT_ATTRID, false)?
     .finish();
    Ok(())
  }
}
pub struct SearchRoomRequestArgs<'a> {
    pub option: i32,
    pub worldId: u32,
    pub lobbyId: u64,
    pub rangeFilter_startIndex: u32,
    pub rangeFilter_max: u32,
    pub flagFilter: u32,
    pub flagAttr: u32,
    pub intFilter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntSearchFilter<'a>>>>>,
    pub binFilter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinSearchFilter<'a>>>>>,
    pub attrId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for SearchRoomRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SearchRoomRequestArgs {
      option: 0,
      worldId: 0,
      lobbyId: 0,
      rangeFilter_startIndex: 0,
      rangeFilter_max: 0,
      flagFilter: 0,
      flagAttr: 0,
      intFilter: None,
      binFilter: None,
      attrId: None,
    }
  }
}

pub struct SearchRoomRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SearchRoomRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_option(&mut self, option: i32) {
    self.fbb_.push_slot::<i32>(SearchRoomRequest::VT_OPTION, option, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(SearchRoomRequest::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_rangeFilter_startIndex(&mut self, rangeFilter_startIndex: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_RANGEFILTER_STARTINDEX, rangeFilter_startIndex, 0);
  }
  #[inline]
  pub fn add_rangeFilter_max(&mut self, rangeFilter_max: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_RANGEFILTER_MAX, rangeFilter_max, 0);
  }
  #[inline]
  pub fn add_flagFilter(&mut self, flagFilter: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_FLAGFILTER, flagFilter, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_intFilter(&mut self, intFilter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntSearchFilter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomRequest::VT_INTFILTER, intFilter);
  }
  #[inline]
  pub fn add_binFilter(&mut self, binFilter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinSearchFilter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomRequest::VT_BINFILTER, binFilter);
  }
  #[inline]
  pub fn add_attrId(&mut self, attrId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomRequest::VT_ATTRID, attrId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SearchRoomRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SearchRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SearchRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SearchRoomRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SearchRoomRequest");
      ds.field("option", &self.option());
      ds.field("worldId", &self.worldId());
      ds.field("lobbyId", &self.lobbyId());
      ds.field("rangeFilter_startIndex", &self.rangeFilter_startIndex());
      ds.field("rangeFilter_max", &self.rangeFilter_max());
      ds.field("flagFilter", &self.flagFilter());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("intFilter", &self.intFilter());
      ds.field("binFilter", &self.binFilter());
      ds.field("attrId", &self.attrId());
      ds.finish()
  }
}
pub enum SearchRoomResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SearchRoomResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SearchRoomResponse<'a> {
  type Inner = SearchRoomResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SearchRoomResponse<'a> {
  pub const VT_STARTINDEX: flatbuffers::VOffsetT = 4;
  pub const VT_TOTAL: flatbuffers::VOffsetT = 6;
  pub const VT_ROOMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SearchRoomResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SearchRoomResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<SearchRoomResponse<'bldr>> {
    let mut builder = SearchRoomResponseBuilder::new(_fbb);
    if let Some(x) = args.rooms { builder.add_rooms(x); }
    builder.add_total(args.total);
    builder.add_startIndex(args.startIndex);
    builder.finish()
  }


  #[inline]
  pub fn startIndex(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SearchRoomResponse::VT_STARTINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn total(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SearchRoomResponse::VT_TOTAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rooms(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal>>>>(SearchRoomResponse::VT_ROOMS, None)}
  }
}

impl flatbuffers::Verifiable for SearchRoomResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("startIndex", Self::VT_STARTINDEX, false)?
     .visit_field::<u32>("total", Self::VT_TOTAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomDataExternal>>>>("rooms", Self::VT_ROOMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SearchRoomResponseArgs<'a> {
    pub startIndex: u32,
    pub total: u32,
    pub rooms: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal<'a>>>>>,
}
impl<'a> Default for SearchRoomResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    SearchRoomResponseArgs {
      startIndex: 0,
      total: 0,
      rooms: None,
    }
  }
}

pub struct SearchRoomResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SearchRoomResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_startIndex(&mut self, startIndex: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomResponse::VT_STARTINDEX, startIndex, 0);
  }
  #[inline]
  pub fn add_total(&mut self, total: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomResponse::VT_TOTAL, total, 0);
  }
  #[inline]
  pub fn add_rooms(&mut self, rooms: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomDataExternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomResponse::VT_ROOMS, rooms);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SearchRoomResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SearchRoomResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SearchRoomResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SearchRoomResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SearchRoomResponse");
      ds.field("startIndex", &self.startIndex());
      ds.field("total", &self.total());
      ds.field("rooms", &self.rooms());
      ds.finish()
  }
}
pub enum CreateJoinRoomRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateJoinRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateJoinRoomRequest<'a> {
  type Inner = CreateJoinRoomRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreateJoinRoomRequest<'a> {
  pub const VT_WORLDID: flatbuffers::VOffsetT = 4;
  pub const VT_LOBBYID: flatbuffers::VOffsetT = 6;
  pub const VT_MAXSLOT: flatbuffers::VOffsetT = 8;
  pub const VT_FLAGATTR: flatbuffers::VOffsetT = 10;
  pub const VT_ROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 12;
  pub const VT_ROOMSEARCHABLEINTATTREXTERNAL: flatbuffers::VOffsetT = 14;
  pub const VT_ROOMSEARCHABLEBINATTREXTERNAL: flatbuffers::VOffsetT = 16;
  pub const VT_ROOMBINATTREXTERNAL: flatbuffers::VOffsetT = 18;
  pub const VT_ROOMPASSWORD: flatbuffers::VOffsetT = 20;
  pub const VT_GROUPCONFIG: flatbuffers::VOffsetT = 22;
  pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 24;
  pub const VT_ALLOWEDUSER: flatbuffers::VOffsetT = 26;
  pub const VT_BLOCKEDUSER: flatbuffers::VOffsetT = 28;
  pub const VT_JOINROOMGROUPLABEL: flatbuffers::VOffsetT = 30;
  pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 32;
  pub const VT_TEAMID: flatbuffers::VOffsetT = 34;
  pub const VT_SIGOPTPARAM: flatbuffers::VOffsetT = 36;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateJoinRoomRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateJoinRoomRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<CreateJoinRoomRequest<'bldr>> {
    let mut builder = CreateJoinRoomRequestBuilder::new(_fbb);
    builder.add_passwordSlotMask(args.passwordSlotMask);
    builder.add_lobbyId(args.lobbyId);
    if let Some(x) = args.sigOptParam { builder.add_sigOptParam(x); }
    if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
    if let Some(x) = args.joinRoomGroupLabel { builder.add_joinRoomGroupLabel(x); }
    if let Some(x) = args.blockedUser { builder.add_blockedUser(x); }
    if let Some(x) = args.allowedUser { builder.add_allowedUser(x); }
    if let Some(x) = args.groupConfig { builder.add_groupConfig(x); }
    if let Some(x) = args.roomPassword { builder.add_roomPassword(x); }
    if let Some(x) = args.roomBinAttrExternal { builder.add_roomBinAttrExternal(x); }
    if let Some(x) = args.roomSearchableBinAttrExternal { builder.add_roomSearchableBinAttrExternal(x); }
    if let Some(x) = args.roomSearchableIntAttrExternal { builder.add_roomSearchableIntAttrExternal(x); }
    if let Some(x) = args.roomBinAttrInternal { builder.add_roomBinAttrInternal(x); }
    builder.add_flagAttr(args.flagAttr);
    builder.add_maxSlot(args.maxSlot);
    builder.add_worldId(args.worldId);
    builder.add_teamId(args.teamId);
    builder.finish()
  }


  #[inline]
  pub fn worldId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CreateJoinRoomRequest::VT_WORLDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CreateJoinRoomRequest::VT_LOBBYID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn maxSlot(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CreateJoinRoomRequest::VT_MAXSLOT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CreateJoinRoomRequest::VT_FLAGATTR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(CreateJoinRoomRequest::VT_ROOMBINATTRINTERNAL, None)}
  }
  #[inline]
  pub fn roomSearchableIntAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr>>>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, None)}
  }
  #[inline]
  pub fn roomSearchableBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, None)}
  }
  #[inline]
  pub fn roomBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(CreateJoinRoomRequest::VT_ROOMBINATTREXTERNAL, None)}
  }
  #[inline]
  pub fn roomPassword(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CreateJoinRoomRequest::VT_ROOMPASSWORD, None)}
  }
  #[inline]
  pub fn groupConfig(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GroupConfig<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GroupConfig>>>>(CreateJoinRoomRequest::VT_GROUPCONFIG, None)}
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CreateJoinRoomRequest::VT_PASSWORDSLOTMASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn allowedUser(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CreateJoinRoomRequest::VT_ALLOWEDUSER, None)}
  }
  #[inline]
  pub fn blockedUser(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CreateJoinRoomRequest::VT_BLOCKEDUSER, None)}
  }
  #[inline]
  pub fn joinRoomGroupLabel(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CreateJoinRoomRequest::VT_JOINROOMGROUPLABEL, None)}
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(CreateJoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, None)}
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CreateJoinRoomRequest::VT_TEAMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sigOptParam(&self) -> Option<OptParam<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<OptParam>>(CreateJoinRoomRequest::VT_SIGOPTPARAM, None)}
  }
}

impl flatbuffers::Verifiable for CreateJoinRoomRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("worldId", Self::VT_WORLDID, false)?
     .visit_field::<u64>("lobbyId", Self::VT_LOBBYID, false)?
     .visit_field::<u32>("maxSlot", Self::VT_MAXSLOT, false)?
     .visit_field::<u32>("flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomBinAttrInternal", Self::VT_ROOMBINATTRINTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntAttr>>>>("roomSearchableIntAttrExternal", Self::VT_ROOMSEARCHABLEINTATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomSearchableBinAttrExternal", Self::VT_ROOMSEARCHABLEBINATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomBinAttrExternal", Self::VT_ROOMBINATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("roomPassword", Self::VT_ROOMPASSWORD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GroupConfig>>>>("groupConfig", Self::VT_GROUPCONFIG, false)?
     .visit_field::<u64>("passwordSlotMask", Self::VT_PASSWORDSLOTMASK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("allowedUser", Self::VT_ALLOWEDUSER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("blockedUser", Self::VT_BLOCKEDUSER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("joinRoomGroupLabel", Self::VT_JOINROOMGROUPLABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomMemberBinAttrInternal", Self::VT_ROOMMEMBERBINATTRINTERNAL, false)?
     .visit_field::<u8>("teamId", Self::VT_TEAMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<OptParam>>("sigOptParam", Self::VT_SIGOPTPARAM, false)?
     .finish();
    Ok(())
  }
}
pub struct CreateJoinRoomRequestArgs<'a> {
    pub worldId: u32,
    pub lobbyId: u64,
    pub maxSlot: u32,
    pub flagAttr: u32,
    pub roomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomSearchableIntAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>>>,
    pub roomSearchableBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomPassword: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub groupConfig: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GroupConfig<'a>>>>>,
    pub passwordSlotMask: u64,
    pub allowedUser: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub blockedUser: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub joinRoomGroupLabel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub teamId: u8,
    pub sigOptParam: Option<flatbuffers::WIPOffset<OptParam<'a>>>,
}
impl<'a> Default for CreateJoinRoomRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreateJoinRoomRequestArgs {
      worldId: 0,
      lobbyId: 0,
      maxSlot: 0,
      flagAttr: 0,
      roomBinAttrInternal: None,
      roomSearchableIntAttrExternal: None,
      roomSearchableBinAttrExternal: None,
      roomBinAttrExternal: None,
      roomPassword: None,
      groupConfig: None,
      passwordSlotMask: 0,
      allowedUser: None,
      blockedUser: None,
      joinRoomGroupLabel: None,
      roomMemberBinAttrInternal: None,
      teamId: 0,
      sigOptParam: None,
    }
  }
}

pub struct CreateJoinRoomRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateJoinRoomRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(CreateJoinRoomRequest::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(CreateJoinRoomRequest::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_maxSlot(&mut self, maxSlot: u32) {
    self.fbb_.push_slot::<u32>(CreateJoinRoomRequest::VT_MAXSLOT, maxSlot, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(CreateJoinRoomRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomBinAttrInternal(&mut self, roomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMBINATTRINTERNAL, roomBinAttrInternal);
  }
  #[inline]
  pub fn add_roomSearchableIntAttrExternal(&mut self, roomSearchableIntAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, roomSearchableIntAttrExternal);
  }
  #[inline]
  pub fn add_roomSearchableBinAttrExternal(&mut self, roomSearchableBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, roomSearchableBinAttrExternal);
  }
  #[inline]
  pub fn add_roomBinAttrExternal(&mut self, roomBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMBINATTREXTERNAL, roomBinAttrExternal);
  }
  #[inline]
  pub fn add_roomPassword(&mut self, roomPassword: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMPASSWORD, roomPassword);
  }
  #[inline]
  pub fn add_groupConfig(&mut self, groupConfig: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GroupConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_GROUPCONFIG, groupConfig);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(CreateJoinRoomRequest::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_allowedUser(&mut self, allowedUser: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ALLOWEDUSER, allowedUser);
  }
  #[inline]
  pub fn add_blockedUser(&mut self, blockedUser: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_BLOCKEDUSER, blockedUser);
  }
  #[inline]
  pub fn add_joinRoomGroupLabel(&mut self, joinRoomGroupLabel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_JOINROOMGROUPLABEL, joinRoomGroupLabel);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(CreateJoinRoomRequest::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn add_sigOptParam(&mut self, sigOptParam: flatbuffers::WIPOffset<OptParam<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<OptParam>>(CreateJoinRoomRequest::VT_SIGOPTPARAM, sigOptParam);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateJoinRoomRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateJoinRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateJoinRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreateJoinRoomRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreateJoinRoomRequest");
      ds.field("worldId", &self.worldId());
      ds.field("lobbyId", &self.lobbyId());
      ds.field("maxSlot", &self.maxSlot());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomBinAttrInternal", &self.roomBinAttrInternal());
      ds.field("roomSearchableIntAttrExternal", &self.roomSearchableIntAttrExternal());
      ds.field("roomSearchableBinAttrExternal", &self.roomSearchableBinAttrExternal());
      ds.field("roomBinAttrExternal", &self.roomBinAttrExternal());
      ds.field("roomPassword", &self.roomPassword());
      ds.field("groupConfig", &self.groupConfig());
      ds.field("passwordSlotMask", &self.passwordSlotMask());
      ds.field("allowedUser", &self.allowedUser());
      ds.field("blockedUser", &self.blockedUser());
      ds.field("joinRoomGroupLabel", &self.joinRoomGroupLabel());
      ds.field("roomMemberBinAttrInternal", &self.roomMemberBinAttrInternal());
      ds.field("teamId", &self.teamId());
      ds.field("sigOptParam", &self.sigOptParam());
      ds.finish()
  }
}
pub enum JoinRoomRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct JoinRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for JoinRoomRequest<'a> {
  type Inner = JoinRoomRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> JoinRoomRequest<'a> {
  pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
  pub const VT_ROOMPASSWORD: flatbuffers::VOffsetT = 6;
  pub const VT_JOINROOMGROUPLABEL: flatbuffers::VOffsetT = 8;
  pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 10;
  pub const VT_OPTDATA: flatbuffers::VOffsetT = 12;
  pub const VT_TEAMID: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    JoinRoomRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args JoinRoomRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<JoinRoomRequest<'bldr>> {
    let mut builder = JoinRoomRequestBuilder::new(_fbb);
    builder.add_roomId(args.roomId);
    if let Some(x) = args.optData { builder.add_optData(x); }
    if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
    if let Some(x) = args.joinRoomGroupLabel { builder.add_joinRoomGroupLabel(x); }
    if let Some(x) = args.roomPassword { builder.add_roomPassword(x); }
    builder.add_teamId(args.teamId);
    builder.finish()
  }


  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(JoinRoomRequest::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomPassword(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(JoinRoomRequest::VT_ROOMPASSWORD, None)}
  }
  #[inline]
  pub fn joinRoomGroupLabel(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(JoinRoomRequest::VT_JOINROOMGROUPLABEL, None)}
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(JoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, None)}
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(JoinRoomRequest::VT_OPTDATA, None)}
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(JoinRoomRequest::VT_TEAMID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for JoinRoomRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("roomPassword", Self::VT_ROOMPASSWORD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("joinRoomGroupLabel", Self::VT_JOINROOMGROUPLABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomMemberBinAttrInternal", Self::VT_ROOMMEMBERBINATTRINTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PresenceOptionData>>("optData", Self::VT_OPTDATA, false)?
     .visit_field::<u8>("teamId", Self::VT_TEAMID, false)?
     .finish();
    Ok(())
  }
}
pub struct JoinRoomRequestArgs<'a> {
    pub roomId: u64,
    pub roomPassword: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub joinRoomGroupLabel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a>>>,
    pub teamId: u8,
}
impl<'a> Default for JoinRoomRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    JoinRoomRequestArgs {
      roomId: 0,
      roomPassword: None,
      joinRoomGroupLabel: None,
      roomMemberBinAttrInternal: None,
      optData: None,
      teamId: 0,
    }
  }
}

pub struct JoinRoomRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> JoinRoomRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(JoinRoomRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_roomPassword(&mut self, roomPassword: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JoinRoomRequest::VT_ROOMPASSWORD, roomPassword);
  }
  #[inline]
  pub fn add_joinRoomGroupLabel(&mut self, joinRoomGroupLabel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JoinRoomRequest::VT_JOINROOMGROUPLABEL, joinRoomGroupLabel);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(JoinRoomRequest::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(JoinRoomRequest::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> JoinRoomRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    JoinRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<JoinRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for JoinRoomRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("JoinRoomRequest");
      ds.field("roomId", &self.roomId());
      ds.field("roomPassword", &self.roomPassword());
      ds.field("joinRoomGroupLabel", &self.joinRoomGroupLabel());
      ds.field("roomMemberBinAttrInternal", &self.roomMemberBinAttrInternal());
      ds.field("optData", &self.optData());
      ds.field("teamId", &self.teamId());
      ds.finish()
  }
}
pub enum LeaveRoomRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeaveRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeaveRoomRequest<'a> {
  type Inner = LeaveRoomRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LeaveRoomRequest<'a> {
  pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
  pub const VT_OPTDATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LeaveRoomRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LeaveRoomRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<LeaveRoomRequest<'bldr>> {
    let mut builder = LeaveRoomRequestBuilder::new(_fbb);
    builder.add_roomId(args.roomId);
    if let Some(x) = args.optData { builder.add_optData(x); }
    builder.finish()
  }


  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(LeaveRoomRequest::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(LeaveRoomRequest::VT_OPTDATA, None)}
  }
}

impl flatbuffers::Verifiable for LeaveRoomRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PresenceOptionData>>("optData", Self::VT_OPTDATA, false)?
     .finish();
    Ok(())
  }
}
pub struct LeaveRoomRequestArgs<'a> {
    pub roomId: u64,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a>>>,
}
impl<'a> Default for LeaveRoomRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    LeaveRoomRequestArgs {
      roomId: 0,
      optData: None,
    }
  }
}

pub struct LeaveRoomRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LeaveRoomRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(LeaveRoomRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(LeaveRoomRequest::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LeaveRoomRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LeaveRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeaveRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LeaveRoomRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LeaveRoomRequest");
      ds.field("roomId", &self.roomId());
      ds.field("optData", &self.optData());
      ds.finish()
  }
}
pub enum GetRoomDataExternalListRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetRoomDataExternalListRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRoomDataExternalListRequest<'a> {
  type Inner = GetRoomDataExternalListRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetRoomDataExternalListRequest<'a> {
  pub const VT_ROOMIDS: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRIDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetRoomDataExternalListRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetRoomDataExternalListRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetRoomDataExternalListRequest<'bldr>> {
    let mut builder = GetRoomDataExternalListRequestBuilder::new(_fbb);
    if let Some(x) = args.attrIds { builder.add_attrIds(x); }
    if let Some(x) = args.roomIds { builder.add_roomIds(x); }
    builder.finish()
  }


  #[inline]
  pub fn roomIds(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(GetRoomDataExternalListRequest::VT_ROOMIDS, None)}
  }
  #[inline]
  pub fn attrIds(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(GetRoomDataExternalListRequest::VT_ATTRIDS, None)}
  }
}

impl flatbuffers::Verifiable for GetRoomDataExternalListRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("roomIds", Self::VT_ROOMIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("attrIds", Self::VT_ATTRIDS, false)?
     .finish();
    Ok(())
  }
}
pub struct GetRoomDataExternalListRequestArgs<'a> {
    pub roomIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub attrIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for GetRoomDataExternalListRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetRoomDataExternalListRequestArgs {
      roomIds: None,
      attrIds: None,
    }
  }
}

pub struct GetRoomDataExternalListRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetRoomDataExternalListRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomIds(&mut self, roomIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRoomDataExternalListRequest::VT_ROOMIDS, roomIds);
  }
  #[inline]
  pub fn add_attrIds(&mut self, attrIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRoomDataExternalListRequest::VT_ATTRIDS, attrIds);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetRoomDataExternalListRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetRoomDataExternalListRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRoomDataExternalListRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetRoomDataExternalListRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetRoomDataExternalListRequest");
      ds.field("roomIds", &self.roomIds());
      ds.field("attrIds", &self.attrIds());
      ds.finish()
  }
}
pub enum GetRoomDataExternalListResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetRoomDataExternalListResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRoomDataExternalListResponse<'a> {
  type Inner = GetRoomDataExternalListResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetRoomDataExternalListResponse<'a> {
  pub const VT_ROOMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetRoomDataExternalListResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetRoomDataExternalListResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetRoomDataExternalListResponse<'bldr>> {
    let mut builder = GetRoomDataExternalListResponseBuilder::new(_fbb);
    if let Some(x) = args.rooms { builder.add_rooms(x); }
    builder.finish()
  }


  #[inline]
  pub fn rooms(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal>>>>(GetRoomDataExternalListResponse::VT_ROOMS, None)}
  }
}

impl flatbuffers::Verifiable for GetRoomDataExternalListResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomDataExternal>>>>("rooms", Self::VT_ROOMS, false)?
     .finish();
    Ok(())
  }
}
pub struct GetRoomDataExternalListResponseArgs<'a> {
    pub rooms: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal<'a>>>>>,
}
impl<'a> Default for GetRoomDataExternalListResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetRoomDataExternalListResponseArgs {
      rooms: None,
    }
  }
}

pub struct GetRoomDataExternalListResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetRoomDataExternalListResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_rooms(&mut self, rooms: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomDataExternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRoomDataExternalListResponse::VT_ROOMS, rooms);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetRoomDataExternalListResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetRoomDataExternalListResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRoomDataExternalListResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetRoomDataExternalListResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetRoomDataExternalListResponse");
      ds.field("rooms", &self.rooms());
      ds.finish()
  }
}
pub enum SetRoomDataExternalRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetRoomDataExternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetRoomDataExternalRequest<'a> {
  type Inner = SetRoomDataExternalRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SetRoomDataExternalRequest<'a> {
  pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
  pub const VT_ROOMSEARCHABLEINTATTREXTERNAL: flatbuffers::VOffsetT = 6;
  pub const VT_ROOMSEARCHABLEBINATTREXTERNAL: flatbuffers::VOffsetT = 8;
  pub const VT_ROOMBINATTREXTERNAL: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetRoomDataExternalRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SetRoomDataExternalRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SetRoomDataExternalRequest<'bldr>> {
    let mut builder = SetRoomDataExternalRequestBuilder::new(_fbb);
    builder.add_roomId(args.roomId);
    if let Some(x) = args.roomBinAttrExternal { builder.add_roomBinAttrExternal(x); }
    if let Some(x) = args.roomSearchableBinAttrExternal { builder.add_roomSearchableBinAttrExternal(x); }
    if let Some(x) = args.roomSearchableIntAttrExternal { builder.add_roomSearchableIntAttrExternal(x); }
    builder.finish()
  }


  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SetRoomDataExternalRequest::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomSearchableIntAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr>>>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, None)}
  }
  #[inline]
  pub fn roomSearchableBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, None)}
  }
  #[inline]
  pub fn roomBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(SetRoomDataExternalRequest::VT_ROOMBINATTREXTERNAL, None)}
  }
}

impl flatbuffers::Verifiable for SetRoomDataExternalRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntAttr>>>>("roomSearchableIntAttrExternal", Self::VT_ROOMSEARCHABLEINTATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomSearchableBinAttrExternal", Self::VT_ROOMSEARCHABLEBINATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomBinAttrExternal", Self::VT_ROOMBINATTREXTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct SetRoomDataExternalRequestArgs<'a> {
    pub roomId: u64,
    pub roomSearchableIntAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>>>,
    pub roomSearchableBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
}
impl<'a> Default for SetRoomDataExternalRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SetRoomDataExternalRequestArgs {
      roomId: 0,
      roomSearchableIntAttrExternal: None,
      roomSearchableBinAttrExternal: None,
      roomBinAttrExternal: None,
    }
  }
}

pub struct SetRoomDataExternalRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetRoomDataExternalRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SetRoomDataExternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_roomSearchableIntAttrExternal(&mut self, roomSearchableIntAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, roomSearchableIntAttrExternal);
  }
  #[inline]
  pub fn add_roomSearchableBinAttrExternal(&mut self, roomSearchableBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, roomSearchableBinAttrExternal);
  }
  #[inline]
  pub fn add_roomBinAttrExternal(&mut self, roomBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataExternalRequest::VT_ROOMBINATTREXTERNAL, roomBinAttrExternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetRoomDataExternalRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SetRoomDataExternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetRoomDataExternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SetRoomDataExternalRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SetRoomDataExternalRequest");
      ds.field("roomId", &self.roomId());
      ds.field("roomSearchableIntAttrExternal", &self.roomSearchableIntAttrExternal());
      ds.field("roomSearchableBinAttrExternal", &self.roomSearchableBinAttrExternal());
      ds.field("roomBinAttrExternal", &self.roomBinAttrExternal());
      ds.finish()
  }
}
pub enum SetRoomDataInternalRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetRoomDataInternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetRoomDataInternalRequest<'a> {
  type Inner = SetRoomDataInternalRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SetRoomDataInternalRequest<'a> {
  pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
  pub const VT_FLAGFILTER: flatbuffers::VOffsetT = 6;
  pub const VT_FLAGATTR: flatbuffers::VOffsetT = 8;
  pub const VT_ROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 10;
  pub const VT_PASSWORDCONFIG: flatbuffers::VOffsetT = 12;
  pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 14;
  pub const VT_OWNERPRIVILEGERANK: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetRoomDataInternalRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SetRoomDataInternalRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SetRoomDataInternalRequest<'bldr>> {
    let mut builder = SetRoomDataInternalRequestBuilder::new(_fbb);
    builder.add_passwordSlotMask(args.passwordSlotMask);
    builder.add_roomId(args.roomId);
    if let Some(x) = args.ownerPrivilegeRank { builder.add_ownerPrivilegeRank(x); }
    if let Some(x) = args.passwordConfig { builder.add_passwordConfig(x); }
    if let Some(x) = args.roomBinAttrInternal { builder.add_roomBinAttrInternal(x); }
    builder.add_flagAttr(args.flagAttr);
    builder.add_flagFilter(args.flagFilter);
    builder.finish()
  }


  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SetRoomDataInternalRequest::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flagFilter(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SetRoomDataInternalRequest::VT_FLAGFILTER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SetRoomDataInternalRequest::VT_FLAGATTR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(SetRoomDataInternalRequest::VT_ROOMBINATTRINTERNAL, None)}
  }
  #[inline]
  pub fn passwordConfig(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig>>>>(SetRoomDataInternalRequest::VT_PASSWORDCONFIG, None)}
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SetRoomDataInternalRequest::VT_PASSWORDSLOTMASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ownerPrivilegeRank(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SetRoomDataInternalRequest::VT_OWNERPRIVILEGERANK, None)}
  }
}

impl flatbuffers::Verifiable for SetRoomDataInternalRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<u32>("flagFilter", Self::VT_FLAGFILTER, false)?
     .visit_field::<u32>("flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomBinAttrInternal", Self::VT_ROOMBINATTRINTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig>>>>("passwordConfig", Self::VT_PASSWORDCONFIG, false)?
     .visit_field::<u64>("passwordSlotMask", Self::VT_PASSWORDSLOTMASK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("ownerPrivilegeRank", Self::VT_OWNERPRIVILEGERANK, false)?
     .finish();
    Ok(())
  }
}
pub struct SetRoomDataInternalRequestArgs<'a> {
    pub roomId: u64,
    pub flagFilter: u32,
    pub flagAttr: u32,
    pub roomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub passwordConfig: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'a>>>>>,
    pub passwordSlotMask: u64,
    pub ownerPrivilegeRank: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for SetRoomDataInternalRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SetRoomDataInternalRequestArgs {
      roomId: 0,
      flagFilter: 0,
      flagAttr: 0,
      roomBinAttrInternal: None,
      passwordConfig: None,
      passwordSlotMask: 0,
      ownerPrivilegeRank: None,
    }
  }
}

pub struct SetRoomDataInternalRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetRoomDataInternalRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SetRoomDataInternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_flagFilter(&mut self, flagFilter: u32) {
    self.fbb_.push_slot::<u32>(SetRoomDataInternalRequest::VT_FLAGFILTER, flagFilter, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(SetRoomDataInternalRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomBinAttrInternal(&mut self, roomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataInternalRequest::VT_ROOMBINATTRINTERNAL, roomBinAttrInternal);
  }
  #[inline]
  pub fn add_passwordConfig(&mut self, passwordConfig: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataInternalRequest::VT_PASSWORDCONFIG, passwordConfig);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(SetRoomDataInternalRequest::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_ownerPrivilegeRank(&mut self, ownerPrivilegeRank: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataInternalRequest::VT_OWNERPRIVILEGERANK, ownerPrivilegeRank);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetRoomDataInternalRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SetRoomDataInternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetRoomDataInternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SetRoomDataInternalRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SetRoomDataInternalRequest");
      ds.field("roomId", &self.roomId());
      ds.field("flagFilter", &self.flagFilter());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomBinAttrInternal", &self.roomBinAttrInternal());
      ds.field("passwordConfig", &self.passwordConfig());
      ds.field("passwordSlotMask", &self.passwordSlotMask());
      ds.field("ownerPrivilegeRank", &self.ownerPrivilegeRank());
      ds.finish()
  }
}
pub enum GetRoomMemberDataInternalRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetRoomMemberDataInternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRoomMemberDataInternalRequest<'a> {
  type Inner = GetRoomMemberDataInternalRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetRoomMemberDataInternalRequest<'a> {
  pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
  pub const VT_MEMBERID: flatbuffers::VOffsetT = 6;
  pub const VT_ATTRID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetRoomMemberDataInternalRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetRoomMemberDataInternalRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetRoomMemberDataInternalRequest<'bldr>> {
    let mut builder = GetRoomMemberDataInternalRequestBuilder::new(_fbb);
    builder.add_roomId(args.roomId);
    if let Some(x) = args.attrId { builder.add_attrId(x); }
    builder.add_memberId(args.memberId);
    builder.finish()
  }


  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GetRoomMemberDataInternalRequest::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn memberId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(GetRoomMemberDataInternalRequest::VT_MEMBERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn attrId(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(GetRoomMemberDataInternalRequest::VT_ATTRID, None)}
  }
}

impl flatbuffers::Verifiable for GetRoomMemberDataInternalRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<u16>("memberId", Self::VT_MEMBERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("attrId", Self::VT_ATTRID, false)?
     .finish();
    Ok(())
  }
}
pub struct GetRoomMemberDataInternalRequestArgs<'a> {
    pub roomId: u64,
    pub memberId: u16,
    pub attrId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for GetRoomMemberDataInternalRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetRoomMemberDataInternalRequestArgs {
      roomId: 0,
      memberId: 0,
      attrId: None,
    }
  }
}

pub struct GetRoomMemberDataInternalRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetRoomMemberDataInternalRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(GetRoomMemberDataInternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_memberId(&mut self, memberId: u16) {
    self.fbb_.push_slot::<u16>(GetRoomMemberDataInternalRequest::VT_MEMBERID, memberId, 0);
  }
  #[inline]
  pub fn add_attrId(&mut self, attrId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRoomMemberDataInternalRequest::VT_ATTRID, attrId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetRoomMemberDataInternalRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetRoomMemberDataInternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRoomMemberDataInternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetRoomMemberDataInternalRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetRoomMemberDataInternalRequest");
      ds.field("roomId", &self.roomId());
      ds.field("memberId", &self.memberId());
      ds.field("attrId", &self.attrId());
      ds.finish()
  }
}
pub enum SetRoomMemberDataInternalRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetRoomMemberDataInternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetRoomMemberDataInternalRequest<'a> {
  type Inner = SetRoomMemberDataInternalRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SetRoomMemberDataInternalRequest<'a> {
  pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
  pub const VT_MEMBERID: flatbuffers::VOffsetT = 6;
  pub const VT_TEAMID: flatbuffers::VOffsetT = 8;
  pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetRoomMemberDataInternalRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SetRoomMemberDataInternalRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SetRoomMemberDataInternalRequest<'bldr>> {
    let mut builder = SetRoomMemberDataInternalRequestBuilder::new(_fbb);
    builder.add_roomId(args.roomId);
    if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
    builder.add_memberId(args.memberId);
    builder.add_teamId(args.teamId);
    builder.finish()
  }


  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SetRoomMemberDataInternalRequest::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn memberId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SetRoomMemberDataInternalRequest::VT_MEMBERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SetRoomMemberDataInternalRequest::VT_TEAMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(SetRoomMemberDataInternalRequest::VT_ROOMMEMBERBINATTRINTERNAL, None)}
  }
}

impl flatbuffers::Verifiable for SetRoomMemberDataInternalRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<u16>("memberId", Self::VT_MEMBERID, false)?
     .visit_field::<u8>("teamId", Self::VT_TEAMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("roomMemberBinAttrInternal", Self::VT_ROOMMEMBERBINATTRINTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct SetRoomMemberDataInternalRequestArgs<'a> {
    pub roomId: u64,
    pub memberId: u16,
    pub teamId: u8,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
}
impl<'a> Default for SetRoomMemberDataInternalRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SetRoomMemberDataInternalRequestArgs {
      roomId: 0,
      memberId: 0,
      teamId: 0,
      roomMemberBinAttrInternal: None,
    }
  }
}

pub struct SetRoomMemberDataInternalRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetRoomMemberDataInternalRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SetRoomMemberDataInternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_memberId(&mut self, memberId: u16) {
    self.fbb_.push_slot::<u16>(SetRoomMemberDataInternalRequest::VT_MEMBERID, memberId, 0);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(SetRoomMemberDataInternalRequest::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomMemberDataInternalRequest::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetRoomMemberDataInternalRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SetRoomMemberDataInternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetRoomMemberDataInternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SetRoomMemberDataInternalRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SetRoomMemberDataInternalRequest");
      ds.field("roomId", &self.roomId());
      ds.field("memberId", &self.memberId());
      ds.field("teamId", &self.teamId());
      ds.field("roomMemberBinAttrInternal", &self.roomMemberBinAttrInternal());
      ds.finish()
  }
}
pub enum SetUserInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetUserInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetUserInfo<'a> {
  type Inner = SetUserInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SetUserInfo<'a> {
  pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
  pub const VT_USERBINATTR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetUserInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SetUserInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<SetUserInfo<'bldr>> {
    let mut builder = SetUserInfoBuilder::new(_fbb);
    if let Some(x) = args.userBinAttr { builder.add_userBinAttr(x); }
    builder.add_serverId(args.serverId);
    builder.finish()
  }


  #[inline]
  pub fn serverId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SetUserInfo::VT_SERVERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn userBinAttr(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(SetUserInfo::VT_USERBINATTR, None)}
  }
}

impl flatbuffers::Verifiable for SetUserInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("serverId", Self::VT_SERVERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>("userBinAttr", Self::VT_USERBINATTR, false)?
     .finish();
    Ok(())
  }
}
pub struct SetUserInfoArgs<'a> {
    pub serverId: u16,
    pub userBinAttr: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
}
impl<'a> Default for SetUserInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    SetUserInfoArgs {
      serverId: 0,
      userBinAttr: None,
    }
  }
}

pub struct SetUserInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetUserInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(SetUserInfo::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_userBinAttr(&mut self, userBinAttr: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetUserInfo::VT_USERBINATTR, userBinAttr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetUserInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SetUserInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetUserInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SetUserInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SetUserInfo");
      ds.field("serverId", &self.serverId());
      ds.field("userBinAttr", &self.userBinAttr());
      ds.finish()
  }
}
pub enum GetRoomDataInternalRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetRoomDataInternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRoomDataInternalRequest<'a> {
  type Inner = GetRoomDataInternalRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetRoomDataInternalRequest<'a> {
  pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetRoomDataInternalRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetRoomDataInternalRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetRoomDataInternalRequest<'bldr>> {
    let mut builder = GetRoomDataInternalRequestBuilder::new(_fbb);
    builder.add_roomId(args.roomId);
    if let Some(x) = args.attrId { builder.add_attrId(x); }
    builder.finish()
  }


  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GetRoomDataInternalRequest::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn attrId(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(GetRoomDataInternalRequest::VT_ATTRID, None)}
  }
}

impl flatbuffers::Verifiable for GetRoomDataInternalRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("attrId", Self::VT_ATTRID, false)?
     .finish();
    Ok(())
  }
}
pub struct GetRoomDataInternalRequestArgs<'a> {
    pub roomId: u64,
    pub attrId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for GetRoomDataInternalRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetRoomDataInternalRequestArgs {
      roomId: 0,
      attrId: None,
    }
  }
}

pub struct GetRoomDataInternalRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetRoomDataInternalRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(GetRoomDataInternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_attrId(&mut self, attrId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRoomDataInternalRequest::VT_ATTRID, attrId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetRoomDataInternalRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetRoomDataInternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRoomDataInternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetRoomDataInternalRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetRoomDataInternalRequest");
      ds.field("roomId", &self.roomId());
      ds.field("attrId", &self.attrId());
      ds.finish()
  }
}
pub enum RoomMemberUpdateInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomMemberUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMemberUpdateInfo<'a> {
  type Inner = RoomMemberUpdateInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomMemberUpdateInfo<'a> {
  pub const VT_ROOMMEMBERDATAINTERNAL: flatbuffers::VOffsetT = 4;
  pub const VT_EVENTCAUSE: flatbuffers::VOffsetT = 6;
  pub const VT_OPTDATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomMemberUpdateInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomMemberUpdateInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomMemberUpdateInfo<'bldr>> {
    let mut builder = RoomMemberUpdateInfoBuilder::new(_fbb);
    if let Some(x) = args.optData { builder.add_optData(x); }
    if let Some(x) = args.roomMemberDataInternal { builder.add_roomMemberDataInternal(x); }
    builder.add_eventCause(args.eventCause);
    builder.finish()
  }


  #[inline]
  pub fn roomMemberDataInternal(&self) -> Option<RoomMemberDataInternal<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>(RoomMemberUpdateInfo::VT_ROOMMEMBERDATAINTERNAL, None)}
  }
  #[inline]
  pub fn eventCause(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RoomMemberUpdateInfo::VT_EVENTCAUSE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(RoomMemberUpdateInfo::VT_OPTDATA, None)}
  }
}

impl flatbuffers::Verifiable for RoomMemberUpdateInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>("roomMemberDataInternal", Self::VT_ROOMMEMBERDATAINTERNAL, false)?
     .visit_field::<u8>("eventCause", Self::VT_EVENTCAUSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PresenceOptionData>>("optData", Self::VT_OPTDATA, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomMemberUpdateInfoArgs<'a> {
    pub roomMemberDataInternal: Option<flatbuffers::WIPOffset<RoomMemberDataInternal<'a>>>,
    pub eventCause: u8,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a>>>,
}
impl<'a> Default for RoomMemberUpdateInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomMemberUpdateInfoArgs {
      roomMemberDataInternal: None,
      eventCause: 0,
      optData: None,
    }
  }
}

pub struct RoomMemberUpdateInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomMemberUpdateInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomMemberDataInternal(&mut self, roomMemberDataInternal: flatbuffers::WIPOffset<RoomMemberDataInternal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RoomMemberDataInternal>>(RoomMemberUpdateInfo::VT_ROOMMEMBERDATAINTERNAL, roomMemberDataInternal);
  }
  #[inline]
  pub fn add_eventCause(&mut self, eventCause: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberUpdateInfo::VT_EVENTCAUSE, eventCause, 0);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(RoomMemberUpdateInfo::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomMemberUpdateInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomMemberUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMemberUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomMemberUpdateInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomMemberUpdateInfo");
      ds.field("roomMemberDataInternal", &self.roomMemberDataInternal());
      ds.field("eventCause", &self.eventCause());
      ds.field("optData", &self.optData());
      ds.finish()
  }
}
pub enum RoomUpdateInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomUpdateInfo<'a> {
  type Inner = RoomUpdateInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomUpdateInfo<'a> {
  pub const VT_EVENTCAUSE: flatbuffers::VOffsetT = 4;
  pub const VT_ERRORCODE: flatbuffers::VOffsetT = 6;
  pub const VT_OPTDATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomUpdateInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomUpdateInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomUpdateInfo<'bldr>> {
    let mut builder = RoomUpdateInfoBuilder::new(_fbb);
    if let Some(x) = args.optData { builder.add_optData(x); }
    builder.add_errorCode(args.errorCode);
    builder.add_eventCause(args.eventCause);
    builder.finish()
  }


  #[inline]
  pub fn eventCause(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RoomUpdateInfo::VT_EVENTCAUSE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn errorCode(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RoomUpdateInfo::VT_ERRORCODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(RoomUpdateInfo::VT_OPTDATA, None)}
  }
}

impl flatbuffers::Verifiable for RoomUpdateInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("eventCause", Self::VT_EVENTCAUSE, false)?
     .visit_field::<i32>("errorCode", Self::VT_ERRORCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PresenceOptionData>>("optData", Self::VT_OPTDATA, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomUpdateInfoArgs<'a> {
    pub eventCause: u8,
    pub errorCode: i32,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a>>>,
}
impl<'a> Default for RoomUpdateInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomUpdateInfoArgs {
      eventCause: 0,
      errorCode: 0,
      optData: None,
    }
  }
}

pub struct RoomUpdateInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomUpdateInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_eventCause(&mut self, eventCause: u8) {
    self.fbb_.push_slot::<u8>(RoomUpdateInfo::VT_EVENTCAUSE, eventCause, 0);
  }
  #[inline]
  pub fn add_errorCode(&mut self, errorCode: i32) {
    self.fbb_.push_slot::<i32>(RoomUpdateInfo::VT_ERRORCODE, errorCode, 0);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(RoomUpdateInfo::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomUpdateInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomUpdateInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomUpdateInfo");
      ds.field("eventCause", &self.eventCause());
      ds.field("errorCode", &self.errorCode());
      ds.field("optData", &self.optData());
      ds.finish()
  }
}
pub enum RoomDataInternalUpdateInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomDataInternalUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomDataInternalUpdateInfo<'a> {
  type Inner = RoomDataInternalUpdateInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomDataInternalUpdateInfo<'a> {
  pub const VT_NEWROOMDATAINTERNAL: flatbuffers::VOffsetT = 4;
  pub const VT_PREVFLAGATTR: flatbuffers::VOffsetT = 6;
  pub const VT_PREVROOMPASSWORDSLOTMASK: flatbuffers::VOffsetT = 8;
  pub const VT_NEWROOMGROUP: flatbuffers::VOffsetT = 10;
  pub const VT_NEWROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomDataInternalUpdateInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomDataInternalUpdateInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomDataInternalUpdateInfo<'bldr>> {
    let mut builder = RoomDataInternalUpdateInfoBuilder::new(_fbb);
    builder.add_prevRoomPasswordSlotMask(args.prevRoomPasswordSlotMask);
    if let Some(x) = args.newRoomBinAttrInternal { builder.add_newRoomBinAttrInternal(x); }
    if let Some(x) = args.newRoomGroup { builder.add_newRoomGroup(x); }
    builder.add_prevFlagAttr(args.prevFlagAttr);
    if let Some(x) = args.newRoomDataInternal { builder.add_newRoomDataInternal(x); }
    builder.finish()
  }


  #[inline]
  pub fn newRoomDataInternal(&self) -> Option<RoomDataInternal<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RoomDataInternal>>(RoomDataInternalUpdateInfo::VT_NEWROOMDATAINTERNAL, None)}
  }
  #[inline]
  pub fn prevFlagAttr(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomDataInternalUpdateInfo::VT_PREVFLAGATTR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn prevRoomPasswordSlotMask(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RoomDataInternalUpdateInfo::VT_PREVROOMPASSWORDSLOTMASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn newRoomGroup(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomDataInternalUpdateInfo::VT_NEWROOMGROUP, None)}
  }
  #[inline]
  pub fn newRoomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(RoomDataInternalUpdateInfo::VT_NEWROOMBINATTRINTERNAL, None)}
  }
}

impl flatbuffers::Verifiable for RoomDataInternalUpdateInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<RoomDataInternal>>("newRoomDataInternal", Self::VT_NEWROOMDATAINTERNAL, false)?
     .visit_field::<u32>("prevFlagAttr", Self::VT_PREVFLAGATTR, false)?
     .visit_field::<u64>("prevRoomPasswordSlotMask", Self::VT_PREVROOMPASSWORDSLOTMASK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("newRoomGroup", Self::VT_NEWROOMGROUP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("newRoomBinAttrInternal", Self::VT_NEWROOMBINATTRINTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomDataInternalUpdateInfoArgs<'a> {
    pub newRoomDataInternal: Option<flatbuffers::WIPOffset<RoomDataInternal<'a>>>,
    pub prevFlagAttr: u32,
    pub prevRoomPasswordSlotMask: u64,
    pub newRoomGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub newRoomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for RoomDataInternalUpdateInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomDataInternalUpdateInfoArgs {
      newRoomDataInternal: None,
      prevFlagAttr: 0,
      prevRoomPasswordSlotMask: 0,
      newRoomGroup: None,
      newRoomBinAttrInternal: None,
    }
  }
}

pub struct RoomDataInternalUpdateInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomDataInternalUpdateInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_newRoomDataInternal(&mut self, newRoomDataInternal: flatbuffers::WIPOffset<RoomDataInternal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RoomDataInternal>>(RoomDataInternalUpdateInfo::VT_NEWROOMDATAINTERNAL, newRoomDataInternal);
  }
  #[inline]
  pub fn add_prevFlagAttr(&mut self, prevFlagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternalUpdateInfo::VT_PREVFLAGATTR, prevFlagAttr, 0);
  }
  #[inline]
  pub fn add_prevRoomPasswordSlotMask(&mut self, prevRoomPasswordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternalUpdateInfo::VT_PREVROOMPASSWORDSLOTMASK, prevRoomPasswordSlotMask, 0);
  }
  #[inline]
  pub fn add_newRoomGroup(&mut self, newRoomGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternalUpdateInfo::VT_NEWROOMGROUP, newRoomGroup);
  }
  #[inline]
  pub fn add_newRoomBinAttrInternal(&mut self, newRoomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternalUpdateInfo::VT_NEWROOMBINATTRINTERNAL, newRoomBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomDataInternalUpdateInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomDataInternalUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomDataInternalUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomDataInternalUpdateInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomDataInternalUpdateInfo");
      ds.field("newRoomDataInternal", &self.newRoomDataInternal());
      ds.field("prevFlagAttr", &self.prevFlagAttr());
      ds.field("prevRoomPasswordSlotMask", &self.prevRoomPasswordSlotMask());
      ds.field("newRoomGroup", &self.newRoomGroup());
      ds.field("newRoomBinAttrInternal", &self.newRoomBinAttrInternal());
      ds.finish()
  }
}
pub enum RoomMemberDataInternalUpdateInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomMemberDataInternalUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMemberDataInternalUpdateInfo<'a> {
  type Inner = RoomMemberDataInternalUpdateInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomMemberDataInternalUpdateInfo<'a> {
  pub const VT_NEWROOMMEMBERDATAINTERNAL: flatbuffers::VOffsetT = 4;
  pub const VT_PREVFLAGATTR: flatbuffers::VOffsetT = 6;
  pub const VT_PREVTEAMID: flatbuffers::VOffsetT = 8;
  pub const VT_NEWROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomMemberDataInternalUpdateInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomMemberDataInternalUpdateInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomMemberDataInternalUpdateInfo<'bldr>> {
    let mut builder = RoomMemberDataInternalUpdateInfoBuilder::new(_fbb);
    if let Some(x) = args.newRoomMemberBinAttrInternal { builder.add_newRoomMemberBinAttrInternal(x); }
    builder.add_prevFlagAttr(args.prevFlagAttr);
    if let Some(x) = args.newRoomMemberDataInternal { builder.add_newRoomMemberDataInternal(x); }
    builder.add_prevTeamId(args.prevTeamId);
    builder.finish()
  }


  #[inline]
  pub fn newRoomMemberDataInternal(&self) -> Option<RoomMemberDataInternal<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>(RoomMemberDataInternalUpdateInfo::VT_NEWROOMMEMBERDATAINTERNAL, None)}
  }
  #[inline]
  pub fn prevFlagAttr(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RoomMemberDataInternalUpdateInfo::VT_PREVFLAGATTR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn prevTeamId(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RoomMemberDataInternalUpdateInfo::VT_PREVTEAMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn newRoomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(RoomMemberDataInternalUpdateInfo::VT_NEWROOMMEMBERBINATTRINTERNAL, None)}
  }
}

impl flatbuffers::Verifiable for RoomMemberDataInternalUpdateInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>("newRoomMemberDataInternal", Self::VT_NEWROOMMEMBERDATAINTERNAL, false)?
     .visit_field::<u32>("prevFlagAttr", Self::VT_PREVFLAGATTR, false)?
     .visit_field::<u8>("prevTeamId", Self::VT_PREVTEAMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("newRoomMemberBinAttrInternal", Self::VT_NEWROOMMEMBERBINATTRINTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomMemberDataInternalUpdateInfoArgs<'a> {
    pub newRoomMemberDataInternal: Option<flatbuffers::WIPOffset<RoomMemberDataInternal<'a>>>,
    pub prevFlagAttr: u32,
    pub prevTeamId: u8,
    pub newRoomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for RoomMemberDataInternalUpdateInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomMemberDataInternalUpdateInfoArgs {
      newRoomMemberDataInternal: None,
      prevFlagAttr: 0,
      prevTeamId: 0,
      newRoomMemberBinAttrInternal: None,
    }
  }
}

pub struct RoomMemberDataInternalUpdateInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomMemberDataInternalUpdateInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_newRoomMemberDataInternal(&mut self, newRoomMemberDataInternal: flatbuffers::WIPOffset<RoomMemberDataInternal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RoomMemberDataInternal>>(RoomMemberDataInternalUpdateInfo::VT_NEWROOMMEMBERDATAINTERNAL, newRoomMemberDataInternal);
  }
  #[inline]
  pub fn add_prevFlagAttr(&mut self, prevFlagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomMemberDataInternalUpdateInfo::VT_PREVFLAGATTR, prevFlagAttr, 0);
  }
  #[inline]
  pub fn add_prevTeamId(&mut self, prevTeamId: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternalUpdateInfo::VT_PREVTEAMID, prevTeamId, 0);
  }
  #[inline]
  pub fn add_newRoomMemberBinAttrInternal(&mut self, newRoomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMemberDataInternalUpdateInfo::VT_NEWROOMMEMBERBINATTRINTERNAL, newRoomMemberBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomMemberDataInternalUpdateInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomMemberDataInternalUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMemberDataInternalUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomMemberDataInternalUpdateInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomMemberDataInternalUpdateInfo");
      ds.field("newRoomMemberDataInternal", &self.newRoomMemberDataInternal());
      ds.field("prevFlagAttr", &self.prevFlagAttr());
      ds.field("prevTeamId", &self.prevTeamId());
      ds.field("newRoomMemberBinAttrInternal", &self.newRoomMemberBinAttrInternal());
      ds.finish()
  }
}
pub enum GetPingInfoResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetPingInfoResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPingInfoResponse<'a> {
  type Inner = GetPingInfoResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetPingInfoResponse<'a> {
  pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
  pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
  pub const VT_ROOMID: flatbuffers::VOffsetT = 8;
  pub const VT_RTT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetPingInfoResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetPingInfoResponseArgs
  ) -> flatbuffers::WIPOffset<GetPingInfoResponse<'bldr>> {
    let mut builder = GetPingInfoResponseBuilder::new(_fbb);
    builder.add_roomId(args.roomId);
    builder.add_rtt(args.rtt);
    builder.add_worldId(args.worldId);
    builder.add_serverId(args.serverId);
    builder.finish()
  }


  #[inline]
  pub fn serverId(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(GetPingInfoResponse::VT_SERVERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetPingInfoResponse::VT_WORLDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GetPingInfoResponse::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rtt(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetPingInfoResponse::VT_RTT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetPingInfoResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("serverId", Self::VT_SERVERID, false)?
     .visit_field::<u32>("worldId", Self::VT_WORLDID, false)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<u32>("rtt", Self::VT_RTT, false)?
     .finish();
    Ok(())
  }
}
pub struct GetPingInfoResponseArgs {
    pub serverId: u16,
    pub worldId: u32,
    pub roomId: u64,
    pub rtt: u32,
}
impl<'a> Default for GetPingInfoResponseArgs {
  #[inline]
  fn default() -> Self {
    GetPingInfoResponseArgs {
      serverId: 0,
      worldId: 0,
      roomId: 0,
      rtt: 0,
    }
  }
}

pub struct GetPingInfoResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetPingInfoResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(GetPingInfoResponse::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(GetPingInfoResponse::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(GetPingInfoResponse::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_rtt(&mut self, rtt: u32) {
    self.fbb_.push_slot::<u32>(GetPingInfoResponse::VT_RTT, rtt, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetPingInfoResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetPingInfoResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPingInfoResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetPingInfoResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetPingInfoResponse");
      ds.field("serverId", &self.serverId());
      ds.field("worldId", &self.worldId());
      ds.field("roomId", &self.roomId());
      ds.field("rtt", &self.rtt());
      ds.finish()
  }
}
pub enum SendRoomMessageRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SendRoomMessageRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SendRoomMessageRequest<'a> {
  type Inner = SendRoomMessageRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SendRoomMessageRequest<'a> {
  pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
  pub const VT_CASTTYPE: flatbuffers::VOffsetT = 6;
  pub const VT_DST: flatbuffers::VOffsetT = 8;
  pub const VT_MSG: flatbuffers::VOffsetT = 10;
  pub const VT_OPTION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SendRoomMessageRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SendRoomMessageRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SendRoomMessageRequest<'bldr>> {
    let mut builder = SendRoomMessageRequestBuilder::new(_fbb);
    builder.add_roomId(args.roomId);
    if let Some(x) = args.msg { builder.add_msg(x); }
    if let Some(x) = args.dst { builder.add_dst(x); }
    builder.add_option(args.option);
    builder.add_castType(args.castType);
    builder.finish()
  }


  #[inline]
  pub fn roomId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SendRoomMessageRequest::VT_ROOMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn castType(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SendRoomMessageRequest::VT_CASTTYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn dst(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SendRoomMessageRequest::VT_DST, None)}
  }
  #[inline]
  pub fn msg(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SendRoomMessageRequest::VT_MSG, None)}
  }
  #[inline]
  pub fn option(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SendRoomMessageRequest::VT_OPTION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SendRoomMessageRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("roomId", Self::VT_ROOMID, false)?
     .visit_field::<u8>("castType", Self::VT_CASTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("dst", Self::VT_DST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("msg", Self::VT_MSG, false)?
     .visit_field::<u8>("option", Self::VT_OPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct SendRoomMessageRequestArgs<'a> {
    pub roomId: u64,
    pub castType: u8,
    pub dst: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub msg: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub option: u8,
}
impl<'a> Default for SendRoomMessageRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SendRoomMessageRequestArgs {
      roomId: 0,
      castType: 0,
      dst: None,
      msg: None,
      option: 0,
    }
  }
}

pub struct SendRoomMessageRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendRoomMessageRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SendRoomMessageRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_castType(&mut self, castType: u8) {
    self.fbb_.push_slot::<u8>(SendRoomMessageRequest::VT_CASTTYPE, castType, 0);
  }
  #[inline]
  pub fn add_dst(&mut self, dst: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendRoomMessageRequest::VT_DST, dst);
  }
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendRoomMessageRequest::VT_MSG, msg);
  }
  #[inline]
  pub fn add_option(&mut self, option: u8) {
    self.fbb_.push_slot::<u8>(SendRoomMessageRequest::VT_OPTION, option, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SendRoomMessageRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SendRoomMessageRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SendRoomMessageRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SendRoomMessageRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SendRoomMessageRequest");
      ds.field("roomId", &self.roomId());
      ds.field("castType", &self.castType());
      ds.field("dst", &self.dst());
      ds.field("msg", &self.msg());
      ds.field("option", &self.option());
      ds.finish()
  }
}
pub enum RoomMessageInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomMessageInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMessageInfo<'a> {
  type Inner = RoomMessageInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RoomMessageInfo<'a> {
  pub const VT_FILTERED: flatbuffers::VOffsetT = 4;
  pub const VT_CASTTYPE: flatbuffers::VOffsetT = 6;
  pub const VT_DST: flatbuffers::VOffsetT = 8;
  pub const VT_SRCMEMBER: flatbuffers::VOffsetT = 10;
  pub const VT_MSG: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RoomMessageInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RoomMessageInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<RoomMessageInfo<'bldr>> {
    let mut builder = RoomMessageInfoBuilder::new(_fbb);
    if let Some(x) = args.msg { builder.add_msg(x); }
    if let Some(x) = args.srcMember { builder.add_srcMember(x); }
    if let Some(x) = args.dst { builder.add_dst(x); }
    builder.add_castType(args.castType);
    builder.add_filtered(args.filtered);
    builder.finish()
  }


  #[inline]
  pub fn filtered(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RoomMessageInfo::VT_FILTERED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn castType(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RoomMessageInfo::VT_CASTTYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn dst(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(RoomMessageInfo::VT_DST, None)}
  }
  #[inline]
  pub fn srcMember(&self) -> Option<UserInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo>>(RoomMessageInfo::VT_SRCMEMBER, None)}
  }
  #[inline]
  pub fn msg(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomMessageInfo::VT_MSG, None)}
  }
}

impl flatbuffers::Verifiable for RoomMessageInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("filtered", Self::VT_FILTERED, false)?
     .visit_field::<u8>("castType", Self::VT_CASTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("dst", Self::VT_DST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<UserInfo>>("srcMember", Self::VT_SRCMEMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("msg", Self::VT_MSG, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomMessageInfoArgs<'a> {
    pub filtered: bool,
    pub castType: u8,
    pub dst: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub srcMember: Option<flatbuffers::WIPOffset<UserInfo<'a>>>,
    pub msg: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RoomMessageInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    RoomMessageInfoArgs {
      filtered: false,
      castType: 0,
      dst: None,
      srcMember: None,
      msg: None,
    }
  }
}

pub struct RoomMessageInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RoomMessageInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_filtered(&mut self, filtered: bool) {
    self.fbb_.push_slot::<bool>(RoomMessageInfo::VT_FILTERED, filtered, false);
  }
  #[inline]
  pub fn add_castType(&mut self, castType: u8) {
    self.fbb_.push_slot::<u8>(RoomMessageInfo::VT_CASTTYPE, castType, 0);
  }
  #[inline]
  pub fn add_dst(&mut self, dst: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMessageInfo::VT_DST, dst);
  }
  #[inline]
  pub fn add_srcMember(&mut self, srcMember: flatbuffers::WIPOffset<UserInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo>>(RoomMessageInfo::VT_SRCMEMBER, srcMember);
  }
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMessageInfo::VT_MSG, msg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RoomMessageInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RoomMessageInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMessageInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RoomMessageInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RoomMessageInfo");
      ds.field("filtered", &self.filtered());
      ds.field("castType", &self.castType());
      ds.field("dst", &self.dst());
      ds.field("srcMember", &self.srcMember());
      ds.field("msg", &self.msg());
      ds.finish()
  }
}
pub enum MessageDetailsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MessageDetails<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MessageDetails<'a> {
  type Inner = MessageDetails<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MessageDetails<'a> {
  pub const VT_COMMUNICATIONID: flatbuffers::VOffsetT = 4;
  pub const VT_MSGID: flatbuffers::VOffsetT = 6;
  pub const VT_MAINTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_SUBTYPE: flatbuffers::VOffsetT = 10;
  pub const VT_MSGFEATURES: flatbuffers::VOffsetT = 12;
  pub const VT_SUBJECT: flatbuffers::VOffsetT = 14;
  pub const VT_BODY: flatbuffers::VOffsetT = 16;
  pub const VT_DATA: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MessageDetails { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MessageDetailsArgs<'args>
  ) -> flatbuffers::WIPOffset<MessageDetails<'bldr>> {
    let mut builder = MessageDetailsBuilder::new(_fbb);
    builder.add_msgId(args.msgId);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.subject { builder.add_subject(x); }
    builder.add_msgFeatures(args.msgFeatures);
    if let Some(x) = args.communicationId { builder.add_communicationId(x); }
    builder.add_subType(args.subType);
    builder.add_mainType(args.mainType);
    builder.finish()
  }


  #[inline]
  pub fn communicationId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MessageDetails::VT_COMMUNICATIONID, None)}
  }
  #[inline]
  pub fn msgId(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(MessageDetails::VT_MSGID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn mainType(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(MessageDetails::VT_MAINTYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn subType(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(MessageDetails::VT_SUBTYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn msgFeatures(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MessageDetails::VT_MSGFEATURES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn subject(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MessageDetails::VT_SUBJECT, None)}
  }
  #[inline]
  pub fn body(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MessageDetails::VT_BODY, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MessageDetails::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for MessageDetails<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("communicationId", Self::VT_COMMUNICATIONID, false)?
     .visit_field::<u64>("msgId", Self::VT_MSGID, false)?
     .visit_field::<u16>("mainType", Self::VT_MAINTYPE, false)?
     .visit_field::<u16>("subType", Self::VT_SUBTYPE, false)?
     .visit_field::<u32>("msgFeatures", Self::VT_MSGFEATURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subject", Self::VT_SUBJECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct MessageDetailsArgs<'a> {
    pub communicationId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgId: u64,
    pub mainType: u16,
    pub subType: u16,
    pub msgFeatures: u32,
    pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
    pub body: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MessageDetailsArgs<'a> {
  #[inline]
  fn default() -> Self {
    MessageDetailsArgs {
      communicationId: None,
      msgId: 0,
      mainType: 0,
      subType: 0,
      msgFeatures: 0,
      subject: None,
      body: None,
      data: None,
    }
  }
}

pub struct MessageDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageDetailsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_communicationId(&mut self, communicationId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageDetails::VT_COMMUNICATIONID, communicationId);
  }
  #[inline]
  pub fn add_msgId(&mut self, msgId: u64) {
    self.fbb_.push_slot::<u64>(MessageDetails::VT_MSGID, msgId, 0);
  }
  #[inline]
  pub fn add_mainType(&mut self, mainType: u16) {
    self.fbb_.push_slot::<u16>(MessageDetails::VT_MAINTYPE, mainType, 0);
  }
  #[inline]
  pub fn add_subType(&mut self, subType: u16) {
    self.fbb_.push_slot::<u16>(MessageDetails::VT_SUBTYPE, subType, 0);
  }
  #[inline]
  pub fn add_msgFeatures(&mut self, msgFeatures: u32) {
    self.fbb_.push_slot::<u32>(MessageDetails::VT_MSGFEATURES, msgFeatures, 0);
  }
  #[inline]
  pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageDetails::VT_SUBJECT, subject);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageDetails::VT_BODY, body);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageDetails::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MessageDetailsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MessageDetailsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MessageDetails<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MessageDetails<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MessageDetails");
      ds.field("communicationId", &self.communicationId());
      ds.field("msgId", &self.msgId());
      ds.field("mainType", &self.mainType());
      ds.field("subType", &self.subType());
      ds.field("msgFeatures", &self.msgFeatures());
      ds.field("subject", &self.subject());
      ds.field("body", &self.body());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum SendMessageRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SendMessageRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SendMessageRequest<'a> {
  type Inner = SendMessageRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SendMessageRequest<'a> {
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;
  pub const VT_NPIDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SendMessageRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SendMessageRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SendMessageRequest<'bldr>> {
    let mut builder = SendMessageRequestBuilder::new(_fbb);
    if let Some(x) = args.npids { builder.add_npids(x); }
    if let Some(x) = args.message { builder.add_message(x); }
    builder.finish()
  }


  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SendMessageRequest::VT_MESSAGE, None)}
  }
  pub fn message_nested_flatbuffer(&'a self) -> Option<MessageDetails<'a>> {
    self.message().map(|data| {
      use flatbuffers::Follow;
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid flatbuffer in this slot
      unsafe { <flatbuffers::ForwardsUOffset<MessageDetails<'a>>>::follow(data.bytes(), 0) }
    })
  }
  #[inline]
  pub fn npids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SendMessageRequest::VT_NPIDS, None)}
  }
}

impl flatbuffers::Verifiable for SendMessageRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("message", Self::VT_MESSAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("npids", Self::VT_NPIDS, false)?
     .finish();
    Ok(())
  }
}
pub struct SendMessageRequestArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub npids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SendMessageRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SendMessageRequestArgs {
      message: None,
      npids: None,
    }
  }
}

pub struct SendMessageRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendMessageRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendMessageRequest::VT_MESSAGE, message);
  }
  #[inline]
  pub fn add_npids(&mut self, npids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendMessageRequest::VT_NPIDS, npids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SendMessageRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SendMessageRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SendMessageRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SendMessageRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SendMessageRequest");
      ds.field("message", &self.message());
      ds.field("npids", &self.npids());
      ds.finish()
  }
}
pub enum BoardInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoardInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoardInfo<'a> {
  type Inner = BoardInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoardInfo<'a> {
  pub const VT_RANKLIMIT: flatbuffers::VOffsetT = 4;
  pub const VT_UPDATEMODE: flatbuffers::VOffsetT = 6;
  pub const VT_SORTMODE: flatbuffers::VOffsetT = 8;
  pub const VT_UPLOADNUMLIMIT: flatbuffers::VOffsetT = 10;
  pub const VT_UPLOADSIZELIMIT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoardInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoardInfoArgs
  ) -> flatbuffers::WIPOffset<BoardInfo<'bldr>> {
    let mut builder = BoardInfoBuilder::new(_fbb);
    builder.add_uploadSizeLimit(args.uploadSizeLimit);
    builder.add_uploadNumLimit(args.uploadNumLimit);
    builder.add_sortMode(args.sortMode);
    builder.add_updateMode(args.updateMode);
    builder.add_rankLimit(args.rankLimit);
    builder.finish()
  }


  #[inline]
  pub fn rankLimit(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(BoardInfo::VT_RANKLIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn updateMode(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(BoardInfo::VT_UPDATEMODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sortMode(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(BoardInfo::VT_SORTMODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn uploadNumLimit(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(BoardInfo::VT_UPLOADNUMLIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn uploadSizeLimit(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(BoardInfo::VT_UPLOADSIZELIMIT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BoardInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("rankLimit", Self::VT_RANKLIMIT, false)?
     .visit_field::<u32>("updateMode", Self::VT_UPDATEMODE, false)?
     .visit_field::<u32>("sortMode", Self::VT_SORTMODE, false)?
     .visit_field::<u32>("uploadNumLimit", Self::VT_UPLOADNUMLIMIT, false)?
     .visit_field::<u32>("uploadSizeLimit", Self::VT_UPLOADSIZELIMIT, false)?
     .finish();
    Ok(())
  }
}
pub struct BoardInfoArgs {
    pub rankLimit: u32,
    pub updateMode: u32,
    pub sortMode: u32,
    pub uploadNumLimit: u32,
    pub uploadSizeLimit: u32,
}
impl<'a> Default for BoardInfoArgs {
  #[inline]
  fn default() -> Self {
    BoardInfoArgs {
      rankLimit: 0,
      updateMode: 0,
      sortMode: 0,
      uploadNumLimit: 0,
      uploadSizeLimit: 0,
    }
  }
}

pub struct BoardInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoardInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_rankLimit(&mut self, rankLimit: u32) {
    self.fbb_.push_slot::<u32>(BoardInfo::VT_RANKLIMIT, rankLimit, 0);
  }
  #[inline]
  pub fn add_updateMode(&mut self, updateMode: u32) {
    self.fbb_.push_slot::<u32>(BoardInfo::VT_UPDATEMODE, updateMode, 0);
  }
  #[inline]
  pub fn add_sortMode(&mut self, sortMode: u32) {
    self.fbb_.push_slot::<u32>(BoardInfo::VT_SORTMODE, sortMode, 0);
  }
  #[inline]
  pub fn add_uploadNumLimit(&mut self, uploadNumLimit: u32) {
    self.fbb_.push_slot::<u32>(BoardInfo::VT_UPLOADNUMLIMIT, uploadNumLimit, 0);
  }
  #[inline]
  pub fn add_uploadSizeLimit(&mut self, uploadSizeLimit: u32) {
    self.fbb_.push_slot::<u32>(BoardInfo::VT_UPLOADSIZELIMIT, uploadSizeLimit, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoardInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoardInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoardInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoardInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoardInfo");
      ds.field("rankLimit", &self.rankLimit());
      ds.field("updateMode", &self.updateMode());
      ds.field("sortMode", &self.sortMode());
      ds.field("uploadNumLimit", &self.uploadNumLimit());
      ds.field("uploadSizeLimit", &self.uploadSizeLimit());
      ds.finish()
  }
}
pub enum RecordScoreRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RecordScoreRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RecordScoreRequest<'a> {
  type Inner = RecordScoreRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RecordScoreRequest<'a> {
  pub const VT_BOARDID: flatbuffers::VOffsetT = 4;
  pub const VT_PCID: flatbuffers::VOffsetT = 6;
  pub const VT_SCORE: flatbuffers::VOffsetT = 8;
  pub const VT_COMMENT: flatbuffers::VOffsetT = 10;
  pub const VT_DATA: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RecordScoreRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RecordScoreRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<RecordScoreRequest<'bldr>> {
    let mut builder = RecordScoreRequestBuilder::new(_fbb);
    builder.add_score(args.score);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.comment { builder.add_comment(x); }
    builder.add_pcId(args.pcId);
    builder.add_boardId(args.boardId);
    builder.finish()
  }


  #[inline]
  pub fn boardId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RecordScoreRequest::VT_BOARDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pcId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RecordScoreRequest::VT_PCID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn score(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RecordScoreRequest::VT_SCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn comment(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RecordScoreRequest::VT_COMMENT, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RecordScoreRequest::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for RecordScoreRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("boardId", Self::VT_BOARDID, false)?
     .visit_field::<i32>("pcId", Self::VT_PCID, false)?
     .visit_field::<i64>("score", Self::VT_SCORE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comment", Self::VT_COMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct RecordScoreRequestArgs<'a> {
    pub boardId: u32,
    pub pcId: i32,
    pub score: i64,
    pub comment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RecordScoreRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    RecordScoreRequestArgs {
      boardId: 0,
      pcId: 0,
      score: 0,
      comment: None,
      data: None,
    }
  }
}

pub struct RecordScoreRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RecordScoreRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_boardId(&mut self, boardId: u32) {
    self.fbb_.push_slot::<u32>(RecordScoreRequest::VT_BOARDID, boardId, 0);
  }
  #[inline]
  pub fn add_pcId(&mut self, pcId: i32) {
    self.fbb_.push_slot::<i32>(RecordScoreRequest::VT_PCID, pcId, 0);
  }
  #[inline]
  pub fn add_score(&mut self, score: i64) {
    self.fbb_.push_slot::<i64>(RecordScoreRequest::VT_SCORE, score, 0);
  }
  #[inline]
  pub fn add_comment(&mut self, comment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecordScoreRequest::VT_COMMENT, comment);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecordScoreRequest::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RecordScoreRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RecordScoreRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RecordScoreRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RecordScoreRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RecordScoreRequest");
      ds.field("boardId", &self.boardId());
      ds.field("pcId", &self.pcId());
      ds.field("score", &self.score());
      ds.field("comment", &self.comment());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum GetScoreRangeRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetScoreRangeRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetScoreRangeRequest<'a> {
  type Inner = GetScoreRangeRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetScoreRangeRequest<'a> {
  pub const VT_BOARDID: flatbuffers::VOffsetT = 4;
  pub const VT_STARTRANK: flatbuffers::VOffsetT = 6;
  pub const VT_NUMRANKS: flatbuffers::VOffsetT = 8;
  pub const VT_WITHCOMMENT: flatbuffers::VOffsetT = 10;
  pub const VT_WITHGAMEINFO: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetScoreRangeRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetScoreRangeRequestArgs
  ) -> flatbuffers::WIPOffset<GetScoreRangeRequest<'bldr>> {
    let mut builder = GetScoreRangeRequestBuilder::new(_fbb);
    builder.add_numRanks(args.numRanks);
    builder.add_startRank(args.startRank);
    builder.add_boardId(args.boardId);
    builder.add_withGameInfo(args.withGameInfo);
    builder.add_withComment(args.withComment);
    builder.finish()
  }


  #[inline]
  pub fn boardId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetScoreRangeRequest::VT_BOARDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn startRank(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetScoreRangeRequest::VT_STARTRANK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn numRanks(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetScoreRangeRequest::VT_NUMRANKS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn withComment(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GetScoreRangeRequest::VT_WITHCOMMENT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn withGameInfo(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GetScoreRangeRequest::VT_WITHGAMEINFO, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetScoreRangeRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("boardId", Self::VT_BOARDID, false)?
     .visit_field::<u32>("startRank", Self::VT_STARTRANK, false)?
     .visit_field::<u32>("numRanks", Self::VT_NUMRANKS, false)?
     .visit_field::<bool>("withComment", Self::VT_WITHCOMMENT, false)?
     .visit_field::<bool>("withGameInfo", Self::VT_WITHGAMEINFO, false)?
     .finish();
    Ok(())
  }
}
pub struct GetScoreRangeRequestArgs {
    pub boardId: u32,
    pub startRank: u32,
    pub numRanks: u32,
    pub withComment: bool,
    pub withGameInfo: bool,
}
impl<'a> Default for GetScoreRangeRequestArgs {
  #[inline]
  fn default() -> Self {
    GetScoreRangeRequestArgs {
      boardId: 0,
      startRank: 0,
      numRanks: 0,
      withComment: false,
      withGameInfo: false,
    }
  }
}

pub struct GetScoreRangeRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetScoreRangeRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_boardId(&mut self, boardId: u32) {
    self.fbb_.push_slot::<u32>(GetScoreRangeRequest::VT_BOARDID, boardId, 0);
  }
  #[inline]
  pub fn add_startRank(&mut self, startRank: u32) {
    self.fbb_.push_slot::<u32>(GetScoreRangeRequest::VT_STARTRANK, startRank, 0);
  }
  #[inline]
  pub fn add_numRanks(&mut self, numRanks: u32) {
    self.fbb_.push_slot::<u32>(GetScoreRangeRequest::VT_NUMRANKS, numRanks, 0);
  }
  #[inline]
  pub fn add_withComment(&mut self, withComment: bool) {
    self.fbb_.push_slot::<bool>(GetScoreRangeRequest::VT_WITHCOMMENT, withComment, false);
  }
  #[inline]
  pub fn add_withGameInfo(&mut self, withGameInfo: bool) {
    self.fbb_.push_slot::<bool>(GetScoreRangeRequest::VT_WITHGAMEINFO, withGameInfo, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetScoreRangeRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetScoreRangeRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetScoreRangeRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetScoreRangeRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetScoreRangeRequest");
      ds.field("boardId", &self.boardId());
      ds.field("startRank", &self.startRank());
      ds.field("numRanks", &self.numRanks());
      ds.field("withComment", &self.withComment());
      ds.field("withGameInfo", &self.withGameInfo());
      ds.finish()
  }
}
pub enum ScoreNpIdPcIdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScoreNpIdPcId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScoreNpIdPcId<'a> {
  type Inner = ScoreNpIdPcId<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ScoreNpIdPcId<'a> {
  pub const VT_NPID: flatbuffers::VOffsetT = 4;
  pub const VT_PCID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScoreNpIdPcId { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ScoreNpIdPcIdArgs<'args>
  ) -> flatbuffers::WIPOffset<ScoreNpIdPcId<'bldr>> {
    let mut builder = ScoreNpIdPcIdBuilder::new(_fbb);
    builder.add_pcId(args.pcId);
    if let Some(x) = args.npid { builder.add_npid(x); }
    builder.finish()
  }


  #[inline]
  pub fn npid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ScoreNpIdPcId::VT_NPID, None)}
  }
  #[inline]
  pub fn pcId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScoreNpIdPcId::VT_PCID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ScoreNpIdPcId<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("npid", Self::VT_NPID, false)?
     .visit_field::<i32>("pcId", Self::VT_PCID, false)?
     .finish();
    Ok(())
  }
}
pub struct ScoreNpIdPcIdArgs<'a> {
    pub npid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pcId: i32,
}
impl<'a> Default for ScoreNpIdPcIdArgs<'a> {
  #[inline]
  fn default() -> Self {
    ScoreNpIdPcIdArgs {
      npid: None,
      pcId: 0,
    }
  }
}

pub struct ScoreNpIdPcIdBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ScoreNpIdPcIdBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_npid(&mut self, npid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScoreNpIdPcId::VT_NPID, npid);
  }
  #[inline]
  pub fn add_pcId(&mut self, pcId: i32) {
    self.fbb_.push_slot::<i32>(ScoreNpIdPcId::VT_PCID, pcId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ScoreNpIdPcIdBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ScoreNpIdPcIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScoreNpIdPcId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScoreNpIdPcId<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScoreNpIdPcId");
      ds.field("npid", &self.npid());
      ds.field("pcId", &self.pcId());
      ds.finish()
  }
}
pub enum GetScoreNpIdRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetScoreNpIdRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetScoreNpIdRequest<'a> {
  type Inner = GetScoreNpIdRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetScoreNpIdRequest<'a> {
  pub const VT_BOARDID: flatbuffers::VOffsetT = 4;
  pub const VT_NPIDS: flatbuffers::VOffsetT = 6;
  pub const VT_WITHCOMMENT: flatbuffers::VOffsetT = 8;
  pub const VT_WITHGAMEINFO: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetScoreNpIdRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetScoreNpIdRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetScoreNpIdRequest<'bldr>> {
    let mut builder = GetScoreNpIdRequestBuilder::new(_fbb);
    if let Some(x) = args.npids { builder.add_npids(x); }
    builder.add_boardId(args.boardId);
    builder.add_withGameInfo(args.withGameInfo);
    builder.add_withComment(args.withComment);
    builder.finish()
  }


  #[inline]
  pub fn boardId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetScoreNpIdRequest::VT_BOARDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn npids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScoreNpIdPcId<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScoreNpIdPcId>>>>(GetScoreNpIdRequest::VT_NPIDS, None)}
  }
  #[inline]
  pub fn withComment(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GetScoreNpIdRequest::VT_WITHCOMMENT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn withGameInfo(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GetScoreNpIdRequest::VT_WITHGAMEINFO, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetScoreNpIdRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("boardId", Self::VT_BOARDID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ScoreNpIdPcId>>>>("npids", Self::VT_NPIDS, false)?
     .visit_field::<bool>("withComment", Self::VT_WITHCOMMENT, false)?
     .visit_field::<bool>("withGameInfo", Self::VT_WITHGAMEINFO, false)?
     .finish();
    Ok(())
  }
}
pub struct GetScoreNpIdRequestArgs<'a> {
    pub boardId: u32,
    pub npids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScoreNpIdPcId<'a>>>>>,
    pub withComment: bool,
    pub withGameInfo: bool,
}
impl<'a> Default for GetScoreNpIdRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetScoreNpIdRequestArgs {
      boardId: 0,
      npids: None,
      withComment: false,
      withGameInfo: false,
    }
  }
}

pub struct GetScoreNpIdRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetScoreNpIdRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_boardId(&mut self, boardId: u32) {
    self.fbb_.push_slot::<u32>(GetScoreNpIdRequest::VT_BOARDID, boardId, 0);
  }
  #[inline]
  pub fn add_npids(&mut self, npids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ScoreNpIdPcId<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetScoreNpIdRequest::VT_NPIDS, npids);
  }
  #[inline]
  pub fn add_withComment(&mut self, withComment: bool) {
    self.fbb_.push_slot::<bool>(GetScoreNpIdRequest::VT_WITHCOMMENT, withComment, false);
  }
  #[inline]
  pub fn add_withGameInfo(&mut self, withGameInfo: bool) {
    self.fbb_.push_slot::<bool>(GetScoreNpIdRequest::VT_WITHGAMEINFO, withGameInfo, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetScoreNpIdRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetScoreNpIdRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetScoreNpIdRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetScoreNpIdRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetScoreNpIdRequest");
      ds.field("boardId", &self.boardId());
      ds.field("npids", &self.npids());
      ds.field("withComment", &self.withComment());
      ds.field("withGameInfo", &self.withGameInfo());
      ds.finish()
  }
}
pub enum GetScoreFriendsRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetScoreFriendsRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetScoreFriendsRequest<'a> {
  type Inner = GetScoreFriendsRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetScoreFriendsRequest<'a> {
  pub const VT_BOARDID: flatbuffers::VOffsetT = 4;
  pub const VT_INCLUDE_SELF: flatbuffers::VOffsetT = 6;
  pub const VT_MAX: flatbuffers::VOffsetT = 8;
  pub const VT_WITHCOMMENT: flatbuffers::VOffsetT = 10;
  pub const VT_WITHGAMEINFO: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetScoreFriendsRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetScoreFriendsRequestArgs
  ) -> flatbuffers::WIPOffset<GetScoreFriendsRequest<'bldr>> {
    let mut builder = GetScoreFriendsRequestBuilder::new(_fbb);
    builder.add_max(args.max);
    builder.add_boardId(args.boardId);
    builder.add_withGameInfo(args.withGameInfo);
    builder.add_withComment(args.withComment);
    builder.add_include_self(args.include_self);
    builder.finish()
  }


  #[inline]
  pub fn boardId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetScoreFriendsRequest::VT_BOARDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn include_self(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GetScoreFriendsRequest::VT_INCLUDE_SELF, Some(false)).unwrap()}
  }
  #[inline]
  pub fn max(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetScoreFriendsRequest::VT_MAX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn withComment(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GetScoreFriendsRequest::VT_WITHCOMMENT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn withGameInfo(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GetScoreFriendsRequest::VT_WITHGAMEINFO, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetScoreFriendsRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("boardId", Self::VT_BOARDID, false)?
     .visit_field::<bool>("include_self", Self::VT_INCLUDE_SELF, false)?
     .visit_field::<u32>("max", Self::VT_MAX, false)?
     .visit_field::<bool>("withComment", Self::VT_WITHCOMMENT, false)?
     .visit_field::<bool>("withGameInfo", Self::VT_WITHGAMEINFO, false)?
     .finish();
    Ok(())
  }
}
pub struct GetScoreFriendsRequestArgs {
    pub boardId: u32,
    pub include_self: bool,
    pub max: u32,
    pub withComment: bool,
    pub withGameInfo: bool,
}
impl<'a> Default for GetScoreFriendsRequestArgs {
  #[inline]
  fn default() -> Self {
    GetScoreFriendsRequestArgs {
      boardId: 0,
      include_self: false,
      max: 0,
      withComment: false,
      withGameInfo: false,
    }
  }
}

pub struct GetScoreFriendsRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetScoreFriendsRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_boardId(&mut self, boardId: u32) {
    self.fbb_.push_slot::<u32>(GetScoreFriendsRequest::VT_BOARDID, boardId, 0);
  }
  #[inline]
  pub fn add_include_self(&mut self, include_self: bool) {
    self.fbb_.push_slot::<bool>(GetScoreFriendsRequest::VT_INCLUDE_SELF, include_self, false);
  }
  #[inline]
  pub fn add_max(&mut self, max: u32) {
    self.fbb_.push_slot::<u32>(GetScoreFriendsRequest::VT_MAX, max, 0);
  }
  #[inline]
  pub fn add_withComment(&mut self, withComment: bool) {
    self.fbb_.push_slot::<bool>(GetScoreFriendsRequest::VT_WITHCOMMENT, withComment, false);
  }
  #[inline]
  pub fn add_withGameInfo(&mut self, withGameInfo: bool) {
    self.fbb_.push_slot::<bool>(GetScoreFriendsRequest::VT_WITHGAMEINFO, withGameInfo, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetScoreFriendsRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetScoreFriendsRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetScoreFriendsRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetScoreFriendsRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetScoreFriendsRequest");
      ds.field("boardId", &self.boardId());
      ds.field("include_self", &self.include_self());
      ds.field("max", &self.max());
      ds.field("withComment", &self.withComment());
      ds.field("withGameInfo", &self.withGameInfo());
      ds.finish()
  }
}
pub enum ScoreRankDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScoreRankData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScoreRankData<'a> {
  type Inner = ScoreRankData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ScoreRankData<'a> {
  pub const VT_NPID: flatbuffers::VOffsetT = 4;
  pub const VT_ONLINENAME: flatbuffers::VOffsetT = 6;
  pub const VT_PCID: flatbuffers::VOffsetT = 8;
  pub const VT_RANK: flatbuffers::VOffsetT = 10;
  pub const VT_SCORE: flatbuffers::VOffsetT = 12;
  pub const VT_HASGAMEDATA: flatbuffers::VOffsetT = 14;
  pub const VT_RECORDDATE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScoreRankData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ScoreRankDataArgs<'args>
  ) -> flatbuffers::WIPOffset<ScoreRankData<'bldr>> {
    let mut builder = ScoreRankDataBuilder::new(_fbb);
    builder.add_recordDate(args.recordDate);
    builder.add_score(args.score);
    builder.add_rank(args.rank);
    builder.add_pcId(args.pcId);
    if let Some(x) = args.onlineName { builder.add_onlineName(x); }
    if let Some(x) = args.npId { builder.add_npId(x); }
    builder.add_hasGameData(args.hasGameData);
    builder.finish()
  }


  #[inline]
  pub fn npId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ScoreRankData::VT_NPID, None)}
  }
  #[inline]
  pub fn onlineName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ScoreRankData::VT_ONLINENAME, None)}
  }
  #[inline]
  pub fn pcId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScoreRankData::VT_PCID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rank(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ScoreRankData::VT_RANK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn score(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScoreRankData::VT_SCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hasGameData(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ScoreRankData::VT_HASGAMEDATA, Some(false)).unwrap()}
  }
  #[inline]
  pub fn recordDate(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ScoreRankData::VT_RECORDDATE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ScoreRankData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("npId", Self::VT_NPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onlineName", Self::VT_ONLINENAME, false)?
     .visit_field::<i32>("pcId", Self::VT_PCID, false)?
     .visit_field::<u32>("rank", Self::VT_RANK, false)?
     .visit_field::<i64>("score", Self::VT_SCORE, false)?
     .visit_field::<bool>("hasGameData", Self::VT_HASGAMEDATA, false)?
     .visit_field::<u64>("recordDate", Self::VT_RECORDDATE, false)?
     .finish();
    Ok(())
  }
}
pub struct ScoreRankDataArgs<'a> {
    pub npId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onlineName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pcId: i32,
    pub rank: u32,
    pub score: i64,
    pub hasGameData: bool,
    pub recordDate: u64,
}
impl<'a> Default for ScoreRankDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    ScoreRankDataArgs {
      npId: None,
      onlineName: None,
      pcId: 0,
      rank: 0,
      score: 0,
      hasGameData: false,
      recordDate: 0,
    }
  }
}

pub struct ScoreRankDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ScoreRankDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_npId(&mut self, npId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScoreRankData::VT_NPID, npId);
  }
  #[inline]
  pub fn add_onlineName(&mut self, onlineName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScoreRankData::VT_ONLINENAME, onlineName);
  }
  #[inline]
  pub fn add_pcId(&mut self, pcId: i32) {
    self.fbb_.push_slot::<i32>(ScoreRankData::VT_PCID, pcId, 0);
  }
  #[inline]
  pub fn add_rank(&mut self, rank: u32) {
    self.fbb_.push_slot::<u32>(ScoreRankData::VT_RANK, rank, 0);
  }
  #[inline]
  pub fn add_score(&mut self, score: i64) {
    self.fbb_.push_slot::<i64>(ScoreRankData::VT_SCORE, score, 0);
  }
  #[inline]
  pub fn add_hasGameData(&mut self, hasGameData: bool) {
    self.fbb_.push_slot::<bool>(ScoreRankData::VT_HASGAMEDATA, hasGameData, false);
  }
  #[inline]
  pub fn add_recordDate(&mut self, recordDate: u64) {
    self.fbb_.push_slot::<u64>(ScoreRankData::VT_RECORDDATE, recordDate, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ScoreRankDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ScoreRankDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScoreRankData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScoreRankData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScoreRankData");
      ds.field("npId", &self.npId());
      ds.field("onlineName", &self.onlineName());
      ds.field("pcId", &self.pcId());
      ds.field("rank", &self.rank());
      ds.field("score", &self.score());
      ds.field("hasGameData", &self.hasGameData());
      ds.field("recordDate", &self.recordDate());
      ds.finish()
  }
}
pub enum ScoreInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScoreInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScoreInfo<'a> {
  type Inner = ScoreInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ScoreInfo<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScoreInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ScoreInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<ScoreInfo<'bldr>> {
    let mut builder = ScoreInfoBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ScoreInfo::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for ScoreInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct ScoreInfoArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ScoreInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    ScoreInfoArgs {
      data: None,
    }
  }
}

pub struct ScoreInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ScoreInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScoreInfo::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ScoreInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ScoreInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScoreInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScoreInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScoreInfo");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum GetScoreResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetScoreResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetScoreResponse<'a> {
  type Inner = GetScoreResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetScoreResponse<'a> {
  pub const VT_RANKARRAY: flatbuffers::VOffsetT = 4;
  pub const VT_COMMENTARRAY: flatbuffers::VOffsetT = 6;
  pub const VT_INFOARRAY: flatbuffers::VOffsetT = 8;
  pub const VT_LASTSORTDATE: flatbuffers::VOffsetT = 10;
  pub const VT_TOTALRECORD: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetScoreResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetScoreResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetScoreResponse<'bldr>> {
    let mut builder = GetScoreResponseBuilder::new(_fbb);
    builder.add_lastSortDate(args.lastSortDate);
    builder.add_totalRecord(args.totalRecord);
    if let Some(x) = args.infoArray { builder.add_infoArray(x); }
    if let Some(x) = args.commentArray { builder.add_commentArray(x); }
    if let Some(x) = args.rankArray { builder.add_rankArray(x); }
    builder.finish()
  }


  #[inline]
  pub fn rankArray(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScoreRankData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScoreRankData>>>>(GetScoreResponse::VT_RANKARRAY, None)}
  }
  #[inline]
  pub fn commentArray(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GetScoreResponse::VT_COMMENTARRAY, None)}
  }
  #[inline]
  pub fn infoArray(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScoreInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScoreInfo>>>>(GetScoreResponse::VT_INFOARRAY, None)}
  }
  #[inline]
  pub fn lastSortDate(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GetScoreResponse::VT_LASTSORTDATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn totalRecord(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetScoreResponse::VT_TOTALRECORD, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetScoreResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ScoreRankData>>>>("rankArray", Self::VT_RANKARRAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("commentArray", Self::VT_COMMENTARRAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ScoreInfo>>>>("infoArray", Self::VT_INFOARRAY, false)?
     .visit_field::<u64>("lastSortDate", Self::VT_LASTSORTDATE, false)?
     .visit_field::<u32>("totalRecord", Self::VT_TOTALRECORD, false)?
     .finish();
    Ok(())
  }
}
pub struct GetScoreResponseArgs<'a> {
    pub rankArray: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScoreRankData<'a>>>>>,
    pub commentArray: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub infoArray: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScoreInfo<'a>>>>>,
    pub lastSortDate: u64,
    pub totalRecord: u32,
}
impl<'a> Default for GetScoreResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetScoreResponseArgs {
      rankArray: None,
      commentArray: None,
      infoArray: None,
      lastSortDate: 0,
      totalRecord: 0,
    }
  }
}

pub struct GetScoreResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetScoreResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_rankArray(&mut self, rankArray: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ScoreRankData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetScoreResponse::VT_RANKARRAY, rankArray);
  }
  #[inline]
  pub fn add_commentArray(&mut self, commentArray: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetScoreResponse::VT_COMMENTARRAY, commentArray);
  }
  #[inline]
  pub fn add_infoArray(&mut self, infoArray: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ScoreInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetScoreResponse::VT_INFOARRAY, infoArray);
  }
  #[inline]
  pub fn add_lastSortDate(&mut self, lastSortDate: u64) {
    self.fbb_.push_slot::<u64>(GetScoreResponse::VT_LASTSORTDATE, lastSortDate, 0);
  }
  #[inline]
  pub fn add_totalRecord(&mut self, totalRecord: u32) {
    self.fbb_.push_slot::<u32>(GetScoreResponse::VT_TOTALRECORD, totalRecord, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetScoreResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetScoreResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetScoreResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetScoreResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetScoreResponse");
      ds.field("rankArray", &self.rankArray());
      ds.field("commentArray", &self.commentArray());
      ds.field("infoArray", &self.infoArray());
      ds.field("lastSortDate", &self.lastSortDate());
      ds.field("totalRecord", &self.totalRecord());
      ds.finish()
  }
}
pub enum RecordScoreGameDataRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RecordScoreGameDataRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RecordScoreGameDataRequest<'a> {
  type Inner = RecordScoreGameDataRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RecordScoreGameDataRequest<'a> {
  pub const VT_BOARDID: flatbuffers::VOffsetT = 4;
  pub const VT_PCID: flatbuffers::VOffsetT = 6;
  pub const VT_SCORE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RecordScoreGameDataRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RecordScoreGameDataRequestArgs
  ) -> flatbuffers::WIPOffset<RecordScoreGameDataRequest<'bldr>> {
    let mut builder = RecordScoreGameDataRequestBuilder::new(_fbb);
    builder.add_score(args.score);
    builder.add_pcId(args.pcId);
    builder.add_boardId(args.boardId);
    builder.finish()
  }


  #[inline]
  pub fn boardId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RecordScoreGameDataRequest::VT_BOARDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pcId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RecordScoreGameDataRequest::VT_PCID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn score(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RecordScoreGameDataRequest::VT_SCORE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RecordScoreGameDataRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("boardId", Self::VT_BOARDID, false)?
     .visit_field::<i32>("pcId", Self::VT_PCID, false)?
     .visit_field::<i64>("score", Self::VT_SCORE, false)?
     .finish();
    Ok(())
  }
}
pub struct RecordScoreGameDataRequestArgs {
    pub boardId: u32,
    pub pcId: i32,
    pub score: i64,
}
impl<'a> Default for RecordScoreGameDataRequestArgs {
  #[inline]
  fn default() -> Self {
    RecordScoreGameDataRequestArgs {
      boardId: 0,
      pcId: 0,
      score: 0,
    }
  }
}

pub struct RecordScoreGameDataRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RecordScoreGameDataRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_boardId(&mut self, boardId: u32) {
    self.fbb_.push_slot::<u32>(RecordScoreGameDataRequest::VT_BOARDID, boardId, 0);
  }
  #[inline]
  pub fn add_pcId(&mut self, pcId: i32) {
    self.fbb_.push_slot::<i32>(RecordScoreGameDataRequest::VT_PCID, pcId, 0);
  }
  #[inline]
  pub fn add_score(&mut self, score: i64) {
    self.fbb_.push_slot::<i64>(RecordScoreGameDataRequest::VT_SCORE, score, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RecordScoreGameDataRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RecordScoreGameDataRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RecordScoreGameDataRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RecordScoreGameDataRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RecordScoreGameDataRequest");
      ds.field("boardId", &self.boardId());
      ds.field("pcId", &self.pcId());
      ds.field("score", &self.score());
      ds.finish()
  }
}
pub enum GetScoreGameDataRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetScoreGameDataRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetScoreGameDataRequest<'a> {
  type Inner = GetScoreGameDataRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetScoreGameDataRequest<'a> {
  pub const VT_BOARDID: flatbuffers::VOffsetT = 4;
  pub const VT_NPID: flatbuffers::VOffsetT = 6;
  pub const VT_PCID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetScoreGameDataRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetScoreGameDataRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetScoreGameDataRequest<'bldr>> {
    let mut builder = GetScoreGameDataRequestBuilder::new(_fbb);
    builder.add_pcId(args.pcId);
    if let Some(x) = args.npId { builder.add_npId(x); }
    builder.add_boardId(args.boardId);
    builder.finish()
  }


  #[inline]
  pub fn boardId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetScoreGameDataRequest::VT_BOARDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn npId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetScoreGameDataRequest::VT_NPID, None)}
  }
  #[inline]
  pub fn pcId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GetScoreGameDataRequest::VT_PCID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetScoreGameDataRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("boardId", Self::VT_BOARDID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("npId", Self::VT_NPID, false)?
     .visit_field::<i32>("pcId", Self::VT_PCID, false)?
     .finish();
    Ok(())
  }
}
pub struct GetScoreGameDataRequestArgs<'a> {
    pub boardId: u32,
    pub npId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pcId: i32,
}
impl<'a> Default for GetScoreGameDataRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetScoreGameDataRequestArgs {
      boardId: 0,
      npId: None,
      pcId: 0,
    }
  }
}

pub struct GetScoreGameDataRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetScoreGameDataRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_boardId(&mut self, boardId: u32) {
    self.fbb_.push_slot::<u32>(GetScoreGameDataRequest::VT_BOARDID, boardId, 0);
  }
  #[inline]
  pub fn add_npId(&mut self, npId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetScoreGameDataRequest::VT_NPID, npId);
  }
  #[inline]
  pub fn add_pcId(&mut self, pcId: i32) {
    self.fbb_.push_slot::<i32>(GetScoreGameDataRequest::VT_PCID, pcId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetScoreGameDataRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetScoreGameDataRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetScoreGameDataRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetScoreGameDataRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetScoreGameDataRequest");
      ds.field("boardId", &self.boardId());
      ds.field("npId", &self.npId());
      ds.field("pcId", &self.pcId());
      ds.finish()
  }
}
pub enum TusUserOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusUser<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusUser<'a> {
  type Inner = TusUser<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusUser<'a> {
  pub const VT_VUSER: flatbuffers::VOffsetT = 4;
  pub const VT_NPID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusUser { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusUserArgs<'args>
  ) -> flatbuffers::WIPOffset<TusUser<'bldr>> {
    let mut builder = TusUserBuilder::new(_fbb);
    if let Some(x) = args.npid { builder.add_npid(x); }
    builder.add_vuser(args.vuser);
    builder.finish()
  }


  #[inline]
  pub fn vuser(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TusUser::VT_VUSER, Some(false)).unwrap()}
  }
  #[inline]
  pub fn npid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TusUser::VT_NPID, None)}
  }
}

impl flatbuffers::Verifiable for TusUser<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("vuser", Self::VT_VUSER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("npid", Self::VT_NPID, false)?
     .finish();
    Ok(())
  }
}
pub struct TusUserArgs<'a> {
    pub vuser: bool,
    pub npid: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TusUserArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusUserArgs {
      vuser: false,
      npid: None,
    }
  }
}

pub struct TusUserBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusUserBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_vuser(&mut self, vuser: bool) {
    self.fbb_.push_slot::<bool>(TusUser::VT_VUSER, vuser, false);
  }
  #[inline]
  pub fn add_npid(&mut self, npid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusUser::VT_NPID, npid);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusUserBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusUserBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusUser<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusUser<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusUser");
      ds.field("vuser", &self.vuser());
      ds.field("npid", &self.npid());
      ds.finish()
  }
}
pub enum TusVariableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusVariable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusVariable<'a> {
  type Inner = TusVariable<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusVariable<'a> {
  pub const VT_OWNERID: flatbuffers::VOffsetT = 4;
  pub const VT_HASDATA: flatbuffers::VOffsetT = 6;
  pub const VT_LASTCHANGEDDATE: flatbuffers::VOffsetT = 8;
  pub const VT_LASTCHANGEDAUTHORID: flatbuffers::VOffsetT = 10;
  pub const VT_VARIABLE: flatbuffers::VOffsetT = 12;
  pub const VT_OLDVARIABLE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusVariable { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusVariableArgs<'args>
  ) -> flatbuffers::WIPOffset<TusVariable<'bldr>> {
    let mut builder = TusVariableBuilder::new(_fbb);
    builder.add_oldVariable(args.oldVariable);
    builder.add_variable(args.variable);
    builder.add_lastChangedDate(args.lastChangedDate);
    if let Some(x) = args.lastChangedAuthorId { builder.add_lastChangedAuthorId(x); }
    if let Some(x) = args.ownerId { builder.add_ownerId(x); }
    builder.add_hasData(args.hasData);
    builder.finish()
  }


  #[inline]
  pub fn ownerId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TusVariable::VT_OWNERID, None)}
  }
  #[inline]
  pub fn hasData(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TusVariable::VT_HASDATA, Some(false)).unwrap()}
  }
  #[inline]
  pub fn lastChangedDate(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(TusVariable::VT_LASTCHANGEDDATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lastChangedAuthorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TusVariable::VT_LASTCHANGEDAUTHORID, None)}
  }
  #[inline]
  pub fn variable(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TusVariable::VT_VARIABLE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn oldVariable(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TusVariable::VT_OLDVARIABLE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TusVariable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ownerId", Self::VT_OWNERID, false)?
     .visit_field::<bool>("hasData", Self::VT_HASDATA, false)?
     .visit_field::<u64>("lastChangedDate", Self::VT_LASTCHANGEDDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastChangedAuthorId", Self::VT_LASTCHANGEDAUTHORID, false)?
     .visit_field::<i64>("variable", Self::VT_VARIABLE, false)?
     .visit_field::<i64>("oldVariable", Self::VT_OLDVARIABLE, false)?
     .finish();
    Ok(())
  }
}
pub struct TusVariableArgs<'a> {
    pub ownerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hasData: bool,
    pub lastChangedDate: u64,
    pub lastChangedAuthorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub variable: i64,
    pub oldVariable: i64,
}
impl<'a> Default for TusVariableArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusVariableArgs {
      ownerId: None,
      hasData: false,
      lastChangedDate: 0,
      lastChangedAuthorId: None,
      variable: 0,
      oldVariable: 0,
    }
  }
}

pub struct TusVariableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusVariableBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ownerId(&mut self, ownerId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusVariable::VT_OWNERID, ownerId);
  }
  #[inline]
  pub fn add_hasData(&mut self, hasData: bool) {
    self.fbb_.push_slot::<bool>(TusVariable::VT_HASDATA, hasData, false);
  }
  #[inline]
  pub fn add_lastChangedDate(&mut self, lastChangedDate: u64) {
    self.fbb_.push_slot::<u64>(TusVariable::VT_LASTCHANGEDDATE, lastChangedDate, 0);
  }
  #[inline]
  pub fn add_lastChangedAuthorId(&mut self, lastChangedAuthorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusVariable::VT_LASTCHANGEDAUTHORID, lastChangedAuthorId);
  }
  #[inline]
  pub fn add_variable(&mut self, variable: i64) {
    self.fbb_.push_slot::<i64>(TusVariable::VT_VARIABLE, variable, 0);
  }
  #[inline]
  pub fn add_oldVariable(&mut self, oldVariable: i64) {
    self.fbb_.push_slot::<i64>(TusVariable::VT_OLDVARIABLE, oldVariable, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusVariableBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusVariableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusVariable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusVariable<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusVariable");
      ds.field("ownerId", &self.ownerId());
      ds.field("hasData", &self.hasData());
      ds.field("lastChangedDate", &self.lastChangedDate());
      ds.field("lastChangedAuthorId", &self.lastChangedAuthorId());
      ds.field("variable", &self.variable());
      ds.field("oldVariable", &self.oldVariable());
      ds.finish()
  }
}
pub enum TusVarResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusVarResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusVarResponse<'a> {
  type Inner = TusVarResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusVarResponse<'a> {
  pub const VT_VARS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusVarResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusVarResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<TusVarResponse<'bldr>> {
    let mut builder = TusVarResponseBuilder::new(_fbb);
    if let Some(x) = args.vars { builder.add_vars(x); }
    builder.finish()
  }


  #[inline]
  pub fn vars(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusVariable<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusVariable>>>>(TusVarResponse::VT_VARS, None)}
  }
}

impl flatbuffers::Verifiable for TusVarResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TusVariable>>>>("vars", Self::VT_VARS, false)?
     .finish();
    Ok(())
  }
}
pub struct TusVarResponseArgs<'a> {
    pub vars: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusVariable<'a>>>>>,
}
impl<'a> Default for TusVarResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusVarResponseArgs {
      vars: None,
    }
  }
}

pub struct TusVarResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusVarResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_vars(&mut self, vars: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TusVariable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusVarResponse::VT_VARS, vars);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusVarResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusVarResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusVarResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusVarResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusVarResponse");
      ds.field("vars", &self.vars());
      ds.finish()
  }
}
pub enum TusSetMultiSlotVariableRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusSetMultiSlotVariableRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusSetMultiSlotVariableRequest<'a> {
  type Inner = TusSetMultiSlotVariableRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusSetMultiSlotVariableRequest<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTIDARRAY: flatbuffers::VOffsetT = 6;
  pub const VT_VARIABLEARRAY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusSetMultiSlotVariableRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusSetMultiSlotVariableRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusSetMultiSlotVariableRequest<'bldr>> {
    let mut builder = TusSetMultiSlotVariableRequestBuilder::new(_fbb);
    if let Some(x) = args.variableArray { builder.add_variableArray(x); }
    if let Some(x) = args.slotIdArray { builder.add_slotIdArray(x); }
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> Option<TusUser<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusUser>>(TusSetMultiSlotVariableRequest::VT_USER, None)}
  }
  #[inline]
  pub fn slotIdArray(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(TusSetMultiSlotVariableRequest::VT_SLOTIDARRAY, None)}
  }
  #[inline]
  pub fn variableArray(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(TusSetMultiSlotVariableRequest::VT_VARIABLEARRAY, None)}
  }
}

impl flatbuffers::Verifiable for TusSetMultiSlotVariableRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusUser>>("user", Self::VT_USER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("slotIdArray", Self::VT_SLOTIDARRAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("variableArray", Self::VT_VARIABLEARRAY, false)?
     .finish();
    Ok(())
  }
}
pub struct TusSetMultiSlotVariableRequestArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<TusUser<'a>>>,
    pub slotIdArray: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub variableArray: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for TusSetMultiSlotVariableRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusSetMultiSlotVariableRequestArgs {
      user: None,
      slotIdArray: None,
      variableArray: None,
    }
  }
}

pub struct TusSetMultiSlotVariableRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusSetMultiSlotVariableRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<TusUser<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusUser>>(TusSetMultiSlotVariableRequest::VT_USER, user);
  }
  #[inline]
  pub fn add_slotIdArray(&mut self, slotIdArray: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusSetMultiSlotVariableRequest::VT_SLOTIDARRAY, slotIdArray);
  }
  #[inline]
  pub fn add_variableArray(&mut self, variableArray: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusSetMultiSlotVariableRequest::VT_VARIABLEARRAY, variableArray);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusSetMultiSlotVariableRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusSetMultiSlotVariableRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusSetMultiSlotVariableRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusSetMultiSlotVariableRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusSetMultiSlotVariableRequest");
      ds.field("user", &self.user());
      ds.field("slotIdArray", &self.slotIdArray());
      ds.field("variableArray", &self.variableArray());
      ds.finish()
  }
}
pub enum TusGetMultiSlotVariableRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusGetMultiSlotVariableRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusGetMultiSlotVariableRequest<'a> {
  type Inner = TusGetMultiSlotVariableRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusGetMultiSlotVariableRequest<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTIDARRAY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusGetMultiSlotVariableRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusGetMultiSlotVariableRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusGetMultiSlotVariableRequest<'bldr>> {
    let mut builder = TusGetMultiSlotVariableRequestBuilder::new(_fbb);
    if let Some(x) = args.slotIdArray { builder.add_slotIdArray(x); }
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> Option<TusUser<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusUser>>(TusGetMultiSlotVariableRequest::VT_USER, None)}
  }
  #[inline]
  pub fn slotIdArray(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(TusGetMultiSlotVariableRequest::VT_SLOTIDARRAY, None)}
  }
}

impl flatbuffers::Verifiable for TusGetMultiSlotVariableRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusUser>>("user", Self::VT_USER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("slotIdArray", Self::VT_SLOTIDARRAY, false)?
     .finish();
    Ok(())
  }
}
pub struct TusGetMultiSlotVariableRequestArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<TusUser<'a>>>,
    pub slotIdArray: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for TusGetMultiSlotVariableRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusGetMultiSlotVariableRequestArgs {
      user: None,
      slotIdArray: None,
    }
  }
}

pub struct TusGetMultiSlotVariableRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusGetMultiSlotVariableRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<TusUser<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusUser>>(TusGetMultiSlotVariableRequest::VT_USER, user);
  }
  #[inline]
  pub fn add_slotIdArray(&mut self, slotIdArray: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusGetMultiSlotVariableRequest::VT_SLOTIDARRAY, slotIdArray);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusGetMultiSlotVariableRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusGetMultiSlotVariableRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusGetMultiSlotVariableRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusGetMultiSlotVariableRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusGetMultiSlotVariableRequest");
      ds.field("user", &self.user());
      ds.field("slotIdArray", &self.slotIdArray());
      ds.finish()
  }
}
pub enum TusGetMultiUserVariableRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusGetMultiUserVariableRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusGetMultiUserVariableRequest<'a> {
  type Inner = TusGetMultiUserVariableRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusGetMultiUserVariableRequest<'a> {
  pub const VT_USERS: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusGetMultiUserVariableRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusGetMultiUserVariableRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusGetMultiUserVariableRequest<'bldr>> {
    let mut builder = TusGetMultiUserVariableRequestBuilder::new(_fbb);
    builder.add_slotId(args.slotId);
    if let Some(x) = args.users { builder.add_users(x); }
    builder.finish()
  }


  #[inline]
  pub fn users(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusUser<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusUser>>>>(TusGetMultiUserVariableRequest::VT_USERS, None)}
  }
  #[inline]
  pub fn slotId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusGetMultiUserVariableRequest::VT_SLOTID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TusGetMultiUserVariableRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TusUser>>>>("users", Self::VT_USERS, false)?
     .visit_field::<i32>("slotId", Self::VT_SLOTID, false)?
     .finish();
    Ok(())
  }
}
pub struct TusGetMultiUserVariableRequestArgs<'a> {
    pub users: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusUser<'a>>>>>,
    pub slotId: i32,
}
impl<'a> Default for TusGetMultiUserVariableRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusGetMultiUserVariableRequestArgs {
      users: None,
      slotId: 0,
    }
  }
}

pub struct TusGetMultiUserVariableRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusGetMultiUserVariableRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_users(&mut self, users: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TusUser<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusGetMultiUserVariableRequest::VT_USERS, users);
  }
  #[inline]
  pub fn add_slotId(&mut self, slotId: i32) {
    self.fbb_.push_slot::<i32>(TusGetMultiUserVariableRequest::VT_SLOTID, slotId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusGetMultiUserVariableRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusGetMultiUserVariableRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusGetMultiUserVariableRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusGetMultiUserVariableRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusGetMultiUserVariableRequest");
      ds.field("users", &self.users());
      ds.field("slotId", &self.slotId());
      ds.finish()
  }
}
pub enum TusGetFriendsVariableRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusGetFriendsVariableRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusGetFriendsVariableRequest<'a> {
  type Inner = TusGetFriendsVariableRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusGetFriendsVariableRequest<'a> {
  pub const VT_SLOTID: flatbuffers::VOffsetT = 4;
  pub const VT_INCLUDESELF: flatbuffers::VOffsetT = 6;
  pub const VT_SORTTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_ARRAYNUM: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusGetFriendsVariableRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusGetFriendsVariableRequestArgs
  ) -> flatbuffers::WIPOffset<TusGetFriendsVariableRequest<'bldr>> {
    let mut builder = TusGetFriendsVariableRequestBuilder::new(_fbb);
    builder.add_arrayNum(args.arrayNum);
    builder.add_sortType(args.sortType);
    builder.add_slotId(args.slotId);
    builder.add_includeSelf(args.includeSelf);
    builder.finish()
  }


  #[inline]
  pub fn slotId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusGetFriendsVariableRequest::VT_SLOTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn includeSelf(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TusGetFriendsVariableRequest::VT_INCLUDESELF, Some(false)).unwrap()}
  }
  #[inline]
  pub fn sortType(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusGetFriendsVariableRequest::VT_SORTTYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn arrayNum(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TusGetFriendsVariableRequest::VT_ARRAYNUM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TusGetFriendsVariableRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("slotId", Self::VT_SLOTID, false)?
     .visit_field::<bool>("includeSelf", Self::VT_INCLUDESELF, false)?
     .visit_field::<i32>("sortType", Self::VT_SORTTYPE, false)?
     .visit_field::<u32>("arrayNum", Self::VT_ARRAYNUM, false)?
     .finish();
    Ok(())
  }
}
pub struct TusGetFriendsVariableRequestArgs {
    pub slotId: i32,
    pub includeSelf: bool,
    pub sortType: i32,
    pub arrayNum: u32,
}
impl<'a> Default for TusGetFriendsVariableRequestArgs {
  #[inline]
  fn default() -> Self {
    TusGetFriendsVariableRequestArgs {
      slotId: 0,
      includeSelf: false,
      sortType: 0,
      arrayNum: 0,
    }
  }
}

pub struct TusGetFriendsVariableRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusGetFriendsVariableRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_slotId(&mut self, slotId: i32) {
    self.fbb_.push_slot::<i32>(TusGetFriendsVariableRequest::VT_SLOTID, slotId, 0);
  }
  #[inline]
  pub fn add_includeSelf(&mut self, includeSelf: bool) {
    self.fbb_.push_slot::<bool>(TusGetFriendsVariableRequest::VT_INCLUDESELF, includeSelf, false);
  }
  #[inline]
  pub fn add_sortType(&mut self, sortType: i32) {
    self.fbb_.push_slot::<i32>(TusGetFriendsVariableRequest::VT_SORTTYPE, sortType, 0);
  }
  #[inline]
  pub fn add_arrayNum(&mut self, arrayNum: u32) {
    self.fbb_.push_slot::<u32>(TusGetFriendsVariableRequest::VT_ARRAYNUM, arrayNum, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusGetFriendsVariableRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusGetFriendsVariableRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusGetFriendsVariableRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusGetFriendsVariableRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusGetFriendsVariableRequest");
      ds.field("slotId", &self.slotId());
      ds.field("includeSelf", &self.includeSelf());
      ds.field("sortType", &self.sortType());
      ds.field("arrayNum", &self.arrayNum());
      ds.finish()
  }
}
pub enum TusAddAndGetVariableRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusAddAndGetVariableRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusAddAndGetVariableRequest<'a> {
  type Inner = TusAddAndGetVariableRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusAddAndGetVariableRequest<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTID: flatbuffers::VOffsetT = 6;
  pub const VT_INVARIABLE: flatbuffers::VOffsetT = 8;
  pub const VT_ISLASTCHANGEDDATE: flatbuffers::VOffsetT = 10;
  pub const VT_ISLASTCHANGEDAUTHORID: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusAddAndGetVariableRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusAddAndGetVariableRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusAddAndGetVariableRequest<'bldr>> {
    let mut builder = TusAddAndGetVariableRequestBuilder::new(_fbb);
    builder.add_inVariable(args.inVariable);
    if let Some(x) = args.isLastChangedAuthorId { builder.add_isLastChangedAuthorId(x); }
    if let Some(x) = args.isLastChangedDate { builder.add_isLastChangedDate(x); }
    builder.add_slotId(args.slotId);
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> Option<TusUser<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusUser>>(TusAddAndGetVariableRequest::VT_USER, None)}
  }
  #[inline]
  pub fn slotId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusAddAndGetVariableRequest::VT_SLOTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn inVariable(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TusAddAndGetVariableRequest::VT_INVARIABLE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn isLastChangedDate(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(TusAddAndGetVariableRequest::VT_ISLASTCHANGEDDATE, None)}
  }
  #[inline]
  pub fn isLastChangedAuthorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TusAddAndGetVariableRequest::VT_ISLASTCHANGEDAUTHORID, None)}
  }
}

impl flatbuffers::Verifiable for TusAddAndGetVariableRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusUser>>("user", Self::VT_USER, false)?
     .visit_field::<i32>("slotId", Self::VT_SLOTID, false)?
     .visit_field::<i64>("inVariable", Self::VT_INVARIABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("isLastChangedDate", Self::VT_ISLASTCHANGEDDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("isLastChangedAuthorId", Self::VT_ISLASTCHANGEDAUTHORID, false)?
     .finish();
    Ok(())
  }
}
pub struct TusAddAndGetVariableRequestArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<TusUser<'a>>>,
    pub slotId: i32,
    pub inVariable: i64,
    pub isLastChangedDate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub isLastChangedAuthorId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TusAddAndGetVariableRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusAddAndGetVariableRequestArgs {
      user: None,
      slotId: 0,
      inVariable: 0,
      isLastChangedDate: None,
      isLastChangedAuthorId: None,
    }
  }
}

pub struct TusAddAndGetVariableRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusAddAndGetVariableRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<TusUser<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusUser>>(TusAddAndGetVariableRequest::VT_USER, user);
  }
  #[inline]
  pub fn add_slotId(&mut self, slotId: i32) {
    self.fbb_.push_slot::<i32>(TusAddAndGetVariableRequest::VT_SLOTID, slotId, 0);
  }
  #[inline]
  pub fn add_inVariable(&mut self, inVariable: i64) {
    self.fbb_.push_slot::<i64>(TusAddAndGetVariableRequest::VT_INVARIABLE, inVariable, 0);
  }
  #[inline]
  pub fn add_isLastChangedDate(&mut self, isLastChangedDate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusAddAndGetVariableRequest::VT_ISLASTCHANGEDDATE, isLastChangedDate);
  }
  #[inline]
  pub fn add_isLastChangedAuthorId(&mut self, isLastChangedAuthorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusAddAndGetVariableRequest::VT_ISLASTCHANGEDAUTHORID, isLastChangedAuthorId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusAddAndGetVariableRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusAddAndGetVariableRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusAddAndGetVariableRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusAddAndGetVariableRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusAddAndGetVariableRequest");
      ds.field("user", &self.user());
      ds.field("slotId", &self.slotId());
      ds.field("inVariable", &self.inVariable());
      ds.field("isLastChangedDate", &self.isLastChangedDate());
      ds.field("isLastChangedAuthorId", &self.isLastChangedAuthorId());
      ds.finish()
  }
}
pub enum TusTryAndSetVariableRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusTryAndSetVariableRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusTryAndSetVariableRequest<'a> {
  type Inner = TusTryAndSetVariableRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusTryAndSetVariableRequest<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTID: flatbuffers::VOffsetT = 6;
  pub const VT_OPETYPE: flatbuffers::VOffsetT = 8;
  pub const VT_VARIABLE: flatbuffers::VOffsetT = 10;
  pub const VT_ISLASTCHANGEDDATE: flatbuffers::VOffsetT = 12;
  pub const VT_ISLASTCHANGEDAUTHORID: flatbuffers::VOffsetT = 14;
  pub const VT_COMPAREVALUE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusTryAndSetVariableRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusTryAndSetVariableRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusTryAndSetVariableRequest<'bldr>> {
    let mut builder = TusTryAndSetVariableRequestBuilder::new(_fbb);
    builder.add_variable(args.variable);
    if let Some(x) = args.compareValue { builder.add_compareValue(x); }
    if let Some(x) = args.isLastChangedAuthorId { builder.add_isLastChangedAuthorId(x); }
    if let Some(x) = args.isLastChangedDate { builder.add_isLastChangedDate(x); }
    builder.add_opeType(args.opeType);
    builder.add_slotId(args.slotId);
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> Option<TusUser<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusUser>>(TusTryAndSetVariableRequest::VT_USER, None)}
  }
  #[inline]
  pub fn slotId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusTryAndSetVariableRequest::VT_SLOTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn opeType(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusTryAndSetVariableRequest::VT_OPETYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn variable(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TusTryAndSetVariableRequest::VT_VARIABLE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn isLastChangedDate(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(TusTryAndSetVariableRequest::VT_ISLASTCHANGEDDATE, None)}
  }
  #[inline]
  pub fn isLastChangedAuthorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TusTryAndSetVariableRequest::VT_ISLASTCHANGEDAUTHORID, None)}
  }
  #[inline]
  pub fn compareValue(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(TusTryAndSetVariableRequest::VT_COMPAREVALUE, None)}
  }
}

impl flatbuffers::Verifiable for TusTryAndSetVariableRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusUser>>("user", Self::VT_USER, false)?
     .visit_field::<i32>("slotId", Self::VT_SLOTID, false)?
     .visit_field::<i32>("opeType", Self::VT_OPETYPE, false)?
     .visit_field::<i64>("variable", Self::VT_VARIABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("isLastChangedDate", Self::VT_ISLASTCHANGEDDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("isLastChangedAuthorId", Self::VT_ISLASTCHANGEDAUTHORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("compareValue", Self::VT_COMPAREVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct TusTryAndSetVariableRequestArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<TusUser<'a>>>,
    pub slotId: i32,
    pub opeType: i32,
    pub variable: i64,
    pub isLastChangedDate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub isLastChangedAuthorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub compareValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for TusTryAndSetVariableRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusTryAndSetVariableRequestArgs {
      user: None,
      slotId: 0,
      opeType: 0,
      variable: 0,
      isLastChangedDate: None,
      isLastChangedAuthorId: None,
      compareValue: None,
    }
  }
}

pub struct TusTryAndSetVariableRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusTryAndSetVariableRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<TusUser<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusUser>>(TusTryAndSetVariableRequest::VT_USER, user);
  }
  #[inline]
  pub fn add_slotId(&mut self, slotId: i32) {
    self.fbb_.push_slot::<i32>(TusTryAndSetVariableRequest::VT_SLOTID, slotId, 0);
  }
  #[inline]
  pub fn add_opeType(&mut self, opeType: i32) {
    self.fbb_.push_slot::<i32>(TusTryAndSetVariableRequest::VT_OPETYPE, opeType, 0);
  }
  #[inline]
  pub fn add_variable(&mut self, variable: i64) {
    self.fbb_.push_slot::<i64>(TusTryAndSetVariableRequest::VT_VARIABLE, variable, 0);
  }
  #[inline]
  pub fn add_isLastChangedDate(&mut self, isLastChangedDate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusTryAndSetVariableRequest::VT_ISLASTCHANGEDDATE, isLastChangedDate);
  }
  #[inline]
  pub fn add_isLastChangedAuthorId(&mut self, isLastChangedAuthorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusTryAndSetVariableRequest::VT_ISLASTCHANGEDAUTHORID, isLastChangedAuthorId);
  }
  #[inline]
  pub fn add_compareValue(&mut self, compareValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusTryAndSetVariableRequest::VT_COMPAREVALUE, compareValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusTryAndSetVariableRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusTryAndSetVariableRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusTryAndSetVariableRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusTryAndSetVariableRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusTryAndSetVariableRequest");
      ds.field("user", &self.user());
      ds.field("slotId", &self.slotId());
      ds.field("opeType", &self.opeType());
      ds.field("variable", &self.variable());
      ds.field("isLastChangedDate", &self.isLastChangedDate());
      ds.field("isLastChangedAuthorId", &self.isLastChangedAuthorId());
      ds.field("compareValue", &self.compareValue());
      ds.finish()
  }
}
pub enum TusDeleteMultiSlotVariableRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusDeleteMultiSlotVariableRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusDeleteMultiSlotVariableRequest<'a> {
  type Inner = TusDeleteMultiSlotVariableRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusDeleteMultiSlotVariableRequest<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTIDARRAY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusDeleteMultiSlotVariableRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusDeleteMultiSlotVariableRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusDeleteMultiSlotVariableRequest<'bldr>> {
    let mut builder = TusDeleteMultiSlotVariableRequestBuilder::new(_fbb);
    if let Some(x) = args.slotIdArray { builder.add_slotIdArray(x); }
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> Option<TusUser<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusUser>>(TusDeleteMultiSlotVariableRequest::VT_USER, None)}
  }
  #[inline]
  pub fn slotIdArray(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(TusDeleteMultiSlotVariableRequest::VT_SLOTIDARRAY, None)}
  }
}

impl flatbuffers::Verifiable for TusDeleteMultiSlotVariableRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusUser>>("user", Self::VT_USER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("slotIdArray", Self::VT_SLOTIDARRAY, false)?
     .finish();
    Ok(())
  }
}
pub struct TusDeleteMultiSlotVariableRequestArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<TusUser<'a>>>,
    pub slotIdArray: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for TusDeleteMultiSlotVariableRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusDeleteMultiSlotVariableRequestArgs {
      user: None,
      slotIdArray: None,
    }
  }
}

pub struct TusDeleteMultiSlotVariableRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusDeleteMultiSlotVariableRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<TusUser<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusUser>>(TusDeleteMultiSlotVariableRequest::VT_USER, user);
  }
  #[inline]
  pub fn add_slotIdArray(&mut self, slotIdArray: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusDeleteMultiSlotVariableRequest::VT_SLOTIDARRAY, slotIdArray);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusDeleteMultiSlotVariableRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusDeleteMultiSlotVariableRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusDeleteMultiSlotVariableRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusDeleteMultiSlotVariableRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusDeleteMultiSlotVariableRequest");
      ds.field("user", &self.user());
      ds.field("slotIdArray", &self.slotIdArray());
      ds.finish()
  }
}
pub enum TusSetDataRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusSetDataRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusSetDataRequest<'a> {
  type Inner = TusSetDataRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusSetDataRequest<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;
  pub const VT_INFO: flatbuffers::VOffsetT = 10;
  pub const VT_ISLASTCHANGEDDATE: flatbuffers::VOffsetT = 12;
  pub const VT_ISLASTCHANGEDAUTHORID: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusSetDataRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusSetDataRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusSetDataRequest<'bldr>> {
    let mut builder = TusSetDataRequestBuilder::new(_fbb);
    if let Some(x) = args.isLastChangedAuthorId { builder.add_isLastChangedAuthorId(x); }
    if let Some(x) = args.isLastChangedDate { builder.add_isLastChangedDate(x); }
    if let Some(x) = args.info { builder.add_info(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_slotId(args.slotId);
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> Option<TusUser<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusUser>>(TusSetDataRequest::VT_USER, None)}
  }
  #[inline]
  pub fn slotId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusSetDataRequest::VT_SLOTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TusSetDataRequest::VT_DATA, None)}
  }
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TusSetDataRequest::VT_INFO, None)}
  }
  #[inline]
  pub fn isLastChangedDate(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(TusSetDataRequest::VT_ISLASTCHANGEDDATE, None)}
  }
  #[inline]
  pub fn isLastChangedAuthorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TusSetDataRequest::VT_ISLASTCHANGEDAUTHORID, None)}
  }
}

impl flatbuffers::Verifiable for TusSetDataRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusUser>>("user", Self::VT_USER, false)?
     .visit_field::<i32>("slotId", Self::VT_SLOTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("info", Self::VT_INFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("isLastChangedDate", Self::VT_ISLASTCHANGEDDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("isLastChangedAuthorId", Self::VT_ISLASTCHANGEDAUTHORID, false)?
     .finish();
    Ok(())
  }
}
pub struct TusSetDataRequestArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<TusUser<'a>>>,
    pub slotId: i32,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub isLastChangedDate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub isLastChangedAuthorId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TusSetDataRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusSetDataRequestArgs {
      user: None,
      slotId: 0,
      data: None,
      info: None,
      isLastChangedDate: None,
      isLastChangedAuthorId: None,
    }
  }
}

pub struct TusSetDataRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusSetDataRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<TusUser<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusUser>>(TusSetDataRequest::VT_USER, user);
  }
  #[inline]
  pub fn add_slotId(&mut self, slotId: i32) {
    self.fbb_.push_slot::<i32>(TusSetDataRequest::VT_SLOTID, slotId, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusSetDataRequest::VT_DATA, data);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusSetDataRequest::VT_INFO, info);
  }
  #[inline]
  pub fn add_isLastChangedDate(&mut self, isLastChangedDate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusSetDataRequest::VT_ISLASTCHANGEDDATE, isLastChangedDate);
  }
  #[inline]
  pub fn add_isLastChangedAuthorId(&mut self, isLastChangedAuthorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusSetDataRequest::VT_ISLASTCHANGEDAUTHORID, isLastChangedAuthorId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusSetDataRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusSetDataRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusSetDataRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusSetDataRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusSetDataRequest");
      ds.field("user", &self.user());
      ds.field("slotId", &self.slotId());
      ds.field("data", &self.data());
      ds.field("info", &self.info());
      ds.field("isLastChangedDate", &self.isLastChangedDate());
      ds.field("isLastChangedAuthorId", &self.isLastChangedAuthorId());
      ds.finish()
  }
}
pub enum TusDataStatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusDataStatus<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusDataStatus<'a> {
  type Inner = TusDataStatus<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusDataStatus<'a> {
  pub const VT_OWNERID: flatbuffers::VOffsetT = 4;
  pub const VT_HASDATA: flatbuffers::VOffsetT = 6;
  pub const VT_LASTCHANGEDDATE: flatbuffers::VOffsetT = 8;
  pub const VT_LASTCHANGEDAUTHORID: flatbuffers::VOffsetT = 10;
  pub const VT_INFO: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusDataStatus { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusDataStatusArgs<'args>
  ) -> flatbuffers::WIPOffset<TusDataStatus<'bldr>> {
    let mut builder = TusDataStatusBuilder::new(_fbb);
    builder.add_lastChangedDate(args.lastChangedDate);
    if let Some(x) = args.info { builder.add_info(x); }
    if let Some(x) = args.lastChangedAuthorId { builder.add_lastChangedAuthorId(x); }
    if let Some(x) = args.ownerId { builder.add_ownerId(x); }
    builder.add_hasData(args.hasData);
    builder.finish()
  }


  #[inline]
  pub fn ownerId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TusDataStatus::VT_OWNERID, None)}
  }
  #[inline]
  pub fn hasData(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TusDataStatus::VT_HASDATA, Some(false)).unwrap()}
  }
  #[inline]
  pub fn lastChangedDate(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(TusDataStatus::VT_LASTCHANGEDDATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lastChangedAuthorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TusDataStatus::VT_LASTCHANGEDAUTHORID, None)}
  }
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TusDataStatus::VT_INFO, None)}
  }
}

impl flatbuffers::Verifiable for TusDataStatus<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ownerId", Self::VT_OWNERID, false)?
     .visit_field::<bool>("hasData", Self::VT_HASDATA, false)?
     .visit_field::<u64>("lastChangedDate", Self::VT_LASTCHANGEDDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastChangedAuthorId", Self::VT_LASTCHANGEDAUTHORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("info", Self::VT_INFO, false)?
     .finish();
    Ok(())
  }
}
pub struct TusDataStatusArgs<'a> {
    pub ownerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hasData: bool,
    pub lastChangedDate: u64,
    pub lastChangedAuthorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for TusDataStatusArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusDataStatusArgs {
      ownerId: None,
      hasData: false,
      lastChangedDate: 0,
      lastChangedAuthorId: None,
      info: None,
    }
  }
}

pub struct TusDataStatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusDataStatusBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ownerId(&mut self, ownerId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusDataStatus::VT_OWNERID, ownerId);
  }
  #[inline]
  pub fn add_hasData(&mut self, hasData: bool) {
    self.fbb_.push_slot::<bool>(TusDataStatus::VT_HASDATA, hasData, false);
  }
  #[inline]
  pub fn add_lastChangedDate(&mut self, lastChangedDate: u64) {
    self.fbb_.push_slot::<u64>(TusDataStatus::VT_LASTCHANGEDDATE, lastChangedDate, 0);
  }
  #[inline]
  pub fn add_lastChangedAuthorId(&mut self, lastChangedAuthorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusDataStatus::VT_LASTCHANGEDAUTHORID, lastChangedAuthorId);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusDataStatus::VT_INFO, info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusDataStatusBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusDataStatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusDataStatus<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusDataStatus<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusDataStatus");
      ds.field("ownerId", &self.ownerId());
      ds.field("hasData", &self.hasData());
      ds.field("lastChangedDate", &self.lastChangedDate());
      ds.field("lastChangedAuthorId", &self.lastChangedAuthorId());
      ds.field("info", &self.info());
      ds.finish()
  }
}
pub enum TusDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusData<'a> {
  type Inner = TusData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusData<'a> {
  pub const VT_STATUS: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusDataArgs<'args>
  ) -> flatbuffers::WIPOffset<TusData<'bldr>> {
    let mut builder = TusDataBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    builder.finish()
  }


  #[inline]
  pub fn status(&self) -> Option<TusDataStatus<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusDataStatus>>(TusData::VT_STATUS, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TusData::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for TusData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusDataStatus>>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct TusDataArgs<'a> {
    pub status: Option<flatbuffers::WIPOffset<TusDataStatus<'a>>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for TusDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusDataArgs {
      status: None,
      data: None,
    }
  }
}

pub struct TusDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<TusDataStatus<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusDataStatus>>(TusData::VT_STATUS, status);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusData::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusData");
      ds.field("status", &self.status());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum TusDataStatusResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusDataStatusResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusDataStatusResponse<'a> {
  type Inner = TusDataStatusResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusDataStatusResponse<'a> {
  pub const VT_STATUS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusDataStatusResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusDataStatusResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<TusDataStatusResponse<'bldr>> {
    let mut builder = TusDataStatusResponseBuilder::new(_fbb);
    if let Some(x) = args.status { builder.add_status(x); }
    builder.finish()
  }


  #[inline]
  pub fn status(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusDataStatus<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusDataStatus>>>>(TusDataStatusResponse::VT_STATUS, None)}
  }
}

impl flatbuffers::Verifiable for TusDataStatusResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TusDataStatus>>>>("status", Self::VT_STATUS, false)?
     .finish();
    Ok(())
  }
}
pub struct TusDataStatusResponseArgs<'a> {
    pub status: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusDataStatus<'a>>>>>,
}
impl<'a> Default for TusDataStatusResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusDataStatusResponseArgs {
      status: None,
    }
  }
}

pub struct TusDataStatusResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusDataStatusResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TusDataStatus<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusDataStatusResponse::VT_STATUS, status);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusDataStatusResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusDataStatusResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusDataStatusResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusDataStatusResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusDataStatusResponse");
      ds.field("status", &self.status());
      ds.finish()
  }
}
pub enum TusGetDataRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusGetDataRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusGetDataRequest<'a> {
  type Inner = TusGetDataRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusGetDataRequest<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusGetDataRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusGetDataRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusGetDataRequest<'bldr>> {
    let mut builder = TusGetDataRequestBuilder::new(_fbb);
    builder.add_slotId(args.slotId);
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> Option<TusUser<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusUser>>(TusGetDataRequest::VT_USER, None)}
  }
  #[inline]
  pub fn slotId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusGetDataRequest::VT_SLOTID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TusGetDataRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusUser>>("user", Self::VT_USER, false)?
     .visit_field::<i32>("slotId", Self::VT_SLOTID, false)?
     .finish();
    Ok(())
  }
}
pub struct TusGetDataRequestArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<TusUser<'a>>>,
    pub slotId: i32,
}
impl<'a> Default for TusGetDataRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusGetDataRequestArgs {
      user: None,
      slotId: 0,
    }
  }
}

pub struct TusGetDataRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusGetDataRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<TusUser<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusUser>>(TusGetDataRequest::VT_USER, user);
  }
  #[inline]
  pub fn add_slotId(&mut self, slotId: i32) {
    self.fbb_.push_slot::<i32>(TusGetDataRequest::VT_SLOTID, slotId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusGetDataRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusGetDataRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusGetDataRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusGetDataRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusGetDataRequest");
      ds.field("user", &self.user());
      ds.field("slotId", &self.slotId());
      ds.finish()
  }
}
pub enum TusGetMultiSlotDataStatusRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusGetMultiSlotDataStatusRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusGetMultiSlotDataStatusRequest<'a> {
  type Inner = TusGetMultiSlotDataStatusRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusGetMultiSlotDataStatusRequest<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTIDARRAY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusGetMultiSlotDataStatusRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusGetMultiSlotDataStatusRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusGetMultiSlotDataStatusRequest<'bldr>> {
    let mut builder = TusGetMultiSlotDataStatusRequestBuilder::new(_fbb);
    if let Some(x) = args.slotIdArray { builder.add_slotIdArray(x); }
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> Option<TusUser<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusUser>>(TusGetMultiSlotDataStatusRequest::VT_USER, None)}
  }
  #[inline]
  pub fn slotIdArray(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(TusGetMultiSlotDataStatusRequest::VT_SLOTIDARRAY, None)}
  }
}

impl flatbuffers::Verifiable for TusGetMultiSlotDataStatusRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusUser>>("user", Self::VT_USER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("slotIdArray", Self::VT_SLOTIDARRAY, false)?
     .finish();
    Ok(())
  }
}
pub struct TusGetMultiSlotDataStatusRequestArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<TusUser<'a>>>,
    pub slotIdArray: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for TusGetMultiSlotDataStatusRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusGetMultiSlotDataStatusRequestArgs {
      user: None,
      slotIdArray: None,
    }
  }
}

pub struct TusGetMultiSlotDataStatusRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusGetMultiSlotDataStatusRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<TusUser<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusUser>>(TusGetMultiSlotDataStatusRequest::VT_USER, user);
  }
  #[inline]
  pub fn add_slotIdArray(&mut self, slotIdArray: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusGetMultiSlotDataStatusRequest::VT_SLOTIDARRAY, slotIdArray);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusGetMultiSlotDataStatusRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusGetMultiSlotDataStatusRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusGetMultiSlotDataStatusRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusGetMultiSlotDataStatusRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusGetMultiSlotDataStatusRequest");
      ds.field("user", &self.user());
      ds.field("slotIdArray", &self.slotIdArray());
      ds.finish()
  }
}
pub enum TusGetMultiUserDataStatusRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusGetMultiUserDataStatusRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusGetMultiUserDataStatusRequest<'a> {
  type Inner = TusGetMultiUserDataStatusRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusGetMultiUserDataStatusRequest<'a> {
  pub const VT_USERS: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusGetMultiUserDataStatusRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusGetMultiUserDataStatusRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusGetMultiUserDataStatusRequest<'bldr>> {
    let mut builder = TusGetMultiUserDataStatusRequestBuilder::new(_fbb);
    builder.add_slotId(args.slotId);
    if let Some(x) = args.users { builder.add_users(x); }
    builder.finish()
  }


  #[inline]
  pub fn users(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusUser<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusUser>>>>(TusGetMultiUserDataStatusRequest::VT_USERS, None)}
  }
  #[inline]
  pub fn slotId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusGetMultiUserDataStatusRequest::VT_SLOTID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TusGetMultiUserDataStatusRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TusUser>>>>("users", Self::VT_USERS, false)?
     .visit_field::<i32>("slotId", Self::VT_SLOTID, false)?
     .finish();
    Ok(())
  }
}
pub struct TusGetMultiUserDataStatusRequestArgs<'a> {
    pub users: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TusUser<'a>>>>>,
    pub slotId: i32,
}
impl<'a> Default for TusGetMultiUserDataStatusRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusGetMultiUserDataStatusRequestArgs {
      users: None,
      slotId: 0,
    }
  }
}

pub struct TusGetMultiUserDataStatusRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusGetMultiUserDataStatusRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_users(&mut self, users: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TusUser<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusGetMultiUserDataStatusRequest::VT_USERS, users);
  }
  #[inline]
  pub fn add_slotId(&mut self, slotId: i32) {
    self.fbb_.push_slot::<i32>(TusGetMultiUserDataStatusRequest::VT_SLOTID, slotId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusGetMultiUserDataStatusRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusGetMultiUserDataStatusRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusGetMultiUserDataStatusRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusGetMultiUserDataStatusRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusGetMultiUserDataStatusRequest");
      ds.field("users", &self.users());
      ds.field("slotId", &self.slotId());
      ds.finish()
  }
}
pub enum TusGetFriendsDataStatusRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusGetFriendsDataStatusRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusGetFriendsDataStatusRequest<'a> {
  type Inner = TusGetFriendsDataStatusRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusGetFriendsDataStatusRequest<'a> {
  pub const VT_SLOTID: flatbuffers::VOffsetT = 4;
  pub const VT_INCLUDESELF: flatbuffers::VOffsetT = 6;
  pub const VT_SORTTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_ARRAYNUM: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusGetFriendsDataStatusRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusGetFriendsDataStatusRequestArgs
  ) -> flatbuffers::WIPOffset<TusGetFriendsDataStatusRequest<'bldr>> {
    let mut builder = TusGetFriendsDataStatusRequestBuilder::new(_fbb);
    builder.add_arrayNum(args.arrayNum);
    builder.add_sortType(args.sortType);
    builder.add_slotId(args.slotId);
    builder.add_includeSelf(args.includeSelf);
    builder.finish()
  }


  #[inline]
  pub fn slotId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusGetFriendsDataStatusRequest::VT_SLOTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn includeSelf(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TusGetFriendsDataStatusRequest::VT_INCLUDESELF, Some(false)).unwrap()}
  }
  #[inline]
  pub fn sortType(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TusGetFriendsDataStatusRequest::VT_SORTTYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn arrayNum(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TusGetFriendsDataStatusRequest::VT_ARRAYNUM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TusGetFriendsDataStatusRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("slotId", Self::VT_SLOTID, false)?
     .visit_field::<bool>("includeSelf", Self::VT_INCLUDESELF, false)?
     .visit_field::<i32>("sortType", Self::VT_SORTTYPE, false)?
     .visit_field::<u32>("arrayNum", Self::VT_ARRAYNUM, false)?
     .finish();
    Ok(())
  }
}
pub struct TusGetFriendsDataStatusRequestArgs {
    pub slotId: i32,
    pub includeSelf: bool,
    pub sortType: i32,
    pub arrayNum: u32,
}
impl<'a> Default for TusGetFriendsDataStatusRequestArgs {
  #[inline]
  fn default() -> Self {
    TusGetFriendsDataStatusRequestArgs {
      slotId: 0,
      includeSelf: false,
      sortType: 0,
      arrayNum: 0,
    }
  }
}

pub struct TusGetFriendsDataStatusRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusGetFriendsDataStatusRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_slotId(&mut self, slotId: i32) {
    self.fbb_.push_slot::<i32>(TusGetFriendsDataStatusRequest::VT_SLOTID, slotId, 0);
  }
  #[inline]
  pub fn add_includeSelf(&mut self, includeSelf: bool) {
    self.fbb_.push_slot::<bool>(TusGetFriendsDataStatusRequest::VT_INCLUDESELF, includeSelf, false);
  }
  #[inline]
  pub fn add_sortType(&mut self, sortType: i32) {
    self.fbb_.push_slot::<i32>(TusGetFriendsDataStatusRequest::VT_SORTTYPE, sortType, 0);
  }
  #[inline]
  pub fn add_arrayNum(&mut self, arrayNum: u32) {
    self.fbb_.push_slot::<u32>(TusGetFriendsDataStatusRequest::VT_ARRAYNUM, arrayNum, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusGetFriendsDataStatusRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusGetFriendsDataStatusRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusGetFriendsDataStatusRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusGetFriendsDataStatusRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusGetFriendsDataStatusRequest");
      ds.field("slotId", &self.slotId());
      ds.field("includeSelf", &self.includeSelf());
      ds.field("sortType", &self.sortType());
      ds.field("arrayNum", &self.arrayNum());
      ds.finish()
  }
}
pub enum TusDeleteMultiSlotDataRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TusDeleteMultiSlotDataRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TusDeleteMultiSlotDataRequest<'a> {
  type Inner = TusDeleteMultiSlotDataRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TusDeleteMultiSlotDataRequest<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTIDARRAY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TusDeleteMultiSlotDataRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TusDeleteMultiSlotDataRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<TusDeleteMultiSlotDataRequest<'bldr>> {
    let mut builder = TusDeleteMultiSlotDataRequestBuilder::new(_fbb);
    if let Some(x) = args.slotIdArray { builder.add_slotIdArray(x); }
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> Option<TusUser<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TusUser>>(TusDeleteMultiSlotDataRequest::VT_USER, None)}
  }
  #[inline]
  pub fn slotIdArray(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(TusDeleteMultiSlotDataRequest::VT_SLOTIDARRAY, None)}
  }
}

impl flatbuffers::Verifiable for TusDeleteMultiSlotDataRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TusUser>>("user", Self::VT_USER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("slotIdArray", Self::VT_SLOTIDARRAY, false)?
     .finish();
    Ok(())
  }
}
pub struct TusDeleteMultiSlotDataRequestArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<TusUser<'a>>>,
    pub slotIdArray: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for TusDeleteMultiSlotDataRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    TusDeleteMultiSlotDataRequestArgs {
      user: None,
      slotIdArray: None,
    }
  }
}

pub struct TusDeleteMultiSlotDataRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TusDeleteMultiSlotDataRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<TusUser<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TusUser>>(TusDeleteMultiSlotDataRequest::VT_USER, user);
  }
  #[inline]
  pub fn add_slotIdArray(&mut self, slotIdArray: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TusDeleteMultiSlotDataRequest::VT_SLOTIDARRAY, slotIdArray);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TusDeleteMultiSlotDataRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TusDeleteMultiSlotDataRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TusDeleteMultiSlotDataRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TusDeleteMultiSlotDataRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TusDeleteMultiSlotDataRequest");
      ds.field("user", &self.user());
      ds.field("slotIdArray", &self.slotIdArray());
      ds.finish()
  }
}
pub enum SetPresenceRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetPresenceRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetPresenceRequest<'a> {
  type Inner = SetPresenceRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SetPresenceRequest<'a> {
  pub const VT_TITLE: flatbuffers::VOffsetT = 4;
  pub const VT_TITLE_ID: flatbuffers::VOffsetT = 6;
  pub const VT_STATUS: flatbuffers::VOffsetT = 8;
  pub const VT_COMMENT: flatbuffers::VOffsetT = 10;
  pub const VT_DATA: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetPresenceRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SetPresenceRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SetPresenceRequest<'bldr>> {
    let mut builder = SetPresenceRequestBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.comment { builder.add_comment(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.title_id { builder.add_title_id(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    builder.finish()
  }


  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SetPresenceRequest::VT_TITLE, None)}
  }
  #[inline]
  pub fn title_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SetPresenceRequest::VT_TITLE_ID, None)}
  }
  #[inline]
  pub fn status(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SetPresenceRequest::VT_STATUS, None)}
  }
  #[inline]
  pub fn comment(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SetPresenceRequest::VT_COMMENT, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SetPresenceRequest::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for SetPresenceRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title_id", Self::VT_TITLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comment", Self::VT_COMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct SetPresenceRequestArgs<'a> {
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for SetPresenceRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SetPresenceRequestArgs {
      title: None,
      title_id: None,
      status: None,
      comment: None,
      data: None,
    }
  }
}

pub struct SetPresenceRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetPresenceRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetPresenceRequest::VT_TITLE, title);
  }
  #[inline]
  pub fn add_title_id(&mut self, title_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetPresenceRequest::VT_TITLE_ID, title_id);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetPresenceRequest::VT_STATUS, status);
  }
  #[inline]
  pub fn add_comment(&mut self, comment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetPresenceRequest::VT_COMMENT, comment);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetPresenceRequest::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetPresenceRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SetPresenceRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetPresenceRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SetPresenceRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SetPresenceRequest");
      ds.field("title", &self.title());
      ds.field("title_id", &self.title_id());
      ds.field("status", &self.status());
      ds.field("comment", &self.comment());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum MatchingSearchConditionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchingSearchCondition<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchingSearchCondition<'a> {
  type Inner = MatchingSearchCondition<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatchingSearchCondition<'a> {
  pub const VT_ATTR_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ATTR_ID: flatbuffers::VOffsetT = 6;
  pub const VT_COMP_OP: flatbuffers::VOffsetT = 8;
  pub const VT_COMP_VALUE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchingSearchCondition { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchingSearchConditionArgs
  ) -> flatbuffers::WIPOffset<MatchingSearchCondition<'bldr>> {
    let mut builder = MatchingSearchConditionBuilder::new(_fbb);
    builder.add_comp_value(args.comp_value);
    builder.add_comp_op(args.comp_op);
    builder.add_attr_id(args.attr_id);
    builder.add_attr_type(args.attr_type);
    builder.finish()
  }


  #[inline]
  pub fn attr_type(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingSearchCondition::VT_ATTR_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn attr_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingSearchCondition::VT_ATTR_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn comp_op(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingSearchCondition::VT_COMP_OP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn comp_value(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingSearchCondition::VT_COMP_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MatchingSearchCondition<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("attr_type", Self::VT_ATTR_TYPE, false)?
     .visit_field::<u32>("attr_id", Self::VT_ATTR_ID, false)?
     .visit_field::<u32>("comp_op", Self::VT_COMP_OP, false)?
     .visit_field::<u32>("comp_value", Self::VT_COMP_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchingSearchConditionArgs {
    pub attr_type: u32,
    pub attr_id: u32,
    pub comp_op: u32,
    pub comp_value: u32,
}
impl<'a> Default for MatchingSearchConditionArgs {
  #[inline]
  fn default() -> Self {
    MatchingSearchConditionArgs {
      attr_type: 0,
      attr_id: 0,
      comp_op: 0,
      comp_value: 0,
    }
  }
}

pub struct MatchingSearchConditionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchingSearchConditionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_attr_type(&mut self, attr_type: u32) {
    self.fbb_.push_slot::<u32>(MatchingSearchCondition::VT_ATTR_TYPE, attr_type, 0);
  }
  #[inline]
  pub fn add_attr_id(&mut self, attr_id: u32) {
    self.fbb_.push_slot::<u32>(MatchingSearchCondition::VT_ATTR_ID, attr_id, 0);
  }
  #[inline]
  pub fn add_comp_op(&mut self, comp_op: u32) {
    self.fbb_.push_slot::<u32>(MatchingSearchCondition::VT_COMP_OP, comp_op, 0);
  }
  #[inline]
  pub fn add_comp_value(&mut self, comp_value: u32) {
    self.fbb_.push_slot::<u32>(MatchingSearchCondition::VT_COMP_VALUE, comp_value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchingSearchConditionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchingSearchConditionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchingSearchCondition<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchingSearchCondition<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchingSearchCondition");
      ds.field("attr_type", &self.attr_type());
      ds.field("attr_id", &self.attr_id());
      ds.field("comp_op", &self.comp_op());
      ds.field("comp_value", &self.comp_value());
      ds.finish()
  }
}
pub enum MatchingAttrOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchingAttr<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchingAttr<'a> {
  type Inner = MatchingAttr<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatchingAttr<'a> {
  pub const VT_ATTR_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ATTR_ID: flatbuffers::VOffsetT = 6;
  pub const VT_NUM: flatbuffers::VOffsetT = 8;
  pub const VT_DATA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchingAttr { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchingAttrArgs<'args>
  ) -> flatbuffers::WIPOffset<MatchingAttr<'bldr>> {
    let mut builder = MatchingAttrBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_num(args.num);
    builder.add_attr_id(args.attr_id);
    builder.add_attr_type(args.attr_type);
    builder.finish()
  }


  #[inline]
  pub fn attr_type(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingAttr::VT_ATTR_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn attr_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingAttr::VT_ATTR_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn num(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingAttr::VT_NUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MatchingAttr::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for MatchingAttr<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("attr_type", Self::VT_ATTR_TYPE, false)?
     .visit_field::<u32>("attr_id", Self::VT_ATTR_ID, false)?
     .visit_field::<u32>("num", Self::VT_NUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchingAttrArgs<'a> {
    pub attr_type: u32,
    pub attr_id: u32,
    pub num: u32,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MatchingAttrArgs<'a> {
  #[inline]
  fn default() -> Self {
    MatchingAttrArgs {
      attr_type: 0,
      attr_id: 0,
      num: 0,
      data: None,
    }
  }
}

pub struct MatchingAttrBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchingAttrBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_attr_type(&mut self, attr_type: u32) {
    self.fbb_.push_slot::<u32>(MatchingAttr::VT_ATTR_TYPE, attr_type, 0);
  }
  #[inline]
  pub fn add_attr_id(&mut self, attr_id: u32) {
    self.fbb_.push_slot::<u32>(MatchingAttr::VT_ATTR_ID, attr_id, 0);
  }
  #[inline]
  pub fn add_num(&mut self, num: u32) {
    self.fbb_.push_slot::<u32>(MatchingAttr::VT_NUM, num, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingAttr::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchingAttrBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchingAttrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchingAttr<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchingAttr<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchingAttr");
      ds.field("attr_type", &self.attr_type());
      ds.field("attr_id", &self.attr_id());
      ds.field("num", &self.num());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum CreateRoomGUIRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateRoomGUIRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateRoomGUIRequest<'a> {
  type Inner = CreateRoomGUIRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreateRoomGUIRequest<'a> {
  pub const VT_TOTAL_SLOTS: flatbuffers::VOffsetT = 4;
  pub const VT_PRIVATE_SLOTS: flatbuffers::VOffsetT = 6;
  pub const VT_PRIVILEGE_GRANT: flatbuffers::VOffsetT = 8;
  pub const VT_STEALTH: flatbuffers::VOffsetT = 10;
  pub const VT_GAME_ATTRS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateRoomGUIRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateRoomGUIRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<CreateRoomGUIRequest<'bldr>> {
    let mut builder = CreateRoomGUIRequestBuilder::new(_fbb);
    if let Some(x) = args.game_attrs { builder.add_game_attrs(x); }
    builder.add_private_slots(args.private_slots);
    builder.add_total_slots(args.total_slots);
    builder.add_stealth(args.stealth);
    builder.add_privilege_grant(args.privilege_grant);
    builder.finish()
  }


  #[inline]
  pub fn total_slots(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CreateRoomGUIRequest::VT_TOTAL_SLOTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn private_slots(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CreateRoomGUIRequest::VT_PRIVATE_SLOTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn privilege_grant(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CreateRoomGUIRequest::VT_PRIVILEGE_GRANT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn stealth(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CreateRoomGUIRequest::VT_STEALTH, Some(false)).unwrap()}
  }
  #[inline]
  pub fn game_attrs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr>>>>(CreateRoomGUIRequest::VT_GAME_ATTRS, None)}
  }
}

impl flatbuffers::Verifiable for CreateRoomGUIRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("total_slots", Self::VT_TOTAL_SLOTS, false)?
     .visit_field::<u32>("private_slots", Self::VT_PRIVATE_SLOTS, false)?
     .visit_field::<bool>("privilege_grant", Self::VT_PRIVILEGE_GRANT, false)?
     .visit_field::<bool>("stealth", Self::VT_STEALTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingAttr>>>>("game_attrs", Self::VT_GAME_ATTRS, false)?
     .finish();
    Ok(())
  }
}
pub struct CreateRoomGUIRequestArgs<'a> {
    pub total_slots: u32,
    pub private_slots: u32,
    pub privilege_grant: bool,
    pub stealth: bool,
    pub game_attrs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>>>,
}
impl<'a> Default for CreateRoomGUIRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreateRoomGUIRequestArgs {
      total_slots: 0,
      private_slots: 0,
      privilege_grant: false,
      stealth: false,
      game_attrs: None,
    }
  }
}

pub struct CreateRoomGUIRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateRoomGUIRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_total_slots(&mut self, total_slots: u32) {
    self.fbb_.push_slot::<u32>(CreateRoomGUIRequest::VT_TOTAL_SLOTS, total_slots, 0);
  }
  #[inline]
  pub fn add_private_slots(&mut self, private_slots: u32) {
    self.fbb_.push_slot::<u32>(CreateRoomGUIRequest::VT_PRIVATE_SLOTS, private_slots, 0);
  }
  #[inline]
  pub fn add_privilege_grant(&mut self, privilege_grant: bool) {
    self.fbb_.push_slot::<bool>(CreateRoomGUIRequest::VT_PRIVILEGE_GRANT, privilege_grant, false);
  }
  #[inline]
  pub fn add_stealth(&mut self, stealth: bool) {
    self.fbb_.push_slot::<bool>(CreateRoomGUIRequest::VT_STEALTH, stealth, false);
  }
  #[inline]
  pub fn add_game_attrs(&mut self, game_attrs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateRoomGUIRequest::VT_GAME_ATTRS, game_attrs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateRoomGUIRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateRoomGUIRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateRoomGUIRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreateRoomGUIRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreateRoomGUIRequest");
      ds.field("total_slots", &self.total_slots());
      ds.field("private_slots", &self.private_slots());
      ds.field("privilege_grant", &self.privilege_grant());
      ds.field("stealth", &self.stealth());
      ds.field("game_attrs", &self.game_attrs());
      ds.finish()
  }
}
pub enum GUIUserInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GUIUserInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GUIUserInfo<'a> {
  type Inner = GUIUserInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GUIUserInfo<'a> {
  pub const VT_INFO: flatbuffers::VOffsetT = 4;
  pub const VT_OWNER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GUIUserInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GUIUserInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<GUIUserInfo<'bldr>> {
    let mut builder = GUIUserInfoBuilder::new(_fbb);
    if let Some(x) = args.info { builder.add_info(x); }
    builder.add_owner(args.owner);
    builder.finish()
  }


  #[inline]
  pub fn info(&self) -> Option<UserInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo>>(GUIUserInfo::VT_INFO, None)}
  }
  #[inline]
  pub fn owner(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GUIUserInfo::VT_OWNER, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GUIUserInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<UserInfo>>("info", Self::VT_INFO, false)?
     .visit_field::<bool>("owner", Self::VT_OWNER, false)?
     .finish();
    Ok(())
  }
}
pub struct GUIUserInfoArgs<'a> {
    pub info: Option<flatbuffers::WIPOffset<UserInfo<'a>>>,
    pub owner: bool,
}
impl<'a> Default for GUIUserInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    GUIUserInfoArgs {
      info: None,
      owner: false,
    }
  }
}

pub struct GUIUserInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GUIUserInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<UserInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo>>(GUIUserInfo::VT_INFO, info);
  }
  #[inline]
  pub fn add_owner(&mut self, owner: bool) {
    self.fbb_.push_slot::<bool>(GUIUserInfo::VT_OWNER, owner, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GUIUserInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GUIUserInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GUIUserInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GUIUserInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GUIUserInfo");
      ds.field("info", &self.info());
      ds.field("owner", &self.owner());
      ds.finish()
  }
}
pub enum MatchingRoomStatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchingRoomStatus<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchingRoomStatus<'a> {
  type Inner = MatchingRoomStatus<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatchingRoomStatus<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MEMBERS: flatbuffers::VOffsetT = 6;
  pub const VT_KICK_ACTOR: flatbuffers::VOffsetT = 8;
  pub const VT_OPT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchingRoomStatus { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchingRoomStatusArgs<'args>
  ) -> flatbuffers::WIPOffset<MatchingRoomStatus<'bldr>> {
    let mut builder = MatchingRoomStatusBuilder::new(_fbb);
    if let Some(x) = args.opt { builder.add_opt(x); }
    if let Some(x) = args.kick_actor { builder.add_kick_actor(x); }
    if let Some(x) = args.members { builder.add_members(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MatchingRoomStatus::VT_ID, None)}
  }
  #[inline]
  pub fn members(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GUIUserInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GUIUserInfo>>>>(MatchingRoomStatus::VT_MEMBERS, None)}
  }
  #[inline]
  pub fn kick_actor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MatchingRoomStatus::VT_KICK_ACTOR, None)}
  }
  #[inline]
  pub fn opt(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MatchingRoomStatus::VT_OPT, None)}
  }
}

impl flatbuffers::Verifiable for MatchingRoomStatus<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GUIUserInfo>>>>("members", Self::VT_MEMBERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("kick_actor", Self::VT_KICK_ACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("opt", Self::VT_OPT, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchingRoomStatusArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub members: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GUIUserInfo<'a>>>>>,
    pub kick_actor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opt: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MatchingRoomStatusArgs<'a> {
  #[inline]
  fn default() -> Self {
    MatchingRoomStatusArgs {
      id: None,
      members: None,
      kick_actor: None,
      opt: None,
    }
  }
}

pub struct MatchingRoomStatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchingRoomStatusBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingRoomStatus::VT_ID, id);
  }
  #[inline]
  pub fn add_members(&mut self, members: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GUIUserInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingRoomStatus::VT_MEMBERS, members);
  }
  #[inline]
  pub fn add_kick_actor(&mut self, kick_actor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingRoomStatus::VT_KICK_ACTOR, kick_actor);
  }
  #[inline]
  pub fn add_opt(&mut self, opt: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingRoomStatus::VT_OPT, opt);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchingRoomStatusBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchingRoomStatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchingRoomStatus<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchingRoomStatus<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchingRoomStatus");
      ds.field("id", &self.id());
      ds.field("members", &self.members());
      ds.field("kick_actor", &self.kick_actor());
      ds.field("opt", &self.opt());
      ds.finish()
  }
}
pub enum GetRoomListGUIRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetRoomListGUIRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRoomListGUIRequest<'a> {
  type Inner = GetRoomListGUIRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetRoomListGUIRequest<'a> {
  pub const VT_RANGE_START: flatbuffers::VOffsetT = 4;
  pub const VT_RANGE_MAX: flatbuffers::VOffsetT = 6;
  pub const VT_CONDS: flatbuffers::VOffsetT = 8;
  pub const VT_ATTRS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetRoomListGUIRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetRoomListGUIRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetRoomListGUIRequest<'bldr>> {
    let mut builder = GetRoomListGUIRequestBuilder::new(_fbb);
    if let Some(x) = args.attrs { builder.add_attrs(x); }
    if let Some(x) = args.conds { builder.add_conds(x); }
    builder.add_range_max(args.range_max);
    builder.add_range_start(args.range_start);
    builder.finish()
  }


  #[inline]
  pub fn range_start(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetRoomListGUIRequest::VT_RANGE_START, Some(0)).unwrap()}
  }
  #[inline]
  pub fn range_max(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GetRoomListGUIRequest::VT_RANGE_MAX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn conds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingSearchCondition<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingSearchCondition>>>>(GetRoomListGUIRequest::VT_CONDS, None)}
  }
  #[inline]
  pub fn attrs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr>>>>(GetRoomListGUIRequest::VT_ATTRS, None)}
  }
}

impl flatbuffers::Verifiable for GetRoomListGUIRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("range_start", Self::VT_RANGE_START, false)?
     .visit_field::<u32>("range_max", Self::VT_RANGE_MAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingSearchCondition>>>>("conds", Self::VT_CONDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingAttr>>>>("attrs", Self::VT_ATTRS, false)?
     .finish();
    Ok(())
  }
}
pub struct GetRoomListGUIRequestArgs<'a> {
    pub range_start: u32,
    pub range_max: u32,
    pub conds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingSearchCondition<'a>>>>>,
    pub attrs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>>>,
}
impl<'a> Default for GetRoomListGUIRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetRoomListGUIRequestArgs {
      range_start: 0,
      range_max: 0,
      conds: None,
      attrs: None,
    }
  }
}

pub struct GetRoomListGUIRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetRoomListGUIRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_range_start(&mut self, range_start: u32) {
    self.fbb_.push_slot::<u32>(GetRoomListGUIRequest::VT_RANGE_START, range_start, 0);
  }
  #[inline]
  pub fn add_range_max(&mut self, range_max: u32) {
    self.fbb_.push_slot::<u32>(GetRoomListGUIRequest::VT_RANGE_MAX, range_max, 0);
  }
  #[inline]
  pub fn add_conds(&mut self, conds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingSearchCondition<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRoomListGUIRequest::VT_CONDS, conds);
  }
  #[inline]
  pub fn add_attrs(&mut self, attrs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRoomListGUIRequest::VT_ATTRS, attrs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetRoomListGUIRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetRoomListGUIRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRoomListGUIRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetRoomListGUIRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetRoomListGUIRequest");
      ds.field("range_start", &self.range_start());
      ds.field("range_max", &self.range_max());
      ds.field("conds", &self.conds());
      ds.field("attrs", &self.attrs());
      ds.finish()
  }
}
pub enum MatchingRoomOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchingRoom<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchingRoom<'a> {
  type Inner = MatchingRoom<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatchingRoom<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ATTR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchingRoom { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchingRoomArgs<'args>
  ) -> flatbuffers::WIPOffset<MatchingRoom<'bldr>> {
    let mut builder = MatchingRoomBuilder::new(_fbb);
    if let Some(x) = args.attr { builder.add_attr(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MatchingRoom::VT_ID, None)}
  }
  #[inline]
  pub fn attr(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr>>>>(MatchingRoom::VT_ATTR, None)}
  }
}

impl flatbuffers::Verifiable for MatchingRoom<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingAttr>>>>("attr", Self::VT_ATTR, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchingRoomArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub attr: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>>>,
}
impl<'a> Default for MatchingRoomArgs<'a> {
  #[inline]
  fn default() -> Self {
    MatchingRoomArgs {
      id: None,
      attr: None,
    }
  }
}

pub struct MatchingRoomBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchingRoomBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingRoom::VT_ID, id);
  }
  #[inline]
  pub fn add_attr(&mut self, attr: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingRoom::VT_ATTR, attr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchingRoomBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchingRoomBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchingRoom<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchingRoom<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchingRoom");
      ds.field("id", &self.id());
      ds.field("attr", &self.attr());
      ds.finish()
  }
}
pub enum MatchingRoomListOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchingRoomList<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchingRoomList<'a> {
  type Inner = MatchingRoomList<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatchingRoomList<'a> {
  pub const VT_START: flatbuffers::VOffsetT = 4;
  pub const VT_TOTAL: flatbuffers::VOffsetT = 6;
  pub const VT_ROOMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchingRoomList { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchingRoomListArgs<'args>
  ) -> flatbuffers::WIPOffset<MatchingRoomList<'bldr>> {
    let mut builder = MatchingRoomListBuilder::new(_fbb);
    if let Some(x) = args.rooms { builder.add_rooms(x); }
    builder.add_total(args.total);
    builder.add_start(args.start);
    builder.finish()
  }


  #[inline]
  pub fn start(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingRoomList::VT_START, Some(0)).unwrap()}
  }
  #[inline]
  pub fn total(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingRoomList::VT_TOTAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rooms(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingRoom<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingRoom>>>>(MatchingRoomList::VT_ROOMS, None)}
  }
}

impl flatbuffers::Verifiable for MatchingRoomList<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("start", Self::VT_START, false)?
     .visit_field::<u32>("total", Self::VT_TOTAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingRoom>>>>("rooms", Self::VT_ROOMS, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchingRoomListArgs<'a> {
    pub start: u32,
    pub total: u32,
    pub rooms: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingRoom<'a>>>>>,
}
impl<'a> Default for MatchingRoomListArgs<'a> {
  #[inline]
  fn default() -> Self {
    MatchingRoomListArgs {
      start: 0,
      total: 0,
      rooms: None,
    }
  }
}

pub struct MatchingRoomListBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchingRoomListBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_start(&mut self, start: u32) {
    self.fbb_.push_slot::<u32>(MatchingRoomList::VT_START, start, 0);
  }
  #[inline]
  pub fn add_total(&mut self, total: u32) {
    self.fbb_.push_slot::<u32>(MatchingRoomList::VT_TOTAL, total, 0);
  }
  #[inline]
  pub fn add_rooms(&mut self, rooms: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingRoom<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingRoomList::VT_ROOMS, rooms);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchingRoomListBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchingRoomListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchingRoomList<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchingRoomList<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchingRoomList");
      ds.field("start", &self.start());
      ds.field("total", &self.total());
      ds.field("rooms", &self.rooms());
      ds.finish()
  }
}
pub enum MatchingGuiRoomIdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchingGuiRoomId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchingGuiRoomId<'a> {
  type Inner = MatchingGuiRoomId<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatchingGuiRoomId<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchingGuiRoomId { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchingGuiRoomIdArgs<'args>
  ) -> flatbuffers::WIPOffset<MatchingGuiRoomId<'bldr>> {
    let mut builder = MatchingGuiRoomIdBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MatchingGuiRoomId::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for MatchingGuiRoomId<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchingGuiRoomIdArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MatchingGuiRoomIdArgs<'a> {
  #[inline]
  fn default() -> Self {
    MatchingGuiRoomIdArgs {
      id: None,
    }
  }
}

pub struct MatchingGuiRoomIdBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchingGuiRoomIdBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingGuiRoomId::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchingGuiRoomIdBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchingGuiRoomIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchingGuiRoomId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchingGuiRoomId<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchingGuiRoomId");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum SetRoomSearchFlagGUIOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetRoomSearchFlagGUI<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetRoomSearchFlagGUI<'a> {
  type Inner = SetRoomSearchFlagGUI<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SetRoomSearchFlagGUI<'a> {
  pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
  pub const VT_STEALTH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetRoomSearchFlagGUI { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SetRoomSearchFlagGUIArgs<'args>
  ) -> flatbuffers::WIPOffset<SetRoomSearchFlagGUI<'bldr>> {
    let mut builder = SetRoomSearchFlagGUIBuilder::new(_fbb);
    if let Some(x) = args.roomid { builder.add_roomid(x); }
    builder.add_stealth(args.stealth);
    builder.finish()
  }


  #[inline]
  pub fn roomid(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SetRoomSearchFlagGUI::VT_ROOMID, None)}
  }
  #[inline]
  pub fn stealth(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SetRoomSearchFlagGUI::VT_STEALTH, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SetRoomSearchFlagGUI<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("roomid", Self::VT_ROOMID, false)?
     .visit_field::<bool>("stealth", Self::VT_STEALTH, false)?
     .finish();
    Ok(())
  }
}
pub struct SetRoomSearchFlagGUIArgs<'a> {
    pub roomid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub stealth: bool,
}
impl<'a> Default for SetRoomSearchFlagGUIArgs<'a> {
  #[inline]
  fn default() -> Self {
    SetRoomSearchFlagGUIArgs {
      roomid: None,
      stealth: false,
    }
  }
}

pub struct SetRoomSearchFlagGUIBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetRoomSearchFlagGUIBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roomid(&mut self, roomid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomSearchFlagGUI::VT_ROOMID, roomid);
  }
  #[inline]
  pub fn add_stealth(&mut self, stealth: bool) {
    self.fbb_.push_slot::<bool>(SetRoomSearchFlagGUI::VT_STEALTH, stealth, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetRoomSearchFlagGUIBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SetRoomSearchFlagGUIBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetRoomSearchFlagGUI<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SetRoomSearchFlagGUI<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SetRoomSearchFlagGUI");
      ds.field("roomid", &self.roomid());
      ds.field("stealth", &self.stealth());
      ds.finish()
  }
}
pub enum QuickMatchGUIRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QuickMatchGUIRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QuickMatchGUIRequest<'a> {
  type Inner = QuickMatchGUIRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QuickMatchGUIRequest<'a> {
  pub const VT_CONDS: flatbuffers::VOffsetT = 4;
  pub const VT_AVAILABLE_NUM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QuickMatchGUIRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args QuickMatchGUIRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<QuickMatchGUIRequest<'bldr>> {
    let mut builder = QuickMatchGUIRequestBuilder::new(_fbb);
    builder.add_available_num(args.available_num);
    if let Some(x) = args.conds { builder.add_conds(x); }
    builder.finish()
  }


  #[inline]
  pub fn conds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingSearchCondition<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingSearchCondition>>>>(QuickMatchGUIRequest::VT_CONDS, None)}
  }
  #[inline]
  pub fn available_num(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(QuickMatchGUIRequest::VT_AVAILABLE_NUM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for QuickMatchGUIRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingSearchCondition>>>>("conds", Self::VT_CONDS, false)?
     .visit_field::<u32>("available_num", Self::VT_AVAILABLE_NUM, false)?
     .finish();
    Ok(())
  }
}
pub struct QuickMatchGUIRequestArgs<'a> {
    pub conds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingSearchCondition<'a>>>>>,
    pub available_num: u32,
}
impl<'a> Default for QuickMatchGUIRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    QuickMatchGUIRequestArgs {
      conds: None,
      available_num: 0,
    }
  }
}

pub struct QuickMatchGUIRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> QuickMatchGUIRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_conds(&mut self, conds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingSearchCondition<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuickMatchGUIRequest::VT_CONDS, conds);
  }
  #[inline]
  pub fn add_available_num(&mut self, available_num: u32) {
    self.fbb_.push_slot::<u32>(QuickMatchGUIRequest::VT_AVAILABLE_NUM, available_num, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> QuickMatchGUIRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    QuickMatchGUIRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QuickMatchGUIRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QuickMatchGUIRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QuickMatchGUIRequest");
      ds.field("conds", &self.conds());
      ds.field("available_num", &self.available_num());
      ds.finish()
  }
}
pub enum SearchJoinRoomGUIRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SearchJoinRoomGUIRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SearchJoinRoomGUIRequest<'a> {
  type Inner = SearchJoinRoomGUIRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SearchJoinRoomGUIRequest<'a> {
  pub const VT_CONDS: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SearchJoinRoomGUIRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SearchJoinRoomGUIRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SearchJoinRoomGUIRequest<'bldr>> {
    let mut builder = SearchJoinRoomGUIRequestBuilder::new(_fbb);
    if let Some(x) = args.attrs { builder.add_attrs(x); }
    if let Some(x) = args.conds { builder.add_conds(x); }
    builder.finish()
  }


  #[inline]
  pub fn conds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingSearchCondition<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingSearchCondition>>>>(SearchJoinRoomGUIRequest::VT_CONDS, None)}
  }
  #[inline]
  pub fn attrs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr>>>>(SearchJoinRoomGUIRequest::VT_ATTRS, None)}
  }
}

impl flatbuffers::Verifiable for SearchJoinRoomGUIRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingSearchCondition>>>>("conds", Self::VT_CONDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingAttr>>>>("attrs", Self::VT_ATTRS, false)?
     .finish();
    Ok(())
  }
}
pub struct SearchJoinRoomGUIRequestArgs<'a> {
    pub conds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingSearchCondition<'a>>>>>,
    pub attrs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>>>,
}
impl<'a> Default for SearchJoinRoomGUIRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SearchJoinRoomGUIRequestArgs {
      conds: None,
      attrs: None,
    }
  }
}

pub struct SearchJoinRoomGUIRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SearchJoinRoomGUIRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_conds(&mut self, conds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingSearchCondition<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchJoinRoomGUIRequest::VT_CONDS, conds);
  }
  #[inline]
  pub fn add_attrs(&mut self, attrs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchJoinRoomGUIRequest::VT_ATTRS, attrs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SearchJoinRoomGUIRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SearchJoinRoomGUIRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SearchJoinRoomGUIRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SearchJoinRoomGUIRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SearchJoinRoomGUIRequest");
      ds.field("conds", &self.conds());
      ds.field("attrs", &self.attrs());
      ds.finish()
  }
}
pub enum MatchingSearchJoinRoomInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchingSearchJoinRoomInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchingSearchJoinRoomInfo<'a> {
  type Inner = MatchingSearchJoinRoomInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatchingSearchJoinRoomInfo<'a> {
  pub const VT_ROOM: flatbuffers::VOffsetT = 4;
  pub const VT_ATTR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchingSearchJoinRoomInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchingSearchJoinRoomInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<MatchingSearchJoinRoomInfo<'bldr>> {
    let mut builder = MatchingSearchJoinRoomInfoBuilder::new(_fbb);
    if let Some(x) = args.attr { builder.add_attr(x); }
    if let Some(x) = args.room { builder.add_room(x); }
    builder.finish()
  }


  #[inline]
  pub fn room(&self) -> Option<MatchingRoomStatus<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MatchingRoomStatus>>(MatchingSearchJoinRoomInfo::VT_ROOM, None)}
  }
  #[inline]
  pub fn attr(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr>>>>(MatchingSearchJoinRoomInfo::VT_ATTR, None)}
  }
}

impl flatbuffers::Verifiable for MatchingSearchJoinRoomInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<MatchingRoomStatus>>("room", Self::VT_ROOM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingAttr>>>>("attr", Self::VT_ATTR, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchingSearchJoinRoomInfoArgs<'a> {
    pub room: Option<flatbuffers::WIPOffset<MatchingRoomStatus<'a>>>,
    pub attr: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingAttr<'a>>>>>,
}
impl<'a> Default for MatchingSearchJoinRoomInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    MatchingSearchJoinRoomInfoArgs {
      room: None,
      attr: None,
    }
  }
}

pub struct MatchingSearchJoinRoomInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchingSearchJoinRoomInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_room(&mut self, room: flatbuffers::WIPOffset<MatchingRoomStatus<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MatchingRoomStatus>>(MatchingSearchJoinRoomInfo::VT_ROOM, room);
  }
  #[inline]
  pub fn add_attr(&mut self, attr: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingSearchJoinRoomInfo::VT_ATTR, attr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchingSearchJoinRoomInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchingSearchJoinRoomInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchingSearchJoinRoomInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchingSearchJoinRoomInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchingSearchJoinRoomInfo");
      ds.field("room", &self.room());
      ds.field("attr", &self.attr());
      ds.finish()
  }
}
