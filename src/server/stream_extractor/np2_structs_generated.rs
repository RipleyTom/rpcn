// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum BinAttrOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinAttr<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinAttr<'a> {
    type Inner = BinAttr<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> BinAttr<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BinAttr { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BinAttrArgs<'args>) -> flatbuffers::WIPOffset<BinAttr<'bldr>> {
      let mut builder = BinAttrBuilder::new(_fbb);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(BinAttr::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(BinAttr::VT_DATA, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for BinAttr<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct BinAttrArgs<'a> {
    pub id: u16,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BinAttrArgs<'a> {
    #[inline]
    fn default() -> Self {
        BinAttrArgs {
            id: 0,
            data: None,
        }
    }
}
pub struct BinAttrBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BinAttrBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(BinAttr::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinAttr::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinAttrBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BinAttrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinAttr<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for BinAttr<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("BinAttr");
      ds.field("id", &self.id());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum IntAttrOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntAttr<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntAttr<'a> {
    type Inner = IntAttr<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> IntAttr<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntAttr { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IntAttrArgs) -> flatbuffers::WIPOffset<IntAttr<'bldr>> {
      let mut builder = IntAttrBuilder::new(_fbb);
      builder.add_num(args.num);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NUM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(IntAttr::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn num(&self) -> u32 {
    self._tab.get::<u32>(IntAttr::VT_NUM, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for IntAttr<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .visit_field::<u32>(&"num", Self::VT_NUM, false)?
     .finish();
    Ok(())
  }
}
pub struct IntAttrArgs {
    pub id: u16,
    pub num: u32,
}
impl<'a> Default for IntAttrArgs {
    #[inline]
    fn default() -> Self {
        IntAttrArgs {
            id: 0,
            num: 0,
        }
    }
}
pub struct IntAttrBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntAttrBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(IntAttr::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_num(&mut self, num: u32) {
    self.fbb_.push_slot::<u32>(IntAttr::VT_NUM, num, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntAttrBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IntAttrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntAttr<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for IntAttr<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("IntAttr");
      ds.field("id", &self.id());
      ds.field("num", &self.num());
      ds.finish()
  }
}
pub enum MemberBinAttrInternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MemberBinAttrInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MemberBinAttrInternal<'a> {
    type Inner = MemberBinAttrInternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MemberBinAttrInternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MemberBinAttrInternal { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MemberBinAttrInternalArgs<'args>) -> flatbuffers::WIPOffset<MemberBinAttrInternal<'bldr>> {
      let mut builder = MemberBinAttrInternalBuilder::new(_fbb);
      builder.add_updateDate(args.updateDate);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.finish()
    }

    pub const VT_UPDATEDATE: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn updateDate(&self) -> u64 {
    self._tab.get::<u64>(MemberBinAttrInternal::VT_UPDATEDATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<BinAttr<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BinAttr>>(MemberBinAttrInternal::VT_DATA, None)
  }
}

impl flatbuffers::Verifiable for MemberBinAttrInternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"updateDate", Self::VT_UPDATEDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinAttr>>(&"data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct MemberBinAttrInternalArgs<'a> {
    pub updateDate: u64,
    pub data: Option<flatbuffers::WIPOffset<BinAttr<'a>>>,
}
impl<'a> Default for MemberBinAttrInternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        MemberBinAttrInternalArgs {
            updateDate: 0,
            data: None,
        }
    }
}
pub struct MemberBinAttrInternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MemberBinAttrInternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_updateDate(&mut self, updateDate: u64) {
    self.fbb_.push_slot::<u64>(MemberBinAttrInternal::VT_UPDATEDATE, updateDate, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<BinAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinAttr>>(MemberBinAttrInternal::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MemberBinAttrInternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MemberBinAttrInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MemberBinAttrInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MemberBinAttrInternal<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MemberBinAttrInternal");
      ds.field("updateDate", &self.updateDate());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum BinAttrInternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinAttrInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinAttrInternal<'a> {
    type Inner = BinAttrInternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> BinAttrInternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BinAttrInternal { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BinAttrInternalArgs<'args>) -> flatbuffers::WIPOffset<BinAttrInternal<'bldr>> {
      let mut builder = BinAttrInternalBuilder::new(_fbb);
      builder.add_updateDate(args.updateDate);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.add_updateMemberId(args.updateMemberId);
      builder.finish()
    }

    pub const VT_UPDATEDATE: flatbuffers::VOffsetT = 4;
    pub const VT_UPDATEMEMBERID: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn updateDate(&self) -> u64 {
    self._tab.get::<u64>(BinAttrInternal::VT_UPDATEDATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn updateMemberId(&self) -> u16 {
    self._tab.get::<u16>(BinAttrInternal::VT_UPDATEMEMBERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<BinAttr<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BinAttr>>(BinAttrInternal::VT_DATA, None)
  }
}

impl flatbuffers::Verifiable for BinAttrInternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"updateDate", Self::VT_UPDATEDATE, false)?
     .visit_field::<u16>(&"updateMemberId", Self::VT_UPDATEMEMBERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinAttr>>(&"data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct BinAttrInternalArgs<'a> {
    pub updateDate: u64,
    pub updateMemberId: u16,
    pub data: Option<flatbuffers::WIPOffset<BinAttr<'a>>>,
}
impl<'a> Default for BinAttrInternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        BinAttrInternalArgs {
            updateDate: 0,
            updateMemberId: 0,
            data: None,
        }
    }
}
pub struct BinAttrInternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BinAttrInternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_updateDate(&mut self, updateDate: u64) {
    self.fbb_.push_slot::<u64>(BinAttrInternal::VT_UPDATEDATE, updateDate, 0);
  }
  #[inline]
  pub fn add_updateMemberId(&mut self, updateMemberId: u16) {
    self.fbb_.push_slot::<u16>(BinAttrInternal::VT_UPDATEMEMBERID, updateMemberId, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<BinAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinAttr>>(BinAttrInternal::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinAttrInternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BinAttrInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinAttrInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for BinAttrInternal<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("BinAttrInternal");
      ds.field("updateDate", &self.updateDate());
      ds.field("updateMemberId", &self.updateMemberId());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum OptParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OptParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OptParam<'a> {
    type Inner = OptParam<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> OptParam<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OptParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OptParamArgs) -> flatbuffers::WIPOffset<OptParam<'bldr>> {
      let mut builder = OptParamBuilder::new(_fbb);
      builder.add_hubMemberId(args.hubMemberId);
      builder.add_flag(args.flag);
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_FLAG: flatbuffers::VOffsetT = 6;
    pub const VT_HUBMEMBERID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn type_(&self) -> u8 {
    self._tab.get::<u8>(OptParam::VT_TYPE_, Some(0)).unwrap()
  }
  #[inline]
  pub fn flag(&self) -> u8 {
    self._tab.get::<u8>(OptParam::VT_FLAG, Some(0)).unwrap()
  }
  #[inline]
  pub fn hubMemberId(&self) -> u16 {
    self._tab.get::<u16>(OptParam::VT_HUBMEMBERID, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for OptParam<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>(&"type_", Self::VT_TYPE_, false)?
     .visit_field::<u8>(&"flag", Self::VT_FLAG, false)?
     .visit_field::<u16>(&"hubMemberId", Self::VT_HUBMEMBERID, false)?
     .finish();
    Ok(())
  }
}
pub struct OptParamArgs {
    pub type_: u8,
    pub flag: u8,
    pub hubMemberId: u16,
}
impl<'a> Default for OptParamArgs {
    #[inline]
    fn default() -> Self {
        OptParamArgs {
            type_: 0,
            flag: 0,
            hubMemberId: 0,
        }
    }
}
pub struct OptParamBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OptParamBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: u8) {
    self.fbb_.push_slot::<u8>(OptParam::VT_TYPE_, type_, 0);
  }
  #[inline]
  pub fn add_flag(&mut self, flag: u8) {
    self.fbb_.push_slot::<u8>(OptParam::VT_FLAG, flag, 0);
  }
  #[inline]
  pub fn add_hubMemberId(&mut self, hubMemberId: u16) {
    self.fbb_.push_slot::<u16>(OptParam::VT_HUBMEMBERID, hubMemberId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OptParamBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OptParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OptParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for OptParam<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("OptParam");
      ds.field("type_", &self.type_());
      ds.field("flag", &self.flag());
      ds.field("hubMemberId", &self.hubMemberId());
      ds.finish()
  }
}
pub enum GroupConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GroupConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GroupConfig<'a> {
    type Inner = GroupConfig<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> GroupConfig<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GroupConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GroupConfigArgs<'args>) -> flatbuffers::WIPOffset<GroupConfig<'bldr>> {
      let mut builder = GroupConfigBuilder::new(_fbb);
      if let Some(x) = args.label { builder.add_label(x); }
      builder.add_slotNum(args.slotNum);
      builder.add_withPassword(args.withPassword);
      builder.add_withLabel(args.withLabel);
      builder.finish()
    }

    pub const VT_SLOTNUM: flatbuffers::VOffsetT = 4;
    pub const VT_WITHLABEL: flatbuffers::VOffsetT = 6;
    pub const VT_LABEL: flatbuffers::VOffsetT = 8;
    pub const VT_WITHPASSWORD: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn slotNum(&self) -> u32 {
    self._tab.get::<u32>(GroupConfig::VT_SLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn withLabel(&self) -> bool {
    self._tab.get::<bool>(GroupConfig::VT_WITHLABEL, Some(false)).unwrap()
  }
  #[inline]
  pub fn label(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GroupConfig::VT_LABEL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn withPassword(&self) -> bool {
    self._tab.get::<bool>(GroupConfig::VT_WITHPASSWORD, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for GroupConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"slotNum", Self::VT_SLOTNUM, false)?
     .visit_field::<bool>(&"withLabel", Self::VT_WITHLABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"label", Self::VT_LABEL, false)?
     .visit_field::<bool>(&"withPassword", Self::VT_WITHPASSWORD, false)?
     .finish();
    Ok(())
  }
}
pub struct GroupConfigArgs<'a> {
    pub slotNum: u32,
    pub withLabel: bool,
    pub label: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub withPassword: bool,
}
impl<'a> Default for GroupConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        GroupConfigArgs {
            slotNum: 0,
            withLabel: false,
            label: None,
            withPassword: false,
        }
    }
}
pub struct GroupConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GroupConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_slotNum(&mut self, slotNum: u32) {
    self.fbb_.push_slot::<u32>(GroupConfig::VT_SLOTNUM, slotNum, 0);
  }
  #[inline]
  pub fn add_withLabel(&mut self, withLabel: bool) {
    self.fbb_.push_slot::<bool>(GroupConfig::VT_WITHLABEL, withLabel, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroupConfig::VT_LABEL, label);
  }
  #[inline]
  pub fn add_withPassword(&mut self, withPassword: bool) {
    self.fbb_.push_slot::<bool>(GroupConfig::VT_WITHPASSWORD, withPassword, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GroupConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GroupConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GroupConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for GroupConfig<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("GroupConfig");
      ds.field("slotNum", &self.slotNum());
      ds.field("withLabel", &self.withLabel());
      ds.field("label", &self.label());
      ds.field("withPassword", &self.withPassword());
      ds.finish()
  }
}
pub enum UserInfo2Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UserInfo2<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UserInfo2<'a> {
    type Inner = UserInfo2<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UserInfo2<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UserInfo2 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UserInfo2Args<'args>) -> flatbuffers::WIPOffset<UserInfo2<'bldr>> {
      let mut builder = UserInfo2Builder::new(_fbb);
      if let Some(x) = args.avatarUrl { builder.add_avatarUrl(x); }
      if let Some(x) = args.onlineName { builder.add_onlineName(x); }
      if let Some(x) = args.npId { builder.add_npId(x); }
      builder.finish()
    }

    pub const VT_NPID: flatbuffers::VOffsetT = 4;
    pub const VT_ONLINENAME: flatbuffers::VOffsetT = 6;
    pub const VT_AVATARURL: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn npId(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserInfo2::VT_NPID, None)
  }
  #[inline]
  pub fn onlineName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserInfo2::VT_ONLINENAME, None)
  }
  #[inline]
  pub fn avatarUrl(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserInfo2::VT_AVATARURL, None)
  }
}

impl flatbuffers::Verifiable for UserInfo2<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"npId", Self::VT_NPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"onlineName", Self::VT_ONLINENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"avatarUrl", Self::VT_AVATARURL, false)?
     .finish();
    Ok(())
  }
}
pub struct UserInfo2Args<'a> {
    pub npId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onlineName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatarUrl: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UserInfo2Args<'a> {
    #[inline]
    fn default() -> Self {
        UserInfo2Args {
            npId: None,
            onlineName: None,
            avatarUrl: None,
        }
    }
}
pub struct UserInfo2Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UserInfo2Builder<'a, 'b> {
  #[inline]
  pub fn add_npId(&mut self, npId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInfo2::VT_NPID, npId);
  }
  #[inline]
  pub fn add_onlineName(&mut self, onlineName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInfo2::VT_ONLINENAME, onlineName);
  }
  #[inline]
  pub fn add_avatarUrl(&mut self, avatarUrl: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInfo2::VT_AVATARURL, avatarUrl);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UserInfo2Builder<'a, 'b> {
    let start = _fbb.start_table();
    UserInfo2Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UserInfo2<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UserInfo2<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UserInfo2");
      ds.field("npId", &self.npId());
      ds.field("onlineName", &self.onlineName());
      ds.field("avatarUrl", &self.avatarUrl());
      ds.finish()
  }
}
pub enum RoomMemberDataInternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomMemberDataInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMemberDataInternal<'a> {
    type Inner = RoomMemberDataInternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RoomMemberDataInternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomMemberDataInternal { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomMemberDataInternalArgs<'args>) -> flatbuffers::WIPOffset<RoomMemberDataInternal<'bldr>> {
      let mut builder = RoomMemberDataInternalBuilder::new(_fbb);
      builder.add_joinDate(args.joinDate);
      if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
      builder.add_flagAttr(args.flagAttr);
      if let Some(x) = args.userInfo { builder.add_userInfo(x); }
      builder.add_memberId(args.memberId);
      builder.add_natType(args.natType);
      builder.add_roomGroup(args.roomGroup);
      builder.add_teamId(args.teamId);
      builder.finish()
    }

    pub const VT_USERINFO: flatbuffers::VOffsetT = 4;
    pub const VT_JOINDATE: flatbuffers::VOffsetT = 6;
    pub const VT_MEMBERID: flatbuffers::VOffsetT = 8;
    pub const VT_TEAMID: flatbuffers::VOffsetT = 10;
    pub const VT_ROOMGROUP: flatbuffers::VOffsetT = 12;
    pub const VT_NATTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 16;
    pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn userInfo(&self) -> Option<UserInfo2<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo2>>(RoomMemberDataInternal::VT_USERINFO, None)
  }
  #[inline]
  pub fn joinDate(&self) -> u64 {
    self._tab.get::<u64>(RoomMemberDataInternal::VT_JOINDATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn memberId(&self) -> u16 {
    self._tab.get::<u16>(RoomMemberDataInternal::VT_MEMBERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    self._tab.get::<u8>(RoomMemberDataInternal::VT_TEAMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomGroup(&self) -> u8 {
    self._tab.get::<u8>(RoomMemberDataInternal::VT_ROOMGROUP, Some(0)).unwrap()
  }
  #[inline]
  pub fn natType(&self) -> u8 {
    self._tab.get::<u8>(RoomMemberDataInternal::VT_NATTYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomMemberDataInternal::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MemberBinAttrInternal>>>>(RoomMemberDataInternal::VT_ROOMMEMBERBINATTRINTERNAL, None)
  }
}

impl flatbuffers::Verifiable for RoomMemberDataInternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<UserInfo2>>(&"userInfo", Self::VT_USERINFO, false)?
     .visit_field::<u64>(&"joinDate", Self::VT_JOINDATE, false)?
     .visit_field::<u16>(&"memberId", Self::VT_MEMBERID, false)?
     .visit_field::<u8>(&"teamId", Self::VT_TEAMID, false)?
     .visit_field::<u8>(&"roomGroup", Self::VT_ROOMGROUP, false)?
     .visit_field::<u8>(&"natType", Self::VT_NATTYPE, false)?
     .visit_field::<u32>(&"flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MemberBinAttrInternal>>>>(&"roomMemberBinAttrInternal", Self::VT_ROOMMEMBERBINATTRINTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomMemberDataInternalArgs<'a> {
    pub userInfo: Option<flatbuffers::WIPOffset<UserInfo2<'a>>>,
    pub joinDate: u64,
    pub memberId: u16,
    pub teamId: u8,
    pub roomGroup: u8,
    pub natType: u8,
    pub flagAttr: u32,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'a>>>>>,
}
impl<'a> Default for RoomMemberDataInternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomMemberDataInternalArgs {
            userInfo: None,
            joinDate: 0,
            memberId: 0,
            teamId: 0,
            roomGroup: 0,
            natType: 0,
            flagAttr: 0,
            roomMemberBinAttrInternal: None,
        }
    }
}
pub struct RoomMemberDataInternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomMemberDataInternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_userInfo(&mut self, userInfo: flatbuffers::WIPOffset<UserInfo2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo2>>(RoomMemberDataInternal::VT_USERINFO, userInfo);
  }
  #[inline]
  pub fn add_joinDate(&mut self, joinDate: u64) {
    self.fbb_.push_slot::<u64>(RoomMemberDataInternal::VT_JOINDATE, joinDate, 0);
  }
  #[inline]
  pub fn add_memberId(&mut self, memberId: u16) {
    self.fbb_.push_slot::<u16>(RoomMemberDataInternal::VT_MEMBERID, memberId, 0);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternal::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn add_roomGroup(&mut self, roomGroup: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternal::VT_ROOMGROUP, roomGroup, 0);
  }
  #[inline]
  pub fn add_natType(&mut self, natType: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternal::VT_NATTYPE, natType, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomMemberDataInternal::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMemberDataInternal::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomMemberDataInternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomMemberDataInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMemberDataInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RoomMemberDataInternal<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RoomMemberDataInternal");
      ds.field("userInfo", &self.userInfo());
      ds.field("joinDate", &self.joinDate());
      ds.field("memberId", &self.memberId());
      ds.field("teamId", &self.teamId());
      ds.field("roomGroup", &self.roomGroup());
      ds.field("natType", &self.natType());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomMemberBinAttrInternal", &self.roomMemberBinAttrInternal());
      ds.finish()
  }
}
pub enum RoomGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomGroup<'a> {
    type Inner = RoomGroup<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RoomGroup<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomGroupArgs<'args>) -> flatbuffers::WIPOffset<RoomGroup<'bldr>> {
      let mut builder = RoomGroupBuilder::new(_fbb);
      builder.add_curGroupMemberNum(args.curGroupMemberNum);
      builder.add_slotNum(args.slotNum);
      if let Some(x) = args.label { builder.add_label(x); }
      builder.add_withLabel(args.withLabel);
      builder.add_withPassword(args.withPassword);
      builder.add_groupId(args.groupId);
      builder.finish()
    }

    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_WITHPASSWORD: flatbuffers::VOffsetT = 6;
    pub const VT_WITHLABEL: flatbuffers::VOffsetT = 8;
    pub const VT_LABEL: flatbuffers::VOffsetT = 10;
    pub const VT_SLOTNUM: flatbuffers::VOffsetT = 12;
    pub const VT_CURGROUPMEMBERNUM: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn groupId(&self) -> u8 {
    self._tab.get::<u8>(RoomGroup::VT_GROUPID, Some(0)).unwrap()
  }
  #[inline]
  pub fn withPassword(&self) -> bool {
    self._tab.get::<bool>(RoomGroup::VT_WITHPASSWORD, Some(false)).unwrap()
  }
  #[inline]
  pub fn withLabel(&self) -> bool {
    self._tab.get::<bool>(RoomGroup::VT_WITHLABEL, Some(false)).unwrap()
  }
  #[inline]
  pub fn label(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomGroup::VT_LABEL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn slotNum(&self) -> u32 {
    self._tab.get::<u32>(RoomGroup::VT_SLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn curGroupMemberNum(&self) -> u32 {
    self._tab.get::<u32>(RoomGroup::VT_CURGROUPMEMBERNUM, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for RoomGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>(&"groupId", Self::VT_GROUPID, false)?
     .visit_field::<bool>(&"withPassword", Self::VT_WITHPASSWORD, false)?
     .visit_field::<bool>(&"withLabel", Self::VT_WITHLABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"label", Self::VT_LABEL, false)?
     .visit_field::<u32>(&"slotNum", Self::VT_SLOTNUM, false)?
     .visit_field::<u32>(&"curGroupMemberNum", Self::VT_CURGROUPMEMBERNUM, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomGroupArgs<'a> {
    pub groupId: u8,
    pub withPassword: bool,
    pub withLabel: bool,
    pub label: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub slotNum: u32,
    pub curGroupMemberNum: u32,
}
impl<'a> Default for RoomGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomGroupArgs {
            groupId: 0,
            withPassword: false,
            withLabel: false,
            label: None,
            slotNum: 0,
            curGroupMemberNum: 0,
        }
    }
}
pub struct RoomGroupBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomGroupBuilder<'a, 'b> {
  #[inline]
  pub fn add_groupId(&mut self, groupId: u8) {
    self.fbb_.push_slot::<u8>(RoomGroup::VT_GROUPID, groupId, 0);
  }
  #[inline]
  pub fn add_withPassword(&mut self, withPassword: bool) {
    self.fbb_.push_slot::<bool>(RoomGroup::VT_WITHPASSWORD, withPassword, false);
  }
  #[inline]
  pub fn add_withLabel(&mut self, withLabel: bool) {
    self.fbb_.push_slot::<bool>(RoomGroup::VT_WITHLABEL, withLabel, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomGroup::VT_LABEL, label);
  }
  #[inline]
  pub fn add_slotNum(&mut self, slotNum: u32) {
    self.fbb_.push_slot::<u32>(RoomGroup::VT_SLOTNUM, slotNum, 0);
  }
  #[inline]
  pub fn add_curGroupMemberNum(&mut self, curGroupMemberNum: u32) {
    self.fbb_.push_slot::<u32>(RoomGroup::VT_CURGROUPMEMBERNUM, curGroupMemberNum, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomGroupBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RoomGroup<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RoomGroup");
      ds.field("groupId", &self.groupId());
      ds.field("withPassword", &self.withPassword());
      ds.field("withLabel", &self.withLabel());
      ds.field("label", &self.label());
      ds.field("slotNum", &self.slotNum());
      ds.field("curGroupMemberNum", &self.curGroupMemberNum());
      ds.finish()
  }
}
pub enum RoomDataInternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomDataInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomDataInternal<'a> {
    type Inner = RoomDataInternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RoomDataInternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomDataInternal { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomDataInternalArgs<'args>) -> flatbuffers::WIPOffset<RoomDataInternal<'bldr>> {
      let mut builder = RoomDataInternalBuilder::new(_fbb);
      builder.add_passwordSlotMask(args.passwordSlotMask);
      builder.add_roomId(args.roomId);
      builder.add_lobbyId(args.lobbyId);
      if let Some(x) = args.roomBinAttrInternal { builder.add_roomBinAttrInternal(x); }
      builder.add_flagAttr(args.flagAttr);
      if let Some(x) = args.roomGroup { builder.add_roomGroup(x); }
      if let Some(x) = args.memberList { builder.add_memberList(x); }
      builder.add_maxSlot(args.maxSlot);
      builder.add_worldId(args.worldId);
      builder.add_ownerId(args.ownerId);
      builder.add_serverId(args.serverId);
      builder.finish()
    }

    pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
    pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
    pub const VT_LOBBYID: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMID: flatbuffers::VOffsetT = 10;
    pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 12;
    pub const VT_MAXSLOT: flatbuffers::VOffsetT = 14;
    pub const VT_MEMBERLIST: flatbuffers::VOffsetT = 16;
    pub const VT_OWNERID: flatbuffers::VOffsetT = 18;
    pub const VT_ROOMGROUP: flatbuffers::VOffsetT = 20;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 22;
    pub const VT_ROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 24;

  #[inline]
  pub fn serverId(&self) -> u16 {
    self._tab.get::<u16>(RoomDataInternal::VT_SERVERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(RoomDataInternal::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    self._tab.get::<u64>(RoomDataInternal::VT_LOBBYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(RoomDataInternal::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(RoomDataInternal::VT_PASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn maxSlot(&self) -> u32 {
    self._tab.get::<u32>(RoomDataInternal::VT_MAXSLOT, Some(0)).unwrap()
  }
  #[inline]
  pub fn memberList(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>>>(RoomDataInternal::VT_MEMBERLIST, None)
  }
  #[inline]
  pub fn ownerId(&self) -> u16 {
    self._tab.get::<u16>(RoomDataInternal::VT_OWNERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomGroup(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup>>>>(RoomDataInternal::VT_ROOMGROUP, None)
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomDataInternal::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttrInternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttrInternal>>>>(RoomDataInternal::VT_ROOMBINATTRINTERNAL, None)
  }
}

impl flatbuffers::Verifiable for RoomDataInternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"serverId", Self::VT_SERVERID, false)?
     .visit_field::<u32>(&"worldId", Self::VT_WORLDID, false)?
     .visit_field::<u64>(&"lobbyId", Self::VT_LOBBYID, false)?
     .visit_field::<u64>(&"roomId", Self::VT_ROOMID, false)?
     .visit_field::<u64>(&"passwordSlotMask", Self::VT_PASSWORDSLOTMASK, false)?
     .visit_field::<u32>(&"maxSlot", Self::VT_MAXSLOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>>>(&"memberList", Self::VT_MEMBERLIST, false)?
     .visit_field::<u16>(&"ownerId", Self::VT_OWNERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomGroup>>>>(&"roomGroup", Self::VT_ROOMGROUP, false)?
     .visit_field::<u32>(&"flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttrInternal>>>>(&"roomBinAttrInternal", Self::VT_ROOMBINATTRINTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomDataInternalArgs<'a> {
    pub serverId: u16,
    pub worldId: u32,
    pub lobbyId: u64,
    pub roomId: u64,
    pub passwordSlotMask: u64,
    pub maxSlot: u32,
    pub memberList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'a>>>>>,
    pub ownerId: u16,
    pub roomGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>>>,
    pub flagAttr: u32,
    pub roomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttrInternal<'a>>>>>,
}
impl<'a> Default for RoomDataInternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomDataInternalArgs {
            serverId: 0,
            worldId: 0,
            lobbyId: 0,
            roomId: 0,
            passwordSlotMask: 0,
            maxSlot: 0,
            memberList: None,
            ownerId: 0,
            roomGroup: None,
            flagAttr: 0,
            roomBinAttrInternal: None,
        }
    }
}
pub struct RoomDataInternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomDataInternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(RoomDataInternal::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternal::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternal::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternal::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternal::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_maxSlot(&mut self, maxSlot: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternal::VT_MAXSLOT, maxSlot, 0);
  }
  #[inline]
  pub fn add_memberList(&mut self, memberList: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternal::VT_MEMBERLIST, memberList);
  }
  #[inline]
  pub fn add_ownerId(&mut self, ownerId: u16) {
    self.fbb_.push_slot::<u16>(RoomDataInternal::VT_OWNERID, ownerId, 0);
  }
  #[inline]
  pub fn add_roomGroup(&mut self, roomGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternal::VT_ROOMGROUP, roomGroup);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternal::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomBinAttrInternal(&mut self, roomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttrInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternal::VT_ROOMBINATTRINTERNAL, roomBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomDataInternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomDataInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomDataInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RoomDataInternal<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RoomDataInternal");
      ds.field("serverId", &self.serverId());
      ds.field("worldId", &self.worldId());
      ds.field("lobbyId", &self.lobbyId());
      ds.field("roomId", &self.roomId());
      ds.field("passwordSlotMask", &self.passwordSlotMask());
      ds.field("maxSlot", &self.maxSlot());
      ds.field("memberList", &self.memberList());
      ds.field("ownerId", &self.ownerId());
      ds.field("roomGroup", &self.roomGroup());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomBinAttrInternal", &self.roomBinAttrInternal());
      ds.finish()
  }
}
pub enum RoomDataExternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomDataExternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomDataExternal<'a> {
    type Inner = RoomDataExternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RoomDataExternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomDataExternal { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomDataExternalArgs<'args>) -> flatbuffers::WIPOffset<RoomDataExternal<'bldr>> {
      let mut builder = RoomDataExternalBuilder::new(_fbb);
      builder.add_passwordSlotMask(args.passwordSlotMask);
      builder.add_roomId(args.roomId);
      builder.add_lobbyId(args.lobbyId);
      if let Some(x) = args.roomBinAttrExternal { builder.add_roomBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableBinAttrExternal { builder.add_roomSearchableBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableIntAttrExternal { builder.add_roomSearchableIntAttrExternal(x); }
      builder.add_flagAttr(args.flagAttr);
      if let Some(x) = args.roomGroup { builder.add_roomGroup(x); }
      if let Some(x) = args.owner { builder.add_owner(x); }
      builder.add_worldId(args.worldId);
      builder.add_curMemberNum(args.curMemberNum);
      builder.add_openPrivateSlotNum(args.openPrivateSlotNum);
      builder.add_maxSlot(args.maxSlot);
      builder.add_openPublicSlotNum(args.openPublicSlotNum);
      builder.add_privateSlotNum(args.privateSlotNum);
      builder.add_publicSlotNum(args.publicSlotNum);
      builder.add_serverId(args.serverId);
      builder.finish()
    }

    pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
    pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
    pub const VT_PUBLICSLOTNUM: flatbuffers::VOffsetT = 8;
    pub const VT_PRIVATESLOTNUM: flatbuffers::VOffsetT = 10;
    pub const VT_LOBBYID: flatbuffers::VOffsetT = 12;
    pub const VT_ROOMID: flatbuffers::VOffsetT = 14;
    pub const VT_OPENPUBLICSLOTNUM: flatbuffers::VOffsetT = 16;
    pub const VT_MAXSLOT: flatbuffers::VOffsetT = 18;
    pub const VT_OPENPRIVATESLOTNUM: flatbuffers::VOffsetT = 20;
    pub const VT_CURMEMBERNUM: flatbuffers::VOffsetT = 22;
    pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 24;
    pub const VT_OWNER: flatbuffers::VOffsetT = 26;
    pub const VT_ROOMGROUP: flatbuffers::VOffsetT = 28;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 30;
    pub const VT_ROOMSEARCHABLEINTATTREXTERNAL: flatbuffers::VOffsetT = 32;
    pub const VT_ROOMSEARCHABLEBINATTREXTERNAL: flatbuffers::VOffsetT = 34;
    pub const VT_ROOMBINATTREXTERNAL: flatbuffers::VOffsetT = 36;

  #[inline]
  pub fn serverId(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_SERVERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(RoomDataExternal::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn publicSlotNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_PUBLICSLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn privateSlotNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_PRIVATESLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    self._tab.get::<u64>(RoomDataExternal::VT_LOBBYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(RoomDataExternal::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn openPublicSlotNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_OPENPUBLICSLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn maxSlot(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_MAXSLOT, Some(0)).unwrap()
  }
  #[inline]
  pub fn openPrivateSlotNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_OPENPRIVATESLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn curMemberNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_CURMEMBERNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(RoomDataExternal::VT_PASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn owner(&self) -> Option<UserInfo2<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo2>>(RoomDataExternal::VT_OWNER, None)
  }
  #[inline]
  pub fn roomGroup(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup>>>>(RoomDataExternal::VT_ROOMGROUP, None)
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomDataExternal::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomSearchableIntAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr>>>>(RoomDataExternal::VT_ROOMSEARCHABLEINTATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomSearchableBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(RoomDataExternal::VT_ROOMSEARCHABLEBINATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(RoomDataExternal::VT_ROOMBINATTREXTERNAL, None)
  }
}

impl flatbuffers::Verifiable for RoomDataExternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"serverId", Self::VT_SERVERID, false)?
     .visit_field::<u32>(&"worldId", Self::VT_WORLDID, false)?
     .visit_field::<u16>(&"publicSlotNum", Self::VT_PUBLICSLOTNUM, false)?
     .visit_field::<u16>(&"privateSlotNum", Self::VT_PRIVATESLOTNUM, false)?
     .visit_field::<u64>(&"lobbyId", Self::VT_LOBBYID, false)?
     .visit_field::<u64>(&"roomId", Self::VT_ROOMID, false)?
     .visit_field::<u16>(&"openPublicSlotNum", Self::VT_OPENPUBLICSLOTNUM, false)?
     .visit_field::<u16>(&"maxSlot", Self::VT_MAXSLOT, false)?
     .visit_field::<u16>(&"openPrivateSlotNum", Self::VT_OPENPRIVATESLOTNUM, false)?
     .visit_field::<u16>(&"curMemberNum", Self::VT_CURMEMBERNUM, false)?
     .visit_field::<u64>(&"passwordSlotMask", Self::VT_PASSWORDSLOTMASK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<UserInfo2>>(&"owner", Self::VT_OWNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomGroup>>>>(&"roomGroup", Self::VT_ROOMGROUP, false)?
     .visit_field::<u32>(&"flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntAttr>>>>(&"roomSearchableIntAttrExternal", Self::VT_ROOMSEARCHABLEINTATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomSearchableBinAttrExternal", Self::VT_ROOMSEARCHABLEBINATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomBinAttrExternal", Self::VT_ROOMBINATTREXTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomDataExternalArgs<'a> {
    pub serverId: u16,
    pub worldId: u32,
    pub publicSlotNum: u16,
    pub privateSlotNum: u16,
    pub lobbyId: u64,
    pub roomId: u64,
    pub openPublicSlotNum: u16,
    pub maxSlot: u16,
    pub openPrivateSlotNum: u16,
    pub curMemberNum: u16,
    pub passwordSlotMask: u64,
    pub owner: Option<flatbuffers::WIPOffset<UserInfo2<'a>>>,
    pub roomGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>>>,
    pub flagAttr: u32,
    pub roomSearchableIntAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>>>,
    pub roomSearchableBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
}
impl<'a> Default for RoomDataExternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomDataExternalArgs {
            serverId: 0,
            worldId: 0,
            publicSlotNum: 0,
            privateSlotNum: 0,
            lobbyId: 0,
            roomId: 0,
            openPublicSlotNum: 0,
            maxSlot: 0,
            openPrivateSlotNum: 0,
            curMemberNum: 0,
            passwordSlotMask: 0,
            owner: None,
            roomGroup: None,
            flagAttr: 0,
            roomSearchableIntAttrExternal: None,
            roomSearchableBinAttrExternal: None,
            roomBinAttrExternal: None,
        }
    }
}
pub struct RoomDataExternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomDataExternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(RoomDataExternal::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_publicSlotNum(&mut self, publicSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_PUBLICSLOTNUM, publicSlotNum, 0);
  }
  #[inline]
  pub fn add_privateSlotNum(&mut self, privateSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_PRIVATESLOTNUM, privateSlotNum, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataExternal::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataExternal::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_openPublicSlotNum(&mut self, openPublicSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_OPENPUBLICSLOTNUM, openPublicSlotNum, 0);
  }
  #[inline]
  pub fn add_maxSlot(&mut self, maxSlot: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_MAXSLOT, maxSlot, 0);
  }
  #[inline]
  pub fn add_openPrivateSlotNum(&mut self, openPrivateSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_OPENPRIVATESLOTNUM, openPrivateSlotNum, 0);
  }
  #[inline]
  pub fn add_curMemberNum(&mut self, curMemberNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_CURMEMBERNUM, curMemberNum, 0);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(RoomDataExternal::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_owner(&mut self, owner: flatbuffers::WIPOffset<UserInfo2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo2>>(RoomDataExternal::VT_OWNER, owner);
  }
  #[inline]
  pub fn add_roomGroup(&mut self, roomGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMGROUP, roomGroup);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomDataExternal::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomSearchableIntAttrExternal(&mut self, roomSearchableIntAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMSEARCHABLEINTATTREXTERNAL, roomSearchableIntAttrExternal);
  }
  #[inline]
  pub fn add_roomSearchableBinAttrExternal(&mut self, roomSearchableBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMSEARCHABLEBINATTREXTERNAL, roomSearchableBinAttrExternal);
  }
  #[inline]
  pub fn add_roomBinAttrExternal(&mut self, roomBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMBINATTREXTERNAL, roomBinAttrExternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomDataExternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomDataExternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomDataExternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RoomDataExternal<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RoomDataExternal");
      ds.field("serverId", &self.serverId());
      ds.field("worldId", &self.worldId());
      ds.field("publicSlotNum", &self.publicSlotNum());
      ds.field("privateSlotNum", &self.privateSlotNum());
      ds.field("lobbyId", &self.lobbyId());
      ds.field("roomId", &self.roomId());
      ds.field("openPublicSlotNum", &self.openPublicSlotNum());
      ds.field("maxSlot", &self.maxSlot());
      ds.field("openPrivateSlotNum", &self.openPrivateSlotNum());
      ds.field("curMemberNum", &self.curMemberNum());
      ds.field("passwordSlotMask", &self.passwordSlotMask());
      ds.field("owner", &self.owner());
      ds.field("roomGroup", &self.roomGroup());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomSearchableIntAttrExternal", &self.roomSearchableIntAttrExternal());
      ds.field("roomSearchableBinAttrExternal", &self.roomSearchableBinAttrExternal());
      ds.field("roomBinAttrExternal", &self.roomBinAttrExternal());
      ds.finish()
  }
}
pub enum IntSearchFilterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntSearchFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntSearchFilter<'a> {
    type Inner = IntSearchFilter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> IntSearchFilter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntSearchFilter { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IntSearchFilterArgs<'args>) -> flatbuffers::WIPOffset<IntSearchFilter<'bldr>> {
      let mut builder = IntSearchFilterBuilder::new(_fbb);
      if let Some(x) = args.attr { builder.add_attr(x); }
      builder.add_searchOperator(args.searchOperator);
      builder.finish()
    }

    pub const VT_SEARCHOPERATOR: flatbuffers::VOffsetT = 4;
    pub const VT_ATTR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn searchOperator(&self) -> u8 {
    self._tab.get::<u8>(IntSearchFilter::VT_SEARCHOPERATOR, Some(0)).unwrap()
  }
  #[inline]
  pub fn attr(&self) -> Option<IntAttr<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IntAttr>>(IntSearchFilter::VT_ATTR, None)
  }
}

impl flatbuffers::Verifiable for IntSearchFilter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>(&"searchOperator", Self::VT_SEARCHOPERATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntAttr>>(&"attr", Self::VT_ATTR, false)?
     .finish();
    Ok(())
  }
}
pub struct IntSearchFilterArgs<'a> {
    pub searchOperator: u8,
    pub attr: Option<flatbuffers::WIPOffset<IntAttr<'a>>>,
}
impl<'a> Default for IntSearchFilterArgs<'a> {
    #[inline]
    fn default() -> Self {
        IntSearchFilterArgs {
            searchOperator: 0,
            attr: None,
        }
    }
}
pub struct IntSearchFilterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntSearchFilterBuilder<'a, 'b> {
  #[inline]
  pub fn add_searchOperator(&mut self, searchOperator: u8) {
    self.fbb_.push_slot::<u8>(IntSearchFilter::VT_SEARCHOPERATOR, searchOperator, 0);
  }
  #[inline]
  pub fn add_attr(&mut self, attr: flatbuffers::WIPOffset<IntAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntAttr>>(IntSearchFilter::VT_ATTR, attr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntSearchFilterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IntSearchFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntSearchFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for IntSearchFilter<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("IntSearchFilter");
      ds.field("searchOperator", &self.searchOperator());
      ds.field("attr", &self.attr());
      ds.finish()
  }
}
pub enum BinSearchFilterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinSearchFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinSearchFilter<'a> {
    type Inner = BinSearchFilter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> BinSearchFilter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BinSearchFilter { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BinSearchFilterArgs<'args>) -> flatbuffers::WIPOffset<BinSearchFilter<'bldr>> {
      let mut builder = BinSearchFilterBuilder::new(_fbb);
      if let Some(x) = args.attr { builder.add_attr(x); }
      builder.add_searchOperator(args.searchOperator);
      builder.finish()
    }

    pub const VT_SEARCHOPERATOR: flatbuffers::VOffsetT = 4;
    pub const VT_ATTR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn searchOperator(&self) -> u8 {
    self._tab.get::<u8>(BinSearchFilter::VT_SEARCHOPERATOR, Some(0)).unwrap()
  }
  #[inline]
  pub fn attr(&self) -> Option<BinAttr<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BinAttr>>(BinSearchFilter::VT_ATTR, None)
  }
}

impl flatbuffers::Verifiable for BinSearchFilter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>(&"searchOperator", Self::VT_SEARCHOPERATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinAttr>>(&"attr", Self::VT_ATTR, false)?
     .finish();
    Ok(())
  }
}
pub struct BinSearchFilterArgs<'a> {
    pub searchOperator: u8,
    pub attr: Option<flatbuffers::WIPOffset<BinAttr<'a>>>,
}
impl<'a> Default for BinSearchFilterArgs<'a> {
    #[inline]
    fn default() -> Self {
        BinSearchFilterArgs {
            searchOperator: 0,
            attr: None,
        }
    }
}
pub struct BinSearchFilterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BinSearchFilterBuilder<'a, 'b> {
  #[inline]
  pub fn add_searchOperator(&mut self, searchOperator: u8) {
    self.fbb_.push_slot::<u8>(BinSearchFilter::VT_SEARCHOPERATOR, searchOperator, 0);
  }
  #[inline]
  pub fn add_attr(&mut self, attr: flatbuffers::WIPOffset<BinAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinAttr>>(BinSearchFilter::VT_ATTR, attr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinSearchFilterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BinSearchFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinSearchFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for BinSearchFilter<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("BinSearchFilter");
      ds.field("searchOperator", &self.searchOperator());
      ds.field("attr", &self.attr());
      ds.finish()
  }
}
pub enum PresenceOptionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PresenceOptionData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PresenceOptionData<'a> {
    type Inner = PresenceOptionData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> PresenceOptionData<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PresenceOptionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PresenceOptionDataArgs<'args>) -> flatbuffers::WIPOffset<PresenceOptionData<'bldr>> {
      let mut builder = PresenceOptionDataBuilder::new(_fbb);
      builder.add_len(args.len);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;
    pub const VT_LEN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PresenceOptionData::VT_DATA, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn len(&self) -> u32 {
    self._tab.get::<u32>(PresenceOptionData::VT_LEN, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for PresenceOptionData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"data", Self::VT_DATA, false)?
     .visit_field::<u32>(&"len", Self::VT_LEN, false)?
     .finish();
    Ok(())
  }
}
pub struct PresenceOptionDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub len: u32,
}
impl<'a> Default for PresenceOptionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        PresenceOptionDataArgs {
            data: None,
            len: 0,
        }
    }
}
pub struct PresenceOptionDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PresenceOptionDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PresenceOptionData::VT_DATA, data);
  }
  #[inline]
  pub fn add_len(&mut self, len: u32) {
    self.fbb_.push_slot::<u32>(PresenceOptionData::VT_LEN, len, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PresenceOptionDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PresenceOptionDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PresenceOptionData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for PresenceOptionData<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("PresenceOptionData");
      ds.field("data", &self.data());
      ds.field("len", &self.len());
      ds.finish()
  }
}
pub enum RoomGroupPasswordConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomGroupPasswordConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomGroupPasswordConfig<'a> {
    type Inner = RoomGroupPasswordConfig<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RoomGroupPasswordConfig<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomGroupPasswordConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomGroupPasswordConfigArgs<'args>) -> flatbuffers::WIPOffset<RoomGroupPasswordConfig<'bldr>> {
      let mut builder = RoomGroupPasswordConfigBuilder::new(_fbb);
      if let Some(x) = args.groupId { builder.add_groupId(x); }
      builder.add_withPassword(args.withPassword);
      builder.finish()
    }

    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_WITHPASSWORD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn groupId(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomGroupPasswordConfig::VT_GROUPID, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn withPassword(&self) -> bool {
    self._tab.get::<bool>(RoomGroupPasswordConfig::VT_WITHPASSWORD, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for RoomGroupPasswordConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"groupId", Self::VT_GROUPID, false)?
     .visit_field::<bool>(&"withPassword", Self::VT_WITHPASSWORD, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomGroupPasswordConfigArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub withPassword: bool,
}
impl<'a> Default for RoomGroupPasswordConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomGroupPasswordConfigArgs {
            groupId: None,
            withPassword: false,
        }
    }
}
pub struct RoomGroupPasswordConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomGroupPasswordConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomGroupPasswordConfig::VT_GROUPID, groupId);
  }
  #[inline]
  pub fn add_withPassword(&mut self, withPassword: bool) {
    self.fbb_.push_slot::<bool>(RoomGroupPasswordConfig::VT_WITHPASSWORD, withPassword, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomGroupPasswordConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomGroupPasswordConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomGroupPasswordConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RoomGroupPasswordConfig<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RoomGroupPasswordConfig");
      ds.field("groupId", &self.groupId());
      ds.field("withPassword", &self.withPassword());
      ds.finish()
  }
}
pub enum SearchRoomRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SearchRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SearchRoomRequest<'a> {
    type Inner = SearchRoomRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SearchRoomRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SearchRoomRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SearchRoomRequestArgs<'args>) -> flatbuffers::WIPOffset<SearchRoomRequest<'bldr>> {
      let mut builder = SearchRoomRequestBuilder::new(_fbb);
      builder.add_lobbyId(args.lobbyId);
      if let Some(x) = args.attrId { builder.add_attrId(x); }
      if let Some(x) = args.binFilter { builder.add_binFilter(x); }
      if let Some(x) = args.intFilter { builder.add_intFilter(x); }
      builder.add_flagAttr(args.flagAttr);
      builder.add_flagFilter(args.flagFilter);
      builder.add_rangeFilter_max(args.rangeFilter_max);
      builder.add_rangeFilter_startIndex(args.rangeFilter_startIndex);
      builder.add_worldId(args.worldId);
      builder.add_option(args.option);
      builder.finish()
    }

    pub const VT_OPTION: flatbuffers::VOffsetT = 4;
    pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
    pub const VT_LOBBYID: flatbuffers::VOffsetT = 8;
    pub const VT_RANGEFILTER_STARTINDEX: flatbuffers::VOffsetT = 10;
    pub const VT_RANGEFILTER_MAX: flatbuffers::VOffsetT = 12;
    pub const VT_FLAGFILTER: flatbuffers::VOffsetT = 14;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 16;
    pub const VT_INTFILTER: flatbuffers::VOffsetT = 18;
    pub const VT_BINFILTER: flatbuffers::VOffsetT = 20;
    pub const VT_ATTRID: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn option(&self) -> i32 {
    self._tab.get::<i32>(SearchRoomRequest::VT_OPTION, Some(0)).unwrap()
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    self._tab.get::<u64>(SearchRoomRequest::VT_LOBBYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn rangeFilter_startIndex(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_RANGEFILTER_STARTINDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn rangeFilter_max(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_RANGEFILTER_MAX, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagFilter(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_FLAGFILTER, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn intFilter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntSearchFilter<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntSearchFilter>>>>(SearchRoomRequest::VT_INTFILTER, None)
  }
  #[inline]
  pub fn binFilter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinSearchFilter<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinSearchFilter>>>>(SearchRoomRequest::VT_BINFILTER, None)
  }
  #[inline]
  pub fn attrId(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SearchRoomRequest::VT_ATTRID, None)
  }
}

impl flatbuffers::Verifiable for SearchRoomRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>(&"option", Self::VT_OPTION, false)?
     .visit_field::<u32>(&"worldId", Self::VT_WORLDID, false)?
     .visit_field::<u64>(&"lobbyId", Self::VT_LOBBYID, false)?
     .visit_field::<u32>(&"rangeFilter_startIndex", Self::VT_RANGEFILTER_STARTINDEX, false)?
     .visit_field::<u32>(&"rangeFilter_max", Self::VT_RANGEFILTER_MAX, false)?
     .visit_field::<u32>(&"flagFilter", Self::VT_FLAGFILTER, false)?
     .visit_field::<u32>(&"flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntSearchFilter>>>>(&"intFilter", Self::VT_INTFILTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinSearchFilter>>>>(&"binFilter", Self::VT_BINFILTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"attrId", Self::VT_ATTRID, false)?
     .finish();
    Ok(())
  }
}
pub struct SearchRoomRequestArgs<'a> {
    pub option: i32,
    pub worldId: u32,
    pub lobbyId: u64,
    pub rangeFilter_startIndex: u32,
    pub rangeFilter_max: u32,
    pub flagFilter: u32,
    pub flagAttr: u32,
    pub intFilter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntSearchFilter<'a>>>>>,
    pub binFilter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinSearchFilter<'a>>>>>,
    pub attrId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for SearchRoomRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SearchRoomRequestArgs {
            option: 0,
            worldId: 0,
            lobbyId: 0,
            rangeFilter_startIndex: 0,
            rangeFilter_max: 0,
            flagFilter: 0,
            flagAttr: 0,
            intFilter: None,
            binFilter: None,
            attrId: None,
        }
    }
}
pub struct SearchRoomRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SearchRoomRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_option(&mut self, option: i32) {
    self.fbb_.push_slot::<i32>(SearchRoomRequest::VT_OPTION, option, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(SearchRoomRequest::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_rangeFilter_startIndex(&mut self, rangeFilter_startIndex: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_RANGEFILTER_STARTINDEX, rangeFilter_startIndex, 0);
  }
  #[inline]
  pub fn add_rangeFilter_max(&mut self, rangeFilter_max: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_RANGEFILTER_MAX, rangeFilter_max, 0);
  }
  #[inline]
  pub fn add_flagFilter(&mut self, flagFilter: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_FLAGFILTER, flagFilter, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_intFilter(&mut self, intFilter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntSearchFilter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomRequest::VT_INTFILTER, intFilter);
  }
  #[inline]
  pub fn add_binFilter(&mut self, binFilter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinSearchFilter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomRequest::VT_BINFILTER, binFilter);
  }
  #[inline]
  pub fn add_attrId(&mut self, attrId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomRequest::VT_ATTRID, attrId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SearchRoomRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SearchRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SearchRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SearchRoomRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SearchRoomRequest");
      ds.field("option", &self.option());
      ds.field("worldId", &self.worldId());
      ds.field("lobbyId", &self.lobbyId());
      ds.field("rangeFilter_startIndex", &self.rangeFilter_startIndex());
      ds.field("rangeFilter_max", &self.rangeFilter_max());
      ds.field("flagFilter", &self.flagFilter());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("intFilter", &self.intFilter());
      ds.field("binFilter", &self.binFilter());
      ds.field("attrId", &self.attrId());
      ds.finish()
  }
}
pub enum SearchRoomResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SearchRoomResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SearchRoomResponse<'a> {
    type Inner = SearchRoomResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SearchRoomResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SearchRoomResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SearchRoomResponseArgs<'args>) -> flatbuffers::WIPOffset<SearchRoomResponse<'bldr>> {
      let mut builder = SearchRoomResponseBuilder::new(_fbb);
      if let Some(x) = args.rooms { builder.add_rooms(x); }
      builder.add_size_(args.size_);
      builder.add_total(args.total);
      builder.add_startIndex(args.startIndex);
      builder.finish()
    }

    pub const VT_STARTINDEX: flatbuffers::VOffsetT = 4;
    pub const VT_TOTAL: flatbuffers::VOffsetT = 6;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn startIndex(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomResponse::VT_STARTINDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn total(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomResponse::VT_TOTAL, Some(0)).unwrap()
  }
  #[inline]
  pub fn size_(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomResponse::VT_SIZE_, Some(0)).unwrap()
  }
  #[inline]
  pub fn rooms(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal>>>>(SearchRoomResponse::VT_ROOMS, None)
  }
}

impl flatbuffers::Verifiable for SearchRoomResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"startIndex", Self::VT_STARTINDEX, false)?
     .visit_field::<u32>(&"total", Self::VT_TOTAL, false)?
     .visit_field::<u32>(&"size_", Self::VT_SIZE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomDataExternal>>>>(&"rooms", Self::VT_ROOMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SearchRoomResponseArgs<'a> {
    pub startIndex: u32,
    pub total: u32,
    pub size_: u32,
    pub rooms: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal<'a>>>>>,
}
impl<'a> Default for SearchRoomResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        SearchRoomResponseArgs {
            startIndex: 0,
            total: 0,
            size_: 0,
            rooms: None,
        }
    }
}
pub struct SearchRoomResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SearchRoomResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_startIndex(&mut self, startIndex: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomResponse::VT_STARTINDEX, startIndex, 0);
  }
  #[inline]
  pub fn add_total(&mut self, total: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomResponse::VT_TOTAL, total, 0);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomResponse::VT_SIZE_, size_, 0);
  }
  #[inline]
  pub fn add_rooms(&mut self, rooms: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomDataExternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomResponse::VT_ROOMS, rooms);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SearchRoomResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SearchRoomResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SearchRoomResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SearchRoomResponse<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SearchRoomResponse");
      ds.field("startIndex", &self.startIndex());
      ds.field("total", &self.total());
      ds.field("size_", &self.size_());
      ds.field("rooms", &self.rooms());
      ds.finish()
  }
}
pub enum CreateJoinRoomRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateJoinRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateJoinRoomRequest<'a> {
    type Inner = CreateJoinRoomRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> CreateJoinRoomRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CreateJoinRoomRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CreateJoinRoomRequestArgs<'args>) -> flatbuffers::WIPOffset<CreateJoinRoomRequest<'bldr>> {
      let mut builder = CreateJoinRoomRequestBuilder::new(_fbb);
      builder.add_passwordSlotMask(args.passwordSlotMask);
      builder.add_lobbyId(args.lobbyId);
      if let Some(x) = args.sigOptParam { builder.add_sigOptParam(x); }
      if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
      if let Some(x) = args.joinRoomGroupLabel { builder.add_joinRoomGroupLabel(x); }
      if let Some(x) = args.blockedUser { builder.add_blockedUser(x); }
      if let Some(x) = args.allowedUser { builder.add_allowedUser(x); }
      if let Some(x) = args.groupConfig { builder.add_groupConfig(x); }
      if let Some(x) = args.roomPassword { builder.add_roomPassword(x); }
      if let Some(x) = args.roomBinAttrExternal { builder.add_roomBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableBinAttrExternal { builder.add_roomSearchableBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableIntAttrExternal { builder.add_roomSearchableIntAttrExternal(x); }
      if let Some(x) = args.roomBinAttrInternal { builder.add_roomBinAttrInternal(x); }
      builder.add_flagAttr(args.flagAttr);
      builder.add_maxSlot(args.maxSlot);
      builder.add_worldId(args.worldId);
      builder.add_teamId(args.teamId);
      builder.finish()
    }

    pub const VT_WORLDID: flatbuffers::VOffsetT = 4;
    pub const VT_LOBBYID: flatbuffers::VOffsetT = 6;
    pub const VT_MAXSLOT: flatbuffers::VOffsetT = 8;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 10;
    pub const VT_ROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 12;
    pub const VT_ROOMSEARCHABLEINTATTREXTERNAL: flatbuffers::VOffsetT = 14;
    pub const VT_ROOMSEARCHABLEBINATTREXTERNAL: flatbuffers::VOffsetT = 16;
    pub const VT_ROOMBINATTREXTERNAL: flatbuffers::VOffsetT = 18;
    pub const VT_ROOMPASSWORD: flatbuffers::VOffsetT = 20;
    pub const VT_GROUPCONFIG: flatbuffers::VOffsetT = 22;
    pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 24;
    pub const VT_ALLOWEDUSER: flatbuffers::VOffsetT = 26;
    pub const VT_BLOCKEDUSER: flatbuffers::VOffsetT = 28;
    pub const VT_JOINROOMGROUPLABEL: flatbuffers::VOffsetT = 30;
    pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 32;
    pub const VT_TEAMID: flatbuffers::VOffsetT = 34;
    pub const VT_SIGOPTPARAM: flatbuffers::VOffsetT = 36;

  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(CreateJoinRoomRequest::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    self._tab.get::<u64>(CreateJoinRoomRequest::VT_LOBBYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn maxSlot(&self) -> u32 {
    self._tab.get::<u32>(CreateJoinRoomRequest::VT_MAXSLOT, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(CreateJoinRoomRequest::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(CreateJoinRoomRequest::VT_ROOMBINATTRINTERNAL, None)
  }
  #[inline]
  pub fn roomSearchableIntAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr>>>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomSearchableBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(CreateJoinRoomRequest::VT_ROOMBINATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomPassword(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CreateJoinRoomRequest::VT_ROOMPASSWORD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn groupConfig(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GroupConfig<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GroupConfig>>>>(CreateJoinRoomRequest::VT_GROUPCONFIG, None)
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(CreateJoinRoomRequest::VT_PASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn allowedUser(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CreateJoinRoomRequest::VT_ALLOWEDUSER, None)
  }
  #[inline]
  pub fn blockedUser(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CreateJoinRoomRequest::VT_BLOCKEDUSER, None)
  }
  #[inline]
  pub fn joinRoomGroupLabel(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CreateJoinRoomRequest::VT_JOINROOMGROUPLABEL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(CreateJoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, None)
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    self._tab.get::<u8>(CreateJoinRoomRequest::VT_TEAMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn sigOptParam(&self) -> Option<OptParam<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<OptParam>>(CreateJoinRoomRequest::VT_SIGOPTPARAM, None)
  }
}

impl flatbuffers::Verifiable for CreateJoinRoomRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"worldId", Self::VT_WORLDID, false)?
     .visit_field::<u64>(&"lobbyId", Self::VT_LOBBYID, false)?
     .visit_field::<u32>(&"maxSlot", Self::VT_MAXSLOT, false)?
     .visit_field::<u32>(&"flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomBinAttrInternal", Self::VT_ROOMBINATTRINTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntAttr>>>>(&"roomSearchableIntAttrExternal", Self::VT_ROOMSEARCHABLEINTATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomSearchableBinAttrExternal", Self::VT_ROOMSEARCHABLEBINATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomBinAttrExternal", Self::VT_ROOMBINATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"roomPassword", Self::VT_ROOMPASSWORD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GroupConfig>>>>(&"groupConfig", Self::VT_GROUPCONFIG, false)?
     .visit_field::<u64>(&"passwordSlotMask", Self::VT_PASSWORDSLOTMASK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(&"allowedUser", Self::VT_ALLOWEDUSER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(&"blockedUser", Self::VT_BLOCKEDUSER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"joinRoomGroupLabel", Self::VT_JOINROOMGROUPLABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomMemberBinAttrInternal", Self::VT_ROOMMEMBERBINATTRINTERNAL, false)?
     .visit_field::<u8>(&"teamId", Self::VT_TEAMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<OptParam>>(&"sigOptParam", Self::VT_SIGOPTPARAM, false)?
     .finish();
    Ok(())
  }
}
pub struct CreateJoinRoomRequestArgs<'a> {
    pub worldId: u32,
    pub lobbyId: u64,
    pub maxSlot: u32,
    pub flagAttr: u32,
    pub roomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomSearchableIntAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>>>,
    pub roomSearchableBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomPassword: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub groupConfig: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GroupConfig<'a>>>>>,
    pub passwordSlotMask: u64,
    pub allowedUser: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub blockedUser: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub joinRoomGroupLabel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub teamId: u8,
    pub sigOptParam: Option<flatbuffers::WIPOffset<OptParam<'a>>>,
}
impl<'a> Default for CreateJoinRoomRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        CreateJoinRoomRequestArgs {
            worldId: 0,
            lobbyId: 0,
            maxSlot: 0,
            flagAttr: 0,
            roomBinAttrInternal: None,
            roomSearchableIntAttrExternal: None,
            roomSearchableBinAttrExternal: None,
            roomBinAttrExternal: None,
            roomPassword: None,
            groupConfig: None,
            passwordSlotMask: 0,
            allowedUser: None,
            blockedUser: None,
            joinRoomGroupLabel: None,
            roomMemberBinAttrInternal: None,
            teamId: 0,
            sigOptParam: None,
        }
    }
}
pub struct CreateJoinRoomRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CreateJoinRoomRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(CreateJoinRoomRequest::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(CreateJoinRoomRequest::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_maxSlot(&mut self, maxSlot: u32) {
    self.fbb_.push_slot::<u32>(CreateJoinRoomRequest::VT_MAXSLOT, maxSlot, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(CreateJoinRoomRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomBinAttrInternal(&mut self, roomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMBINATTRINTERNAL, roomBinAttrInternal);
  }
  #[inline]
  pub fn add_roomSearchableIntAttrExternal(&mut self, roomSearchableIntAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, roomSearchableIntAttrExternal);
  }
  #[inline]
  pub fn add_roomSearchableBinAttrExternal(&mut self, roomSearchableBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, roomSearchableBinAttrExternal);
  }
  #[inline]
  pub fn add_roomBinAttrExternal(&mut self, roomBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMBINATTREXTERNAL, roomBinAttrExternal);
  }
  #[inline]
  pub fn add_roomPassword(&mut self, roomPassword: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMPASSWORD, roomPassword);
  }
  #[inline]
  pub fn add_groupConfig(&mut self, groupConfig: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GroupConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_GROUPCONFIG, groupConfig);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(CreateJoinRoomRequest::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_allowedUser(&mut self, allowedUser: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ALLOWEDUSER, allowedUser);
  }
  #[inline]
  pub fn add_blockedUser(&mut self, blockedUser: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_BLOCKEDUSER, blockedUser);
  }
  #[inline]
  pub fn add_joinRoomGroupLabel(&mut self, joinRoomGroupLabel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_JOINROOMGROUPLABEL, joinRoomGroupLabel);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(CreateJoinRoomRequest::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn add_sigOptParam(&mut self, sigOptParam: flatbuffers::WIPOffset<OptParam<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<OptParam>>(CreateJoinRoomRequest::VT_SIGOPTPARAM, sigOptParam);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CreateJoinRoomRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CreateJoinRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateJoinRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for CreateJoinRoomRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("CreateJoinRoomRequest");
      ds.field("worldId", &self.worldId());
      ds.field("lobbyId", &self.lobbyId());
      ds.field("maxSlot", &self.maxSlot());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomBinAttrInternal", &self.roomBinAttrInternal());
      ds.field("roomSearchableIntAttrExternal", &self.roomSearchableIntAttrExternal());
      ds.field("roomSearchableBinAttrExternal", &self.roomSearchableBinAttrExternal());
      ds.field("roomBinAttrExternal", &self.roomBinAttrExternal());
      ds.field("roomPassword", &self.roomPassword());
      ds.field("groupConfig", &self.groupConfig());
      ds.field("passwordSlotMask", &self.passwordSlotMask());
      ds.field("allowedUser", &self.allowedUser());
      ds.field("blockedUser", &self.blockedUser());
      ds.field("joinRoomGroupLabel", &self.joinRoomGroupLabel());
      ds.field("roomMemberBinAttrInternal", &self.roomMemberBinAttrInternal());
      ds.field("teamId", &self.teamId());
      ds.field("sigOptParam", &self.sigOptParam());
      ds.finish()
  }
}
pub enum JoinRoomRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct JoinRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for JoinRoomRequest<'a> {
    type Inner = JoinRoomRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> JoinRoomRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        JoinRoomRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args JoinRoomRequestArgs<'args>) -> flatbuffers::WIPOffset<JoinRoomRequest<'bldr>> {
      let mut builder = JoinRoomRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.optData { builder.add_optData(x); }
      if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
      if let Some(x) = args.joinRoomGroupLabel { builder.add_joinRoomGroupLabel(x); }
      if let Some(x) = args.roomPassword { builder.add_roomPassword(x); }
      builder.add_teamId(args.teamId);
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_ROOMPASSWORD: flatbuffers::VOffsetT = 6;
    pub const VT_JOINROOMGROUPLABEL: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 10;
    pub const VT_OPTDATA: flatbuffers::VOffsetT = 12;
    pub const VT_TEAMID: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(JoinRoomRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomPassword(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(JoinRoomRequest::VT_ROOMPASSWORD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn joinRoomGroupLabel(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(JoinRoomRequest::VT_JOINROOMGROUPLABEL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(JoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, None)
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(JoinRoomRequest::VT_OPTDATA, None)
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    self._tab.get::<u8>(JoinRoomRequest::VT_TEAMID, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for JoinRoomRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"roomId", Self::VT_ROOMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"roomPassword", Self::VT_ROOMPASSWORD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"joinRoomGroupLabel", Self::VT_JOINROOMGROUPLABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomMemberBinAttrInternal", Self::VT_ROOMMEMBERBINATTRINTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(&"optData", Self::VT_OPTDATA, false)?
     .visit_field::<u8>(&"teamId", Self::VT_TEAMID, false)?
     .finish();
    Ok(())
  }
}
pub struct JoinRoomRequestArgs<'a> {
    pub roomId: u64,
    pub roomPassword: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub joinRoomGroupLabel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a>>>,
    pub teamId: u8,
}
impl<'a> Default for JoinRoomRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        JoinRoomRequestArgs {
            roomId: 0,
            roomPassword: None,
            joinRoomGroupLabel: None,
            roomMemberBinAttrInternal: None,
            optData: None,
            teamId: 0,
        }
    }
}
pub struct JoinRoomRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> JoinRoomRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(JoinRoomRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_roomPassword(&mut self, roomPassword: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JoinRoomRequest::VT_ROOMPASSWORD, roomPassword);
  }
  #[inline]
  pub fn add_joinRoomGroupLabel(&mut self, joinRoomGroupLabel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JoinRoomRequest::VT_JOINROOMGROUPLABEL, joinRoomGroupLabel);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(JoinRoomRequest::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(JoinRoomRequest::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> JoinRoomRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    JoinRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<JoinRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for JoinRoomRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("JoinRoomRequest");
      ds.field("roomId", &self.roomId());
      ds.field("roomPassword", &self.roomPassword());
      ds.field("joinRoomGroupLabel", &self.joinRoomGroupLabel());
      ds.field("roomMemberBinAttrInternal", &self.roomMemberBinAttrInternal());
      ds.field("optData", &self.optData());
      ds.field("teamId", &self.teamId());
      ds.finish()
  }
}
pub enum LeaveRoomRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeaveRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeaveRoomRequest<'a> {
    type Inner = LeaveRoomRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> LeaveRoomRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LeaveRoomRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LeaveRoomRequestArgs<'args>) -> flatbuffers::WIPOffset<LeaveRoomRequest<'bldr>> {
      let mut builder = LeaveRoomRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.optData { builder.add_optData(x); }
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_OPTDATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(LeaveRoomRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(LeaveRoomRequest::VT_OPTDATA, None)
  }
}

impl flatbuffers::Verifiable for LeaveRoomRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"roomId", Self::VT_ROOMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(&"optData", Self::VT_OPTDATA, false)?
     .finish();
    Ok(())
  }
}
pub struct LeaveRoomRequestArgs<'a> {
    pub roomId: u64,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a>>>,
}
impl<'a> Default for LeaveRoomRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        LeaveRoomRequestArgs {
            roomId: 0,
            optData: None,
        }
    }
}
pub struct LeaveRoomRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LeaveRoomRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(LeaveRoomRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(LeaveRoomRequest::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LeaveRoomRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LeaveRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeaveRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for LeaveRoomRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("LeaveRoomRequest");
      ds.field("roomId", &self.roomId());
      ds.field("optData", &self.optData());
      ds.finish()
  }
}
pub enum SetRoomDataExternalRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetRoomDataExternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetRoomDataExternalRequest<'a> {
    type Inner = SetRoomDataExternalRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SetRoomDataExternalRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetRoomDataExternalRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetRoomDataExternalRequestArgs<'args>) -> flatbuffers::WIPOffset<SetRoomDataExternalRequest<'bldr>> {
      let mut builder = SetRoomDataExternalRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.roomBinAttrExternal { builder.add_roomBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableBinAttrExternal { builder.add_roomSearchableBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableIntAttrExternal { builder.add_roomSearchableIntAttrExternal(x); }
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_ROOMSEARCHABLEINTATTREXTERNAL: flatbuffers::VOffsetT = 6;
    pub const VT_ROOMSEARCHABLEBINATTREXTERNAL: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMBINATTREXTERNAL: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(SetRoomDataExternalRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomSearchableIntAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr>>>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomSearchableBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(SetRoomDataExternalRequest::VT_ROOMBINATTREXTERNAL, None)
  }
}

impl flatbuffers::Verifiable for SetRoomDataExternalRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"roomId", Self::VT_ROOMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntAttr>>>>(&"roomSearchableIntAttrExternal", Self::VT_ROOMSEARCHABLEINTATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomSearchableBinAttrExternal", Self::VT_ROOMSEARCHABLEBINATTREXTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomBinAttrExternal", Self::VT_ROOMBINATTREXTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct SetRoomDataExternalRequestArgs<'a> {
    pub roomId: u64,
    pub roomSearchableIntAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>>>,
    pub roomSearchableBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub roomBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
}
impl<'a> Default for SetRoomDataExternalRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetRoomDataExternalRequestArgs {
            roomId: 0,
            roomSearchableIntAttrExternal: None,
            roomSearchableBinAttrExternal: None,
            roomBinAttrExternal: None,
        }
    }
}
pub struct SetRoomDataExternalRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetRoomDataExternalRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SetRoomDataExternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_roomSearchableIntAttrExternal(&mut self, roomSearchableIntAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, roomSearchableIntAttrExternal);
  }
  #[inline]
  pub fn add_roomSearchableBinAttrExternal(&mut self, roomSearchableBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, roomSearchableBinAttrExternal);
  }
  #[inline]
  pub fn add_roomBinAttrExternal(&mut self, roomBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataExternalRequest::VT_ROOMBINATTREXTERNAL, roomBinAttrExternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetRoomDataExternalRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SetRoomDataExternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetRoomDataExternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SetRoomDataExternalRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SetRoomDataExternalRequest");
      ds.field("roomId", &self.roomId());
      ds.field("roomSearchableIntAttrExternal", &self.roomSearchableIntAttrExternal());
      ds.field("roomSearchableBinAttrExternal", &self.roomSearchableBinAttrExternal());
      ds.field("roomBinAttrExternal", &self.roomBinAttrExternal());
      ds.finish()
  }
}
pub enum SetRoomDataInternalRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetRoomDataInternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetRoomDataInternalRequest<'a> {
    type Inner = SetRoomDataInternalRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SetRoomDataInternalRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetRoomDataInternalRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetRoomDataInternalRequestArgs<'args>) -> flatbuffers::WIPOffset<SetRoomDataInternalRequest<'bldr>> {
      let mut builder = SetRoomDataInternalRequestBuilder::new(_fbb);
      builder.add_passwordSlotMask(args.passwordSlotMask);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.ownerPrivilegeRank { builder.add_ownerPrivilegeRank(x); }
      if let Some(x) = args.passwordConfig { builder.add_passwordConfig(x); }
      if let Some(x) = args.roomBinAttrInternal { builder.add_roomBinAttrInternal(x); }
      builder.add_flagAttr(args.flagAttr);
      builder.add_flagFilter(args.flagFilter);
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_FLAGFILTER: flatbuffers::VOffsetT = 6;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 10;
    pub const VT_PASSWORDCONFIG: flatbuffers::VOffsetT = 12;
    pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 14;
    pub const VT_OWNERPRIVILEGERANK: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(SetRoomDataInternalRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagFilter(&self) -> u32 {
    self._tab.get::<u32>(SetRoomDataInternalRequest::VT_FLAGFILTER, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(SetRoomDataInternalRequest::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr>>>>(SetRoomDataInternalRequest::VT_ROOMBINATTRINTERNAL, None)
  }
  #[inline]
  pub fn passwordConfig(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig>>>>(SetRoomDataInternalRequest::VT_PASSWORDCONFIG, None)
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(SetRoomDataInternalRequest::VT_PASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn ownerPrivilegeRank(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SetRoomDataInternalRequest::VT_OWNERPRIVILEGERANK, None)
  }
}

impl flatbuffers::Verifiable for SetRoomDataInternalRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"roomId", Self::VT_ROOMID, false)?
     .visit_field::<u32>(&"flagFilter", Self::VT_FLAGFILTER, false)?
     .visit_field::<u32>(&"flagAttr", Self::VT_FLAGATTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinAttr>>>>(&"roomBinAttrInternal", Self::VT_ROOMBINATTRINTERNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig>>>>(&"passwordConfig", Self::VT_PASSWORDCONFIG, false)?
     .visit_field::<u64>(&"passwordSlotMask", Self::VT_PASSWORDSLOTMASK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"ownerPrivilegeRank", Self::VT_OWNERPRIVILEGERANK, false)?
     .finish();
    Ok(())
  }
}
pub struct SetRoomDataInternalRequestArgs<'a> {
    pub roomId: u64,
    pub flagFilter: u32,
    pub flagAttr: u32,
    pub roomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>,
    pub passwordConfig: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'a>>>>>,
    pub passwordSlotMask: u64,
    pub ownerPrivilegeRank: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for SetRoomDataInternalRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetRoomDataInternalRequestArgs {
            roomId: 0,
            flagFilter: 0,
            flagAttr: 0,
            roomBinAttrInternal: None,
            passwordConfig: None,
            passwordSlotMask: 0,
            ownerPrivilegeRank: None,
        }
    }
}
pub struct SetRoomDataInternalRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetRoomDataInternalRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SetRoomDataInternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_flagFilter(&mut self, flagFilter: u32) {
    self.fbb_.push_slot::<u32>(SetRoomDataInternalRequest::VT_FLAGFILTER, flagFilter, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(SetRoomDataInternalRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomBinAttrInternal(&mut self, roomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataInternalRequest::VT_ROOMBINATTRINTERNAL, roomBinAttrInternal);
  }
  #[inline]
  pub fn add_passwordConfig(&mut self, passwordConfig: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataInternalRequest::VT_PASSWORDCONFIG, passwordConfig);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(SetRoomDataInternalRequest::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_ownerPrivilegeRank(&mut self, ownerPrivilegeRank: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataInternalRequest::VT_OWNERPRIVILEGERANK, ownerPrivilegeRank);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetRoomDataInternalRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SetRoomDataInternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetRoomDataInternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SetRoomDataInternalRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SetRoomDataInternalRequest");
      ds.field("roomId", &self.roomId());
      ds.field("flagFilter", &self.flagFilter());
      ds.field("flagAttr", &self.flagAttr());
      ds.field("roomBinAttrInternal", &self.roomBinAttrInternal());
      ds.field("passwordConfig", &self.passwordConfig());
      ds.field("passwordSlotMask", &self.passwordSlotMask());
      ds.field("ownerPrivilegeRank", &self.ownerPrivilegeRank());
      ds.finish()
  }
}
pub enum GetRoomDataInternalRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetRoomDataInternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRoomDataInternalRequest<'a> {
    type Inner = GetRoomDataInternalRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> GetRoomDataInternalRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetRoomDataInternalRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetRoomDataInternalRequestArgs<'args>) -> flatbuffers::WIPOffset<GetRoomDataInternalRequest<'bldr>> {
      let mut builder = GetRoomDataInternalRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.attrId { builder.add_attrId(x); }
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(GetRoomDataInternalRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn attrId(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(GetRoomDataInternalRequest::VT_ATTRID, None)
  }
}

impl flatbuffers::Verifiable for GetRoomDataInternalRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"roomId", Self::VT_ROOMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"attrId", Self::VT_ATTRID, false)?
     .finish();
    Ok(())
  }
}
pub struct GetRoomDataInternalRequestArgs<'a> {
    pub roomId: u64,
    pub attrId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for GetRoomDataInternalRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetRoomDataInternalRequestArgs {
            roomId: 0,
            attrId: None,
        }
    }
}
pub struct GetRoomDataInternalRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetRoomDataInternalRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(GetRoomDataInternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_attrId(&mut self, attrId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRoomDataInternalRequest::VT_ATTRID, attrId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetRoomDataInternalRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetRoomDataInternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRoomDataInternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for GetRoomDataInternalRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("GetRoomDataInternalRequest");
      ds.field("roomId", &self.roomId());
      ds.field("attrId", &self.attrId());
      ds.finish()
  }
}
pub enum RoomMemberUpdateInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomMemberUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMemberUpdateInfo<'a> {
    type Inner = RoomMemberUpdateInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RoomMemberUpdateInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomMemberUpdateInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomMemberUpdateInfoArgs<'args>) -> flatbuffers::WIPOffset<RoomMemberUpdateInfo<'bldr>> {
      let mut builder = RoomMemberUpdateInfoBuilder::new(_fbb);
      if let Some(x) = args.optData { builder.add_optData(x); }
      if let Some(x) = args.roomMemberDataInternal { builder.add_roomMemberDataInternal(x); }
      builder.add_eventCause(args.eventCause);
      builder.finish()
    }

    pub const VT_ROOMMEMBERDATAINTERNAL: flatbuffers::VOffsetT = 4;
    pub const VT_EVENTCAUSE: flatbuffers::VOffsetT = 6;
    pub const VT_OPTDATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn roomMemberDataInternal(&self) -> Option<RoomMemberDataInternal<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>(RoomMemberUpdateInfo::VT_ROOMMEMBERDATAINTERNAL, None)
  }
  #[inline]
  pub fn eventCause(&self) -> u8 {
    self._tab.get::<u8>(RoomMemberUpdateInfo::VT_EVENTCAUSE, Some(0)).unwrap()
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(RoomMemberUpdateInfo::VT_OPTDATA, None)
  }
}

impl flatbuffers::Verifiable for RoomMemberUpdateInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<RoomMemberDataInternal>>(&"roomMemberDataInternal", Self::VT_ROOMMEMBERDATAINTERNAL, false)?
     .visit_field::<u8>(&"eventCause", Self::VT_EVENTCAUSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(&"optData", Self::VT_OPTDATA, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomMemberUpdateInfoArgs<'a> {
    pub roomMemberDataInternal: Option<flatbuffers::WIPOffset<RoomMemberDataInternal<'a>>>,
    pub eventCause: u8,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a>>>,
}
impl<'a> Default for RoomMemberUpdateInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomMemberUpdateInfoArgs {
            roomMemberDataInternal: None,
            eventCause: 0,
            optData: None,
        }
    }
}
pub struct RoomMemberUpdateInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomMemberUpdateInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomMemberDataInternal(&mut self, roomMemberDataInternal: flatbuffers::WIPOffset<RoomMemberDataInternal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RoomMemberDataInternal>>(RoomMemberUpdateInfo::VT_ROOMMEMBERDATAINTERNAL, roomMemberDataInternal);
  }
  #[inline]
  pub fn add_eventCause(&mut self, eventCause: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberUpdateInfo::VT_EVENTCAUSE, eventCause, 0);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(RoomMemberUpdateInfo::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomMemberUpdateInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomMemberUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMemberUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RoomMemberUpdateInfo<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RoomMemberUpdateInfo");
      ds.field("roomMemberDataInternal", &self.roomMemberDataInternal());
      ds.field("eventCause", &self.eventCause());
      ds.field("optData", &self.optData());
      ds.finish()
  }
}
pub enum RoomUpdateInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomUpdateInfo<'a> {
    type Inner = RoomUpdateInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RoomUpdateInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomUpdateInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomUpdateInfoArgs<'args>) -> flatbuffers::WIPOffset<RoomUpdateInfo<'bldr>> {
      let mut builder = RoomUpdateInfoBuilder::new(_fbb);
      if let Some(x) = args.optData { builder.add_optData(x); }
      builder.add_errorCode(args.errorCode);
      builder.add_eventCause(args.eventCause);
      builder.finish()
    }

    pub const VT_EVENTCAUSE: flatbuffers::VOffsetT = 4;
    pub const VT_ERRORCODE: flatbuffers::VOffsetT = 6;
    pub const VT_OPTDATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn eventCause(&self) -> u8 {
    self._tab.get::<u8>(RoomUpdateInfo::VT_EVENTCAUSE, Some(0)).unwrap()
  }
  #[inline]
  pub fn errorCode(&self) -> i32 {
    self._tab.get::<i32>(RoomUpdateInfo::VT_ERRORCODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(RoomUpdateInfo::VT_OPTDATA, None)
  }
}

impl flatbuffers::Verifiable for RoomUpdateInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>(&"eventCause", Self::VT_EVENTCAUSE, false)?
     .visit_field::<i32>(&"errorCode", Self::VT_ERRORCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PresenceOptionData>>(&"optData", Self::VT_OPTDATA, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomUpdateInfoArgs<'a> {
    pub eventCause: u8,
    pub errorCode: i32,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a>>>,
}
impl<'a> Default for RoomUpdateInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomUpdateInfoArgs {
            eventCause: 0,
            errorCode: 0,
            optData: None,
        }
    }
}
pub struct RoomUpdateInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomUpdateInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_eventCause(&mut self, eventCause: u8) {
    self.fbb_.push_slot::<u8>(RoomUpdateInfo::VT_EVENTCAUSE, eventCause, 0);
  }
  #[inline]
  pub fn add_errorCode(&mut self, errorCode: i32) {
    self.fbb_.push_slot::<i32>(RoomUpdateInfo::VT_ERRORCODE, errorCode, 0);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(RoomUpdateInfo::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomUpdateInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RoomUpdateInfo<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RoomUpdateInfo");
      ds.field("eventCause", &self.eventCause());
      ds.field("errorCode", &self.errorCode());
      ds.field("optData", &self.optData());
      ds.finish()
  }
}
pub enum GetPingInfoResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetPingInfoResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPingInfoResponse<'a> {
    type Inner = GetPingInfoResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> GetPingInfoResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetPingInfoResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetPingInfoResponseArgs) -> flatbuffers::WIPOffset<GetPingInfoResponse<'bldr>> {
      let mut builder = GetPingInfoResponseBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      builder.add_rtt(args.rtt);
      builder.add_worldId(args.worldId);
      builder.add_serverId(args.serverId);
      builder.finish()
    }

    pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
    pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
    pub const VT_ROOMID: flatbuffers::VOffsetT = 8;
    pub const VT_RTT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn serverId(&self) -> u16 {
    self._tab.get::<u16>(GetPingInfoResponse::VT_SERVERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(GetPingInfoResponse::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(GetPingInfoResponse::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn rtt(&self) -> u32 {
    self._tab.get::<u32>(GetPingInfoResponse::VT_RTT, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for GetPingInfoResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"serverId", Self::VT_SERVERID, false)?
     .visit_field::<u32>(&"worldId", Self::VT_WORLDID, false)?
     .visit_field::<u64>(&"roomId", Self::VT_ROOMID, false)?
     .visit_field::<u32>(&"rtt", Self::VT_RTT, false)?
     .finish();
    Ok(())
  }
}
pub struct GetPingInfoResponseArgs {
    pub serverId: u16,
    pub worldId: u32,
    pub roomId: u64,
    pub rtt: u32,
}
impl<'a> Default for GetPingInfoResponseArgs {
    #[inline]
    fn default() -> Self {
        GetPingInfoResponseArgs {
            serverId: 0,
            worldId: 0,
            roomId: 0,
            rtt: 0,
        }
    }
}
pub struct GetPingInfoResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetPingInfoResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(GetPingInfoResponse::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(GetPingInfoResponse::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(GetPingInfoResponse::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_rtt(&mut self, rtt: u32) {
    self.fbb_.push_slot::<u32>(GetPingInfoResponse::VT_RTT, rtt, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetPingInfoResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetPingInfoResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPingInfoResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for GetPingInfoResponse<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("GetPingInfoResponse");
      ds.field("serverId", &self.serverId());
      ds.field("worldId", &self.worldId());
      ds.field("roomId", &self.roomId());
      ds.field("rtt", &self.rtt());
      ds.finish()
  }
}
pub enum SendRoomMessageRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SendRoomMessageRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SendRoomMessageRequest<'a> {
    type Inner = SendRoomMessageRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SendRoomMessageRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SendRoomMessageRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SendRoomMessageRequestArgs<'args>) -> flatbuffers::WIPOffset<SendRoomMessageRequest<'bldr>> {
      let mut builder = SendRoomMessageRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.msg { builder.add_msg(x); }
      if let Some(x) = args.dst { builder.add_dst(x); }
      builder.add_option(args.option);
      builder.add_castType(args.castType);
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_CASTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DST: flatbuffers::VOffsetT = 8;
    pub const VT_MSG: flatbuffers::VOffsetT = 10;
    pub const VT_OPTION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(SendRoomMessageRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn castType(&self) -> u8 {
    self._tab.get::<u8>(SendRoomMessageRequest::VT_CASTTYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn dst(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SendRoomMessageRequest::VT_DST, None)
  }
  #[inline]
  pub fn msg(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SendRoomMessageRequest::VT_MSG, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn option(&self) -> u8 {
    self._tab.get::<u8>(SendRoomMessageRequest::VT_OPTION, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for SendRoomMessageRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"roomId", Self::VT_ROOMID, false)?
     .visit_field::<u8>(&"castType", Self::VT_CASTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"dst", Self::VT_DST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"msg", Self::VT_MSG, false)?
     .visit_field::<u8>(&"option", Self::VT_OPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct SendRoomMessageRequestArgs<'a> {
    pub roomId: u64,
    pub castType: u8,
    pub dst: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub msg: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub option: u8,
}
impl<'a> Default for SendRoomMessageRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SendRoomMessageRequestArgs {
            roomId: 0,
            castType: 0,
            dst: None,
            msg: None,
            option: 0,
        }
    }
}
pub struct SendRoomMessageRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SendRoomMessageRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SendRoomMessageRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_castType(&mut self, castType: u8) {
    self.fbb_.push_slot::<u8>(SendRoomMessageRequest::VT_CASTTYPE, castType, 0);
  }
  #[inline]
  pub fn add_dst(&mut self, dst: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendRoomMessageRequest::VT_DST, dst);
  }
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendRoomMessageRequest::VT_MSG, msg);
  }
  #[inline]
  pub fn add_option(&mut self, option: u8) {
    self.fbb_.push_slot::<u8>(SendRoomMessageRequest::VT_OPTION, option, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SendRoomMessageRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SendRoomMessageRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SendRoomMessageRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SendRoomMessageRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SendRoomMessageRequest");
      ds.field("roomId", &self.roomId());
      ds.field("castType", &self.castType());
      ds.field("dst", &self.dst());
      ds.field("msg", &self.msg());
      ds.field("option", &self.option());
      ds.finish()
  }
}
pub enum RoomMessageInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RoomMessageInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMessageInfo<'a> {
    type Inner = RoomMessageInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RoomMessageInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomMessageInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomMessageInfoArgs<'args>) -> flatbuffers::WIPOffset<RoomMessageInfo<'bldr>> {
      let mut builder = RoomMessageInfoBuilder::new(_fbb);
      if let Some(x) = args.msg { builder.add_msg(x); }
      if let Some(x) = args.srcMember { builder.add_srcMember(x); }
      if let Some(x) = args.dst { builder.add_dst(x); }
      builder.add_castType(args.castType);
      builder.add_filtered(args.filtered);
      builder.finish()
    }

    pub const VT_FILTERED: flatbuffers::VOffsetT = 4;
    pub const VT_CASTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DST: flatbuffers::VOffsetT = 8;
    pub const VT_SRCMEMBER: flatbuffers::VOffsetT = 10;
    pub const VT_MSG: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn filtered(&self) -> bool {
    self._tab.get::<bool>(RoomMessageInfo::VT_FILTERED, Some(false)).unwrap()
  }
  #[inline]
  pub fn castType(&self) -> u8 {
    self._tab.get::<u8>(RoomMessageInfo::VT_CASTTYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn dst(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(RoomMessageInfo::VT_DST, None)
  }
  #[inline]
  pub fn srcMember(&self) -> Option<UserInfo2<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo2>>(RoomMessageInfo::VT_SRCMEMBER, None)
  }
  #[inline]
  pub fn msg(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomMessageInfo::VT_MSG, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for RoomMessageInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>(&"filtered", Self::VT_FILTERED, false)?
     .visit_field::<u8>(&"castType", Self::VT_CASTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"dst", Self::VT_DST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<UserInfo2>>(&"srcMember", Self::VT_SRCMEMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"msg", Self::VT_MSG, false)?
     .finish();
    Ok(())
  }
}
pub struct RoomMessageInfoArgs<'a> {
    pub filtered: bool,
    pub castType: u8,
    pub dst: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub srcMember: Option<flatbuffers::WIPOffset<UserInfo2<'a>>>,
    pub msg: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RoomMessageInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomMessageInfoArgs {
            filtered: false,
            castType: 0,
            dst: None,
            srcMember: None,
            msg: None,
        }
    }
}
pub struct RoomMessageInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomMessageInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_filtered(&mut self, filtered: bool) {
    self.fbb_.push_slot::<bool>(RoomMessageInfo::VT_FILTERED, filtered, false);
  }
  #[inline]
  pub fn add_castType(&mut self, castType: u8) {
    self.fbb_.push_slot::<u8>(RoomMessageInfo::VT_CASTTYPE, castType, 0);
  }
  #[inline]
  pub fn add_dst(&mut self, dst: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMessageInfo::VT_DST, dst);
  }
  #[inline]
  pub fn add_srcMember(&mut self, srcMember: flatbuffers::WIPOffset<UserInfo2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo2>>(RoomMessageInfo::VT_SRCMEMBER, srcMember);
  }
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMessageInfo::VT_MSG, msg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomMessageInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomMessageInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMessageInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RoomMessageInfo<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RoomMessageInfo");
      ds.field("filtered", &self.filtered());
      ds.field("castType", &self.castType());
      ds.field("dst", &self.dst());
      ds.field("srcMember", &self.srcMember());
      ds.field("msg", &self.msg());
      ds.finish()
  }
}
pub enum MessageDetailsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MessageDetails<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MessageDetails<'a> {
    type Inner = MessageDetails<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MessageDetails<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MessageDetails { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MessageDetailsArgs<'args>) -> flatbuffers::WIPOffset<MessageDetails<'bldr>> {
      let mut builder = MessageDetailsBuilder::new(_fbb);
      builder.add_msgId(args.msgId);
      if let Some(x) = args.data { builder.add_data(x); }
      if let Some(x) = args.body { builder.add_body(x); }
      if let Some(x) = args.subject { builder.add_subject(x); }
      builder.add_msgFeatures(args.msgFeatures);
      if let Some(x) = args.communicationId { builder.add_communicationId(x); }
      builder.add_subType(args.subType);
      builder.add_mainType(args.mainType);
      builder.finish()
    }

    pub const VT_COMMUNICATIONID: flatbuffers::VOffsetT = 4;
    pub const VT_MSGID: flatbuffers::VOffsetT = 6;
    pub const VT_MAINTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_SUBTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_MSGFEATURES: flatbuffers::VOffsetT = 12;
    pub const VT_SUBJECT: flatbuffers::VOffsetT = 14;
    pub const VT_BODY: flatbuffers::VOffsetT = 16;
    pub const VT_DATA: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn communicationId(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MessageDetails::VT_COMMUNICATIONID, None)
  }
  #[inline]
  pub fn msgId(&self) -> u64 {
    self._tab.get::<u64>(MessageDetails::VT_MSGID, Some(0)).unwrap()
  }
  #[inline]
  pub fn mainType(&self) -> u16 {
    self._tab.get::<u16>(MessageDetails::VT_MAINTYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn subType(&self) -> u16 {
    self._tab.get::<u16>(MessageDetails::VT_SUBTYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn msgFeatures(&self) -> u32 {
    self._tab.get::<u32>(MessageDetails::VT_MSGFEATURES, Some(0)).unwrap()
  }
  #[inline]
  pub fn subject(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MessageDetails::VT_SUBJECT, None)
  }
  #[inline]
  pub fn body(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MessageDetails::VT_BODY, None)
  }
  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MessageDetails::VT_DATA, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for MessageDetails<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"communicationId", Self::VT_COMMUNICATIONID, false)?
     .visit_field::<u64>(&"msgId", Self::VT_MSGID, false)?
     .visit_field::<u16>(&"mainType", Self::VT_MAINTYPE, false)?
     .visit_field::<u16>(&"subType", Self::VT_SUBTYPE, false)?
     .visit_field::<u32>(&"msgFeatures", Self::VT_MSGFEATURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"subject", Self::VT_SUBJECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"body", Self::VT_BODY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct MessageDetailsArgs<'a> {
    pub communicationId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgId: u64,
    pub mainType: u16,
    pub subType: u16,
    pub msgFeatures: u32,
    pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
    pub body: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MessageDetailsArgs<'a> {
    #[inline]
    fn default() -> Self {
        MessageDetailsArgs {
            communicationId: None,
            msgId: 0,
            mainType: 0,
            subType: 0,
            msgFeatures: 0,
            subject: None,
            body: None,
            data: None,
        }
    }
}
pub struct MessageDetailsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageDetailsBuilder<'a, 'b> {
  #[inline]
  pub fn add_communicationId(&mut self, communicationId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageDetails::VT_COMMUNICATIONID, communicationId);
  }
  #[inline]
  pub fn add_msgId(&mut self, msgId: u64) {
    self.fbb_.push_slot::<u64>(MessageDetails::VT_MSGID, msgId, 0);
  }
  #[inline]
  pub fn add_mainType(&mut self, mainType: u16) {
    self.fbb_.push_slot::<u16>(MessageDetails::VT_MAINTYPE, mainType, 0);
  }
  #[inline]
  pub fn add_subType(&mut self, subType: u16) {
    self.fbb_.push_slot::<u16>(MessageDetails::VT_SUBTYPE, subType, 0);
  }
  #[inline]
  pub fn add_msgFeatures(&mut self, msgFeatures: u32) {
    self.fbb_.push_slot::<u32>(MessageDetails::VT_MSGFEATURES, msgFeatures, 0);
  }
  #[inline]
  pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageDetails::VT_SUBJECT, subject);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageDetails::VT_BODY, body);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageDetails::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageDetailsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageDetailsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MessageDetails<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MessageDetails<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MessageDetails");
      ds.field("communicationId", &self.communicationId());
      ds.field("msgId", &self.msgId());
      ds.field("mainType", &self.mainType());
      ds.field("subType", &self.subType());
      ds.field("msgFeatures", &self.msgFeatures());
      ds.field("subject", &self.subject());
      ds.field("body", &self.body());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum SendMessageRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SendMessageRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SendMessageRequest<'a> {
    type Inner = SendMessageRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SendMessageRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SendMessageRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SendMessageRequestArgs<'args>) -> flatbuffers::WIPOffset<SendMessageRequest<'bldr>> {
      let mut builder = SendMessageRequestBuilder::new(_fbb);
      if let Some(x) = args.npids { builder.add_npids(x); }
      if let Some(x) = args.message { builder.add_message(x); }
      builder.finish()
    }

    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;
    pub const VT_NPIDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn message(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SendMessageRequest::VT_MESSAGE, None).map(|v| v.safe_slice())
  }
  pub fn message_nested_flatbuffer(&'a self) -> Option<MessageDetails<'a>> {
    self.message().map(|data| {
      use flatbuffers::Follow;
      <flatbuffers::ForwardsUOffset<MessageDetails<'a>>>::follow(data, 0)
    })
  }
  #[inline]
  pub fn npids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SendMessageRequest::VT_NPIDS, None)
  }
}

impl flatbuffers::Verifiable for SendMessageRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"message", Self::VT_MESSAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(&"npids", Self::VT_NPIDS, false)?
     .finish();
    Ok(())
  }
}
pub struct SendMessageRequestArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub npids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SendMessageRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SendMessageRequestArgs {
            message: None,
            npids: None,
        }
    }
}
pub struct SendMessageRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SendMessageRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendMessageRequest::VT_MESSAGE, message);
  }
  #[inline]
  pub fn add_npids(&mut self, npids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendMessageRequest::VT_NPIDS, npids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SendMessageRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SendMessageRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SendMessageRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SendMessageRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SendMessageRequest");
      ds.field("message", &self.message());
      ds.field("npids", &self.npids());
      ds.finish()
  }
}
