// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

pub enum BinAttrOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BinAttr<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinAttr<'a> {
    type Inner = BinAttr<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BinAttr<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BinAttr {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BinAttrArgs<'args>) -> flatbuffers::WIPOffset<BinAttr<'bldr>> {
      let mut builder = BinAttrBuilder::new(_fbb);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(BinAttr::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(BinAttr::VT_DATA, None).map(|v| v.safe_slice())
  }
}

pub struct BinAttrArgs<'a> {
    pub id: u16,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for BinAttrArgs<'a> {
    #[inline]
    fn default() -> Self {
        BinAttrArgs {
            id: 0,
            data: None,
        }
    }
}
pub struct BinAttrBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BinAttrBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(BinAttr::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinAttr::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinAttrBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BinAttrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinAttr<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IntAttrOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IntAttr<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntAttr<'a> {
    type Inner = IntAttr<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IntAttr<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntAttr {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IntAttrArgs) -> flatbuffers::WIPOffset<IntAttr<'bldr>> {
      let mut builder = IntAttrBuilder::new(_fbb);
      builder.add_num(args.num);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NUM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(IntAttr::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn num(&self) -> u32 {
    self._tab.get::<u32>(IntAttr::VT_NUM, Some(0)).unwrap()
  }
}

pub struct IntAttrArgs {
    pub id: u16,
    pub num: u32,
}
impl<'a> Default for IntAttrArgs {
    #[inline]
    fn default() -> Self {
        IntAttrArgs {
            id: 0,
            num: 0,
        }
    }
}
pub struct IntAttrBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntAttrBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(IntAttr::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_num(&mut self, num: u32) {
    self.fbb_.push_slot::<u32>(IntAttr::VT_NUM, num, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntAttrBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IntAttrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntAttr<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MemberBinAttrInternalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MemberBinAttrInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MemberBinAttrInternal<'a> {
    type Inner = MemberBinAttrInternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MemberBinAttrInternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MemberBinAttrInternal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MemberBinAttrInternalArgs<'args>) -> flatbuffers::WIPOffset<MemberBinAttrInternal<'bldr>> {
      let mut builder = MemberBinAttrInternalBuilder::new(_fbb);
      builder.add_updateDate(args.updateDate);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.finish()
    }

    pub const VT_UPDATEDATE: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn updateDate(&self) -> u64 {
    self._tab.get::<u64>(MemberBinAttrInternal::VT_UPDATEDATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<BinAttr<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BinAttr<'a>>>(MemberBinAttrInternal::VT_DATA, None)
  }
}

pub struct MemberBinAttrInternalArgs<'a> {
    pub updateDate: u64,
    pub data: Option<flatbuffers::WIPOffset<BinAttr<'a >>>,
}
impl<'a> Default for MemberBinAttrInternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        MemberBinAttrInternalArgs {
            updateDate: 0,
            data: None,
        }
    }
}
pub struct MemberBinAttrInternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MemberBinAttrInternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_updateDate(&mut self, updateDate: u64) {
    self.fbb_.push_slot::<u64>(MemberBinAttrInternal::VT_UPDATEDATE, updateDate, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<BinAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinAttr>>(MemberBinAttrInternal::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MemberBinAttrInternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MemberBinAttrInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MemberBinAttrInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BinAttrInternalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BinAttrInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinAttrInternal<'a> {
    type Inner = BinAttrInternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BinAttrInternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BinAttrInternal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BinAttrInternalArgs<'args>) -> flatbuffers::WIPOffset<BinAttrInternal<'bldr>> {
      let mut builder = BinAttrInternalBuilder::new(_fbb);
      builder.add_updateDate(args.updateDate);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.add_updateMemberId(args.updateMemberId);
      builder.finish()
    }

    pub const VT_UPDATEDATE: flatbuffers::VOffsetT = 4;
    pub const VT_UPDATEMEMBERID: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn updateDate(&self) -> u64 {
    self._tab.get::<u64>(BinAttrInternal::VT_UPDATEDATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn updateMemberId(&self) -> u16 {
    self._tab.get::<u16>(BinAttrInternal::VT_UPDATEMEMBERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<BinAttr<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BinAttr<'a>>>(BinAttrInternal::VT_DATA, None)
  }
}

pub struct BinAttrInternalArgs<'a> {
    pub updateDate: u64,
    pub updateMemberId: u16,
    pub data: Option<flatbuffers::WIPOffset<BinAttr<'a >>>,
}
impl<'a> Default for BinAttrInternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        BinAttrInternalArgs {
            updateDate: 0,
            updateMemberId: 0,
            data: None,
        }
    }
}
pub struct BinAttrInternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BinAttrInternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_updateDate(&mut self, updateDate: u64) {
    self.fbb_.push_slot::<u64>(BinAttrInternal::VT_UPDATEDATE, updateDate, 0);
  }
  #[inline]
  pub fn add_updateMemberId(&mut self, updateMemberId: u16) {
    self.fbb_.push_slot::<u16>(BinAttrInternal::VT_UPDATEMEMBERID, updateMemberId, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<BinAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinAttr>>(BinAttrInternal::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinAttrInternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BinAttrInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinAttrInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OptParamOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OptParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OptParam<'a> {
    type Inner = OptParam<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> OptParam<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OptParam {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OptParamArgs) -> flatbuffers::WIPOffset<OptParam<'bldr>> {
      let mut builder = OptParamBuilder::new(_fbb);
      builder.add_hubMemberId(args.hubMemberId);
      builder.add_flag(args.flag);
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_FLAG: flatbuffers::VOffsetT = 6;
    pub const VT_HUBMEMBERID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn type_(&self) -> u8 {
    self._tab.get::<u8>(OptParam::VT_TYPE_, Some(0)).unwrap()
  }
  #[inline]
  pub fn flag(&self) -> u8 {
    self._tab.get::<u8>(OptParam::VT_FLAG, Some(0)).unwrap()
  }
  #[inline]
  pub fn hubMemberId(&self) -> u16 {
    self._tab.get::<u16>(OptParam::VT_HUBMEMBERID, Some(0)).unwrap()
  }
}

pub struct OptParamArgs {
    pub type_: u8,
    pub flag: u8,
    pub hubMemberId: u16,
}
impl<'a> Default for OptParamArgs {
    #[inline]
    fn default() -> Self {
        OptParamArgs {
            type_: 0,
            flag: 0,
            hubMemberId: 0,
        }
    }
}
pub struct OptParamBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OptParamBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: u8) {
    self.fbb_.push_slot::<u8>(OptParam::VT_TYPE_, type_, 0);
  }
  #[inline]
  pub fn add_flag(&mut self, flag: u8) {
    self.fbb_.push_slot::<u8>(OptParam::VT_FLAG, flag, 0);
  }
  #[inline]
  pub fn add_hubMemberId(&mut self, hubMemberId: u16) {
    self.fbb_.push_slot::<u16>(OptParam::VT_HUBMEMBERID, hubMemberId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OptParamBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OptParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OptParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GroupConfigOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GroupConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GroupConfig<'a> {
    type Inner = GroupConfig<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GroupConfig<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GroupConfig {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GroupConfigArgs<'args>) -> flatbuffers::WIPOffset<GroupConfig<'bldr>> {
      let mut builder = GroupConfigBuilder::new(_fbb);
      if let Some(x) = args.label { builder.add_label(x); }
      builder.add_slotNum(args.slotNum);
      builder.add_withPassword(args.withPassword);
      builder.add_withLabel(args.withLabel);
      builder.finish()
    }

    pub const VT_SLOTNUM: flatbuffers::VOffsetT = 4;
    pub const VT_WITHLABEL: flatbuffers::VOffsetT = 6;
    pub const VT_LABEL: flatbuffers::VOffsetT = 8;
    pub const VT_WITHPASSWORD: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn slotNum(&self) -> u32 {
    self._tab.get::<u32>(GroupConfig::VT_SLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn withLabel(&self) -> bool {
    self._tab.get::<bool>(GroupConfig::VT_WITHLABEL, Some(false)).unwrap()
  }
  #[inline]
  pub fn label(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GroupConfig::VT_LABEL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn withPassword(&self) -> bool {
    self._tab.get::<bool>(GroupConfig::VT_WITHPASSWORD, Some(false)).unwrap()
  }
}

pub struct GroupConfigArgs<'a> {
    pub slotNum: u32,
    pub withLabel: bool,
    pub label: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub withPassword: bool,
}
impl<'a> Default for GroupConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        GroupConfigArgs {
            slotNum: 0,
            withLabel: false,
            label: None,
            withPassword: false,
        }
    }
}
pub struct GroupConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GroupConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_slotNum(&mut self, slotNum: u32) {
    self.fbb_.push_slot::<u32>(GroupConfig::VT_SLOTNUM, slotNum, 0);
  }
  #[inline]
  pub fn add_withLabel(&mut self, withLabel: bool) {
    self.fbb_.push_slot::<bool>(GroupConfig::VT_WITHLABEL, withLabel, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroupConfig::VT_LABEL, label);
  }
  #[inline]
  pub fn add_withPassword(&mut self, withPassword: bool) {
    self.fbb_.push_slot::<bool>(GroupConfig::VT_WITHPASSWORD, withPassword, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GroupConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GroupConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GroupConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UserInfo2Offset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UserInfo2<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UserInfo2<'a> {
    type Inner = UserInfo2<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UserInfo2<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UserInfo2 {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UserInfo2Args<'args>) -> flatbuffers::WIPOffset<UserInfo2<'bldr>> {
      let mut builder = UserInfo2Builder::new(_fbb);
      if let Some(x) = args.avatarUrl { builder.add_avatarUrl(x); }
      if let Some(x) = args.onlineName { builder.add_onlineName(x); }
      if let Some(x) = args.npId { builder.add_npId(x); }
      builder.finish()
    }

    pub const VT_NPID: flatbuffers::VOffsetT = 4;
    pub const VT_ONLINENAME: flatbuffers::VOffsetT = 6;
    pub const VT_AVATARURL: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn npId(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserInfo2::VT_NPID, None)
  }
  #[inline]
  pub fn onlineName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserInfo2::VT_ONLINENAME, None)
  }
  #[inline]
  pub fn avatarUrl(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserInfo2::VT_AVATARURL, None)
  }
}

pub struct UserInfo2Args<'a> {
    pub npId: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub onlineName: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub avatarUrl: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for UserInfo2Args<'a> {
    #[inline]
    fn default() -> Self {
        UserInfo2Args {
            npId: None,
            onlineName: None,
            avatarUrl: None,
        }
    }
}
pub struct UserInfo2Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UserInfo2Builder<'a, 'b> {
  #[inline]
  pub fn add_npId(&mut self, npId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInfo2::VT_NPID, npId);
  }
  #[inline]
  pub fn add_onlineName(&mut self, onlineName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInfo2::VT_ONLINENAME, onlineName);
  }
  #[inline]
  pub fn add_avatarUrl(&mut self, avatarUrl: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserInfo2::VT_AVATARURL, avatarUrl);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UserInfo2Builder<'a, 'b> {
    let start = _fbb.start_table();
    UserInfo2Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UserInfo2<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomMemberDataInternalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomMemberDataInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMemberDataInternal<'a> {
    type Inner = RoomMemberDataInternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomMemberDataInternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomMemberDataInternal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomMemberDataInternalArgs<'args>) -> flatbuffers::WIPOffset<RoomMemberDataInternal<'bldr>> {
      let mut builder = RoomMemberDataInternalBuilder::new(_fbb);
      builder.add_joinDate(args.joinDate);
      if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
      builder.add_flagAttr(args.flagAttr);
      if let Some(x) = args.userInfo { builder.add_userInfo(x); }
      builder.add_memberId(args.memberId);
      builder.add_natType(args.natType);
      builder.add_roomGroup(args.roomGroup);
      builder.add_teamId(args.teamId);
      builder.finish()
    }

    pub const VT_USERINFO: flatbuffers::VOffsetT = 4;
    pub const VT_JOINDATE: flatbuffers::VOffsetT = 6;
    pub const VT_MEMBERID: flatbuffers::VOffsetT = 8;
    pub const VT_TEAMID: flatbuffers::VOffsetT = 10;
    pub const VT_ROOMGROUP: flatbuffers::VOffsetT = 12;
    pub const VT_NATTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 16;
    pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn userInfo(&self) -> Option<UserInfo2<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo2<'a>>>(RoomMemberDataInternal::VT_USERINFO, None)
  }
  #[inline]
  pub fn joinDate(&self) -> u64 {
    self._tab.get::<u64>(RoomMemberDataInternal::VT_JOINDATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn memberId(&self) -> u16 {
    self._tab.get::<u16>(RoomMemberDataInternal::VT_MEMBERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    self._tab.get::<u8>(RoomMemberDataInternal::VT_TEAMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomGroup(&self) -> u8 {
    self._tab.get::<u8>(RoomMemberDataInternal::VT_ROOMGROUP, Some(0)).unwrap()
  }
  #[inline]
  pub fn natType(&self) -> u8 {
    self._tab.get::<u8>(RoomMemberDataInternal::VT_NATTYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomMemberDataInternal::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'a>>>>>(RoomMemberDataInternal::VT_ROOMMEMBERBINATTRINTERNAL, None)
  }
}

pub struct RoomMemberDataInternalArgs<'a> {
    pub userInfo: Option<flatbuffers::WIPOffset<UserInfo2<'a >>>,
    pub joinDate: u64,
    pub memberId: u16,
    pub teamId: u8,
    pub roomGroup: u8,
    pub natType: u8,
    pub flagAttr: u32,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'a >>>>>,
}
impl<'a> Default for RoomMemberDataInternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomMemberDataInternalArgs {
            userInfo: None,
            joinDate: 0,
            memberId: 0,
            teamId: 0,
            roomGroup: 0,
            natType: 0,
            flagAttr: 0,
            roomMemberBinAttrInternal: None,
        }
    }
}
pub struct RoomMemberDataInternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomMemberDataInternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_userInfo(&mut self, userInfo: flatbuffers::WIPOffset<UserInfo2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo2>>(RoomMemberDataInternal::VT_USERINFO, userInfo);
  }
  #[inline]
  pub fn add_joinDate(&mut self, joinDate: u64) {
    self.fbb_.push_slot::<u64>(RoomMemberDataInternal::VT_JOINDATE, joinDate, 0);
  }
  #[inline]
  pub fn add_memberId(&mut self, memberId: u16) {
    self.fbb_.push_slot::<u16>(RoomMemberDataInternal::VT_MEMBERID, memberId, 0);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternal::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn add_roomGroup(&mut self, roomGroup: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternal::VT_ROOMGROUP, roomGroup, 0);
  }
  #[inline]
  pub fn add_natType(&mut self, natType: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternal::VT_NATTYPE, natType, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomMemberDataInternal::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMemberDataInternal::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomMemberDataInternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomMemberDataInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMemberDataInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomGroupOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomGroup<'a> {
    type Inner = RoomGroup<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomGroup<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomGroup {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomGroupArgs<'args>) -> flatbuffers::WIPOffset<RoomGroup<'bldr>> {
      let mut builder = RoomGroupBuilder::new(_fbb);
      builder.add_curGroupMemberNum(args.curGroupMemberNum);
      builder.add_slotNum(args.slotNum);
      if let Some(x) = args.label { builder.add_label(x); }
      builder.add_withLabel(args.withLabel);
      builder.add_withPassword(args.withPassword);
      builder.add_groupId(args.groupId);
      builder.finish()
    }

    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_WITHPASSWORD: flatbuffers::VOffsetT = 6;
    pub const VT_WITHLABEL: flatbuffers::VOffsetT = 8;
    pub const VT_LABEL: flatbuffers::VOffsetT = 10;
    pub const VT_SLOTNUM: flatbuffers::VOffsetT = 12;
    pub const VT_CURGROUPMEMBERNUM: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn groupId(&self) -> u8 {
    self._tab.get::<u8>(RoomGroup::VT_GROUPID, Some(0)).unwrap()
  }
  #[inline]
  pub fn withPassword(&self) -> bool {
    self._tab.get::<bool>(RoomGroup::VT_WITHPASSWORD, Some(false)).unwrap()
  }
  #[inline]
  pub fn withLabel(&self) -> bool {
    self._tab.get::<bool>(RoomGroup::VT_WITHLABEL, Some(false)).unwrap()
  }
  #[inline]
  pub fn label(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomGroup::VT_LABEL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn slotNum(&self) -> u32 {
    self._tab.get::<u32>(RoomGroup::VT_SLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn curGroupMemberNum(&self) -> u32 {
    self._tab.get::<u32>(RoomGroup::VT_CURGROUPMEMBERNUM, Some(0)).unwrap()
  }
}

pub struct RoomGroupArgs<'a> {
    pub groupId: u8,
    pub withPassword: bool,
    pub withLabel: bool,
    pub label: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub slotNum: u32,
    pub curGroupMemberNum: u32,
}
impl<'a> Default for RoomGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomGroupArgs {
            groupId: 0,
            withPassword: false,
            withLabel: false,
            label: None,
            slotNum: 0,
            curGroupMemberNum: 0,
        }
    }
}
pub struct RoomGroupBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomGroupBuilder<'a, 'b> {
  #[inline]
  pub fn add_groupId(&mut self, groupId: u8) {
    self.fbb_.push_slot::<u8>(RoomGroup::VT_GROUPID, groupId, 0);
  }
  #[inline]
  pub fn add_withPassword(&mut self, withPassword: bool) {
    self.fbb_.push_slot::<bool>(RoomGroup::VT_WITHPASSWORD, withPassword, false);
  }
  #[inline]
  pub fn add_withLabel(&mut self, withLabel: bool) {
    self.fbb_.push_slot::<bool>(RoomGroup::VT_WITHLABEL, withLabel, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomGroup::VT_LABEL, label);
  }
  #[inline]
  pub fn add_slotNum(&mut self, slotNum: u32) {
    self.fbb_.push_slot::<u32>(RoomGroup::VT_SLOTNUM, slotNum, 0);
  }
  #[inline]
  pub fn add_curGroupMemberNum(&mut self, curGroupMemberNum: u32) {
    self.fbb_.push_slot::<u32>(RoomGroup::VT_CURGROUPMEMBERNUM, curGroupMemberNum, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomGroupBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomDataInternalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomDataInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomDataInternal<'a> {
    type Inner = RoomDataInternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomDataInternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomDataInternal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomDataInternalArgs<'args>) -> flatbuffers::WIPOffset<RoomDataInternal<'bldr>> {
      let mut builder = RoomDataInternalBuilder::new(_fbb);
      builder.add_passwordSlotMask(args.passwordSlotMask);
      builder.add_roomId(args.roomId);
      builder.add_lobbyId(args.lobbyId);
      if let Some(x) = args.roomBinAttrInternal { builder.add_roomBinAttrInternal(x); }
      builder.add_flagAttr(args.flagAttr);
      if let Some(x) = args.roomGroup { builder.add_roomGroup(x); }
      if let Some(x) = args.memberList { builder.add_memberList(x); }
      builder.add_maxSlot(args.maxSlot);
      builder.add_worldId(args.worldId);
      builder.add_ownerId(args.ownerId);
      builder.add_serverId(args.serverId);
      builder.finish()
    }

    pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
    pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
    pub const VT_LOBBYID: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMID: flatbuffers::VOffsetT = 10;
    pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 12;
    pub const VT_MAXSLOT: flatbuffers::VOffsetT = 14;
    pub const VT_MEMBERLIST: flatbuffers::VOffsetT = 16;
    pub const VT_OWNERID: flatbuffers::VOffsetT = 18;
    pub const VT_ROOMGROUP: flatbuffers::VOffsetT = 20;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 22;
    pub const VT_ROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 24;

  #[inline]
  pub fn serverId(&self) -> u16 {
    self._tab.get::<u16>(RoomDataInternal::VT_SERVERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(RoomDataInternal::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    self._tab.get::<u64>(RoomDataInternal::VT_LOBBYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(RoomDataInternal::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(RoomDataInternal::VT_PASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn maxSlot(&self) -> u32 {
    self._tab.get::<u32>(RoomDataInternal::VT_MAXSLOT, Some(0)).unwrap()
  }
  #[inline]
  pub fn memberList(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'a>>>>>(RoomDataInternal::VT_MEMBERLIST, None)
  }
  #[inline]
  pub fn ownerId(&self) -> u16 {
    self._tab.get::<u16>(RoomDataInternal::VT_OWNERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomGroup(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RoomGroup<'a>>>>>(RoomDataInternal::VT_ROOMGROUP, None)
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomDataInternal::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttrInternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttrInternal<'a>>>>>(RoomDataInternal::VT_ROOMBINATTRINTERNAL, None)
  }
}

pub struct RoomDataInternalArgs<'a> {
    pub serverId: u16,
    pub worldId: u32,
    pub lobbyId: u64,
    pub roomId: u64,
    pub passwordSlotMask: u64,
    pub maxSlot: u32,
    pub memberList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'a >>>>>,
    pub ownerId: u16,
    pub roomGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<RoomGroup<'a >>>>>,
    pub flagAttr: u32,
    pub roomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttrInternal<'a >>>>>,
}
impl<'a> Default for RoomDataInternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomDataInternalArgs {
            serverId: 0,
            worldId: 0,
            lobbyId: 0,
            roomId: 0,
            passwordSlotMask: 0,
            maxSlot: 0,
            memberList: None,
            ownerId: 0,
            roomGroup: None,
            flagAttr: 0,
            roomBinAttrInternal: None,
        }
    }
}
pub struct RoomDataInternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomDataInternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(RoomDataInternal::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternal::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternal::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternal::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternal::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_maxSlot(&mut self, maxSlot: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternal::VT_MAXSLOT, maxSlot, 0);
  }
  #[inline]
  pub fn add_memberList(&mut self, memberList: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternal::VT_MEMBERLIST, memberList);
  }
  #[inline]
  pub fn add_ownerId(&mut self, ownerId: u16) {
    self.fbb_.push_slot::<u16>(RoomDataInternal::VT_OWNERID, ownerId, 0);
  }
  #[inline]
  pub fn add_roomGroup(&mut self, roomGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternal::VT_ROOMGROUP, roomGroup);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternal::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomBinAttrInternal(&mut self, roomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttrInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternal::VT_ROOMBINATTRINTERNAL, roomBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomDataInternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomDataInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomDataInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomDataExternalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomDataExternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomDataExternal<'a> {
    type Inner = RoomDataExternal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomDataExternal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomDataExternal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomDataExternalArgs<'args>) -> flatbuffers::WIPOffset<RoomDataExternal<'bldr>> {
      let mut builder = RoomDataExternalBuilder::new(_fbb);
      builder.add_passwordSlotMask(args.passwordSlotMask);
      builder.add_roomId(args.roomId);
      builder.add_lobbyId(args.lobbyId);
      if let Some(x) = args.roomBinAttrExternal { builder.add_roomBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableBinAttrExternal { builder.add_roomSearchableBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableIntAttrExternal { builder.add_roomSearchableIntAttrExternal(x); }
      builder.add_flagAttr(args.flagAttr);
      if let Some(x) = args.roomGroup { builder.add_roomGroup(x); }
      if let Some(x) = args.owner { builder.add_owner(x); }
      builder.add_worldId(args.worldId);
      builder.add_curMemberNum(args.curMemberNum);
      builder.add_openPrivateSlotNum(args.openPrivateSlotNum);
      builder.add_maxSlot(args.maxSlot);
      builder.add_openPublicSlotNum(args.openPublicSlotNum);
      builder.add_privateSlotNum(args.privateSlotNum);
      builder.add_publicSlotNum(args.publicSlotNum);
      builder.add_serverId(args.serverId);
      builder.finish()
    }

    pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
    pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
    pub const VT_PUBLICSLOTNUM: flatbuffers::VOffsetT = 8;
    pub const VT_PRIVATESLOTNUM: flatbuffers::VOffsetT = 10;
    pub const VT_LOBBYID: flatbuffers::VOffsetT = 12;
    pub const VT_ROOMID: flatbuffers::VOffsetT = 14;
    pub const VT_OPENPUBLICSLOTNUM: flatbuffers::VOffsetT = 16;
    pub const VT_MAXSLOT: flatbuffers::VOffsetT = 18;
    pub const VT_OPENPRIVATESLOTNUM: flatbuffers::VOffsetT = 20;
    pub const VT_CURMEMBERNUM: flatbuffers::VOffsetT = 22;
    pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 24;
    pub const VT_OWNER: flatbuffers::VOffsetT = 26;
    pub const VT_ROOMGROUP: flatbuffers::VOffsetT = 28;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 30;
    pub const VT_ROOMSEARCHABLEINTATTREXTERNAL: flatbuffers::VOffsetT = 32;
    pub const VT_ROOMSEARCHABLEBINATTREXTERNAL: flatbuffers::VOffsetT = 34;
    pub const VT_ROOMBINATTREXTERNAL: flatbuffers::VOffsetT = 36;

  #[inline]
  pub fn serverId(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_SERVERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(RoomDataExternal::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn publicSlotNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_PUBLICSLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn privateSlotNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_PRIVATESLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    self._tab.get::<u64>(RoomDataExternal::VT_LOBBYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(RoomDataExternal::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn openPublicSlotNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_OPENPUBLICSLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn maxSlot(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_MAXSLOT, Some(0)).unwrap()
  }
  #[inline]
  pub fn openPrivateSlotNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_OPENPRIVATESLOTNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn curMemberNum(&self) -> u16 {
    self._tab.get::<u16>(RoomDataExternal::VT_CURMEMBERNUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(RoomDataExternal::VT_PASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn owner(&self) -> Option<UserInfo2<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo2<'a>>>(RoomDataExternal::VT_OWNER, None)
  }
  #[inline]
  pub fn roomGroup(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RoomGroup<'a>>>>>(RoomDataExternal::VT_ROOMGROUP, None)
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomDataExternal::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomSearchableIntAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<IntAttr<'a>>>>>(RoomDataExternal::VT_ROOMSEARCHABLEINTATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomSearchableBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(RoomDataExternal::VT_ROOMSEARCHABLEBINATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(RoomDataExternal::VT_ROOMBINATTREXTERNAL, None)
  }
}

pub struct RoomDataExternalArgs<'a> {
    pub serverId: u16,
    pub worldId: u32,
    pub publicSlotNum: u16,
    pub privateSlotNum: u16,
    pub lobbyId: u64,
    pub roomId: u64,
    pub openPublicSlotNum: u16,
    pub maxSlot: u16,
    pub openPrivateSlotNum: u16,
    pub curMemberNum: u16,
    pub passwordSlotMask: u64,
    pub owner: Option<flatbuffers::WIPOffset<UserInfo2<'a >>>,
    pub roomGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<RoomGroup<'a >>>>>,
    pub flagAttr: u32,
    pub roomSearchableIntAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<IntAttr<'a >>>>>,
    pub roomSearchableBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
    pub roomBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
}
impl<'a> Default for RoomDataExternalArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomDataExternalArgs {
            serverId: 0,
            worldId: 0,
            publicSlotNum: 0,
            privateSlotNum: 0,
            lobbyId: 0,
            roomId: 0,
            openPublicSlotNum: 0,
            maxSlot: 0,
            openPrivateSlotNum: 0,
            curMemberNum: 0,
            passwordSlotMask: 0,
            owner: None,
            roomGroup: None,
            flagAttr: 0,
            roomSearchableIntAttrExternal: None,
            roomSearchableBinAttrExternal: None,
            roomBinAttrExternal: None,
        }
    }
}
pub struct RoomDataExternalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomDataExternalBuilder<'a, 'b> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(RoomDataExternal::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_publicSlotNum(&mut self, publicSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_PUBLICSLOTNUM, publicSlotNum, 0);
  }
  #[inline]
  pub fn add_privateSlotNum(&mut self, privateSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_PRIVATESLOTNUM, privateSlotNum, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataExternal::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(RoomDataExternal::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_openPublicSlotNum(&mut self, openPublicSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_OPENPUBLICSLOTNUM, openPublicSlotNum, 0);
  }
  #[inline]
  pub fn add_maxSlot(&mut self, maxSlot: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_MAXSLOT, maxSlot, 0);
  }
  #[inline]
  pub fn add_openPrivateSlotNum(&mut self, openPrivateSlotNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_OPENPRIVATESLOTNUM, openPrivateSlotNum, 0);
  }
  #[inline]
  pub fn add_curMemberNum(&mut self, curMemberNum: u16) {
    self.fbb_.push_slot::<u16>(RoomDataExternal::VT_CURMEMBERNUM, curMemberNum, 0);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(RoomDataExternal::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_owner(&mut self, owner: flatbuffers::WIPOffset<UserInfo2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo2>>(RoomDataExternal::VT_OWNER, owner);
  }
  #[inline]
  pub fn add_roomGroup(&mut self, roomGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMGROUP, roomGroup);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomDataExternal::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomSearchableIntAttrExternal(&mut self, roomSearchableIntAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMSEARCHABLEINTATTREXTERNAL, roomSearchableIntAttrExternal);
  }
  #[inline]
  pub fn add_roomSearchableBinAttrExternal(&mut self, roomSearchableBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMSEARCHABLEBINATTREXTERNAL, roomSearchableBinAttrExternal);
  }
  #[inline]
  pub fn add_roomBinAttrExternal(&mut self, roomBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataExternal::VT_ROOMBINATTREXTERNAL, roomBinAttrExternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomDataExternalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomDataExternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomDataExternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IntSearchFilterOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IntSearchFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntSearchFilter<'a> {
    type Inner = IntSearchFilter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IntSearchFilter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntSearchFilter {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IntSearchFilterArgs<'args>) -> flatbuffers::WIPOffset<IntSearchFilter<'bldr>> {
      let mut builder = IntSearchFilterBuilder::new(_fbb);
      if let Some(x) = args.attr { builder.add_attr(x); }
      builder.add_searchOperator(args.searchOperator);
      builder.finish()
    }

    pub const VT_SEARCHOPERATOR: flatbuffers::VOffsetT = 4;
    pub const VT_ATTR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn searchOperator(&self) -> u8 {
    self._tab.get::<u8>(IntSearchFilter::VT_SEARCHOPERATOR, Some(0)).unwrap()
  }
  #[inline]
  pub fn attr(&self) -> Option<IntAttr<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<IntAttr<'a>>>(IntSearchFilter::VT_ATTR, None)
  }
}

pub struct IntSearchFilterArgs<'a> {
    pub searchOperator: u8,
    pub attr: Option<flatbuffers::WIPOffset<IntAttr<'a >>>,
}
impl<'a> Default for IntSearchFilterArgs<'a> {
    #[inline]
    fn default() -> Self {
        IntSearchFilterArgs {
            searchOperator: 0,
            attr: None,
        }
    }
}
pub struct IntSearchFilterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntSearchFilterBuilder<'a, 'b> {
  #[inline]
  pub fn add_searchOperator(&mut self, searchOperator: u8) {
    self.fbb_.push_slot::<u8>(IntSearchFilter::VT_SEARCHOPERATOR, searchOperator, 0);
  }
  #[inline]
  pub fn add_attr(&mut self, attr: flatbuffers::WIPOffset<IntAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntAttr>>(IntSearchFilter::VT_ATTR, attr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntSearchFilterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IntSearchFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntSearchFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BinSearchFilterOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BinSearchFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinSearchFilter<'a> {
    type Inner = BinSearchFilter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BinSearchFilter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BinSearchFilter {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BinSearchFilterArgs<'args>) -> flatbuffers::WIPOffset<BinSearchFilter<'bldr>> {
      let mut builder = BinSearchFilterBuilder::new(_fbb);
      if let Some(x) = args.attr { builder.add_attr(x); }
      builder.add_searchOperator(args.searchOperator);
      builder.finish()
    }

    pub const VT_SEARCHOPERATOR: flatbuffers::VOffsetT = 4;
    pub const VT_ATTR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn searchOperator(&self) -> u8 {
    self._tab.get::<u8>(BinSearchFilter::VT_SEARCHOPERATOR, Some(0)).unwrap()
  }
  #[inline]
  pub fn attr(&self) -> Option<BinAttr<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BinAttr<'a>>>(BinSearchFilter::VT_ATTR, None)
  }
}

pub struct BinSearchFilterArgs<'a> {
    pub searchOperator: u8,
    pub attr: Option<flatbuffers::WIPOffset<BinAttr<'a >>>,
}
impl<'a> Default for BinSearchFilterArgs<'a> {
    #[inline]
    fn default() -> Self {
        BinSearchFilterArgs {
            searchOperator: 0,
            attr: None,
        }
    }
}
pub struct BinSearchFilterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BinSearchFilterBuilder<'a, 'b> {
  #[inline]
  pub fn add_searchOperator(&mut self, searchOperator: u8) {
    self.fbb_.push_slot::<u8>(BinSearchFilter::VT_SEARCHOPERATOR, searchOperator, 0);
  }
  #[inline]
  pub fn add_attr(&mut self, attr: flatbuffers::WIPOffset<BinAttr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinAttr>>(BinSearchFilter::VT_ATTR, attr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinSearchFilterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BinSearchFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinSearchFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PresenceOptionDataOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PresenceOptionData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PresenceOptionData<'a> {
    type Inner = PresenceOptionData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PresenceOptionData<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PresenceOptionData {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PresenceOptionDataArgs<'args>) -> flatbuffers::WIPOffset<PresenceOptionData<'bldr>> {
      let mut builder = PresenceOptionDataBuilder::new(_fbb);
      builder.add_len(args.len);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;
    pub const VT_LEN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PresenceOptionData::VT_DATA, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn len(&self) -> u32 {
    self._tab.get::<u32>(PresenceOptionData::VT_LEN, Some(0)).unwrap()
  }
}

pub struct PresenceOptionDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub len: u32,
}
impl<'a> Default for PresenceOptionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        PresenceOptionDataArgs {
            data: None,
            len: 0,
        }
    }
}
pub struct PresenceOptionDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PresenceOptionDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PresenceOptionData::VT_DATA, data);
  }
  #[inline]
  pub fn add_len(&mut self, len: u32) {
    self.fbb_.push_slot::<u32>(PresenceOptionData::VT_LEN, len, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PresenceOptionDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PresenceOptionDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PresenceOptionData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomGroupPasswordConfigOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomGroupPasswordConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomGroupPasswordConfig<'a> {
    type Inner = RoomGroupPasswordConfig<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomGroupPasswordConfig<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomGroupPasswordConfig {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomGroupPasswordConfigArgs<'args>) -> flatbuffers::WIPOffset<RoomGroupPasswordConfig<'bldr>> {
      let mut builder = RoomGroupPasswordConfigBuilder::new(_fbb);
      if let Some(x) = args.groupId { builder.add_groupId(x); }
      builder.add_withPassword(args.withPassword);
      builder.finish()
    }

    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_WITHPASSWORD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn groupId(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomGroupPasswordConfig::VT_GROUPID, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn withPassword(&self) -> bool {
    self._tab.get::<bool>(RoomGroupPasswordConfig::VT_WITHPASSWORD, Some(false)).unwrap()
  }
}

pub struct RoomGroupPasswordConfigArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub withPassword: bool,
}
impl<'a> Default for RoomGroupPasswordConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomGroupPasswordConfigArgs {
            groupId: None,
            withPassword: false,
        }
    }
}
pub struct RoomGroupPasswordConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomGroupPasswordConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomGroupPasswordConfig::VT_GROUPID, groupId);
  }
  #[inline]
  pub fn add_withPassword(&mut self, withPassword: bool) {
    self.fbb_.push_slot::<bool>(RoomGroupPasswordConfig::VT_WITHPASSWORD, withPassword, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomGroupPasswordConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomGroupPasswordConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomGroupPasswordConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SearchRoomRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SearchRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SearchRoomRequest<'a> {
    type Inner = SearchRoomRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SearchRoomRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SearchRoomRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SearchRoomRequestArgs<'args>) -> flatbuffers::WIPOffset<SearchRoomRequest<'bldr>> {
      let mut builder = SearchRoomRequestBuilder::new(_fbb);
      builder.add_lobbyId(args.lobbyId);
      if let Some(x) = args.attrId { builder.add_attrId(x); }
      if let Some(x) = args.binFilter { builder.add_binFilter(x); }
      if let Some(x) = args.intFilter { builder.add_intFilter(x); }
      builder.add_flagAttr(args.flagAttr);
      builder.add_flagFilter(args.flagFilter);
      builder.add_rangeFilter_max(args.rangeFilter_max);
      builder.add_rangeFilter_startIndex(args.rangeFilter_startIndex);
      builder.add_worldId(args.worldId);
      builder.add_option(args.option);
      builder.finish()
    }

    pub const VT_OPTION: flatbuffers::VOffsetT = 4;
    pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
    pub const VT_LOBBYID: flatbuffers::VOffsetT = 8;
    pub const VT_RANGEFILTER_STARTINDEX: flatbuffers::VOffsetT = 10;
    pub const VT_RANGEFILTER_MAX: flatbuffers::VOffsetT = 12;
    pub const VT_FLAGFILTER: flatbuffers::VOffsetT = 14;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 16;
    pub const VT_INTFILTER: flatbuffers::VOffsetT = 18;
    pub const VT_BINFILTER: flatbuffers::VOffsetT = 20;
    pub const VT_ATTRID: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn option(&self) -> i32 {
    self._tab.get::<i32>(SearchRoomRequest::VT_OPTION, Some(0)).unwrap()
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    self._tab.get::<u64>(SearchRoomRequest::VT_LOBBYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn rangeFilter_startIndex(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_RANGEFILTER_STARTINDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn rangeFilter_max(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_RANGEFILTER_MAX, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagFilter(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_FLAGFILTER, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomRequest::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn intFilter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntSearchFilter<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<IntSearchFilter<'a>>>>>(SearchRoomRequest::VT_INTFILTER, None)
  }
  #[inline]
  pub fn binFilter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinSearchFilter<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinSearchFilter<'a>>>>>(SearchRoomRequest::VT_BINFILTER, None)
  }
  #[inline]
  pub fn attrId(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SearchRoomRequest::VT_ATTRID, None)
  }
}

pub struct SearchRoomRequestArgs<'a> {
    pub option: i32,
    pub worldId: u32,
    pub lobbyId: u64,
    pub rangeFilter_startIndex: u32,
    pub rangeFilter_max: u32,
    pub flagFilter: u32,
    pub flagAttr: u32,
    pub intFilter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<IntSearchFilter<'a >>>>>,
    pub binFilter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinSearchFilter<'a >>>>>,
    pub attrId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u16>>>,
}
impl<'a> Default for SearchRoomRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SearchRoomRequestArgs {
            option: 0,
            worldId: 0,
            lobbyId: 0,
            rangeFilter_startIndex: 0,
            rangeFilter_max: 0,
            flagFilter: 0,
            flagAttr: 0,
            intFilter: None,
            binFilter: None,
            attrId: None,
        }
    }
}
pub struct SearchRoomRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SearchRoomRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_option(&mut self, option: i32) {
    self.fbb_.push_slot::<i32>(SearchRoomRequest::VT_OPTION, option, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(SearchRoomRequest::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_rangeFilter_startIndex(&mut self, rangeFilter_startIndex: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_RANGEFILTER_STARTINDEX, rangeFilter_startIndex, 0);
  }
  #[inline]
  pub fn add_rangeFilter_max(&mut self, rangeFilter_max: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_RANGEFILTER_MAX, rangeFilter_max, 0);
  }
  #[inline]
  pub fn add_flagFilter(&mut self, flagFilter: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_FLAGFILTER, flagFilter, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_intFilter(&mut self, intFilter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntSearchFilter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomRequest::VT_INTFILTER, intFilter);
  }
  #[inline]
  pub fn add_binFilter(&mut self, binFilter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinSearchFilter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomRequest::VT_BINFILTER, binFilter);
  }
  #[inline]
  pub fn add_attrId(&mut self, attrId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomRequest::VT_ATTRID, attrId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SearchRoomRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SearchRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SearchRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SearchRoomResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SearchRoomResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SearchRoomResponse<'a> {
    type Inner = SearchRoomResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SearchRoomResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SearchRoomResponse {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SearchRoomResponseArgs<'args>) -> flatbuffers::WIPOffset<SearchRoomResponse<'bldr>> {
      let mut builder = SearchRoomResponseBuilder::new(_fbb);
      if let Some(x) = args.rooms { builder.add_rooms(x); }
      builder.add_size_(args.size_);
      builder.add_total(args.total);
      builder.add_startIndex(args.startIndex);
      builder.finish()
    }

    pub const VT_STARTINDEX: flatbuffers::VOffsetT = 4;
    pub const VT_TOTAL: flatbuffers::VOffsetT = 6;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn startIndex(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomResponse::VT_STARTINDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn total(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomResponse::VT_TOTAL, Some(0)).unwrap()
  }
  #[inline]
  pub fn size_(&self) -> u32 {
    self._tab.get::<u32>(SearchRoomResponse::VT_SIZE_, Some(0)).unwrap()
  }
  #[inline]
  pub fn rooms(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomDataExternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RoomDataExternal<'a>>>>>(SearchRoomResponse::VT_ROOMS, None)
  }
}

pub struct SearchRoomResponseArgs<'a> {
    pub startIndex: u32,
    pub total: u32,
    pub size_: u32,
    pub rooms: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<RoomDataExternal<'a >>>>>,
}
impl<'a> Default for SearchRoomResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        SearchRoomResponseArgs {
            startIndex: 0,
            total: 0,
            size_: 0,
            rooms: None,
        }
    }
}
pub struct SearchRoomResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SearchRoomResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_startIndex(&mut self, startIndex: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomResponse::VT_STARTINDEX, startIndex, 0);
  }
  #[inline]
  pub fn add_total(&mut self, total: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomResponse::VT_TOTAL, total, 0);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: u32) {
    self.fbb_.push_slot::<u32>(SearchRoomResponse::VT_SIZE_, size_, 0);
  }
  #[inline]
  pub fn add_rooms(&mut self, rooms: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomDataExternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchRoomResponse::VT_ROOMS, rooms);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SearchRoomResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SearchRoomResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SearchRoomResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CreateJoinRoomRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CreateJoinRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateJoinRoomRequest<'a> {
    type Inner = CreateJoinRoomRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CreateJoinRoomRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CreateJoinRoomRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CreateJoinRoomRequestArgs<'args>) -> flatbuffers::WIPOffset<CreateJoinRoomRequest<'bldr>> {
      let mut builder = CreateJoinRoomRequestBuilder::new(_fbb);
      builder.add_passwordSlotMask(args.passwordSlotMask);
      builder.add_lobbyId(args.lobbyId);
      if let Some(x) = args.sigOptParam { builder.add_sigOptParam(x); }
      if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
      if let Some(x) = args.joinRoomGroupLabel { builder.add_joinRoomGroupLabel(x); }
      if let Some(x) = args.blockedUser { builder.add_blockedUser(x); }
      if let Some(x) = args.allowedUser { builder.add_allowedUser(x); }
      if let Some(x) = args.groupConfig { builder.add_groupConfig(x); }
      if let Some(x) = args.roomPassword { builder.add_roomPassword(x); }
      if let Some(x) = args.roomBinAttrExternal { builder.add_roomBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableBinAttrExternal { builder.add_roomSearchableBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableIntAttrExternal { builder.add_roomSearchableIntAttrExternal(x); }
      if let Some(x) = args.roomBinAttrInternal { builder.add_roomBinAttrInternal(x); }
      builder.add_flagAttr(args.flagAttr);
      builder.add_maxSlot(args.maxSlot);
      builder.add_worldId(args.worldId);
      builder.add_teamId(args.teamId);
      builder.finish()
    }

    pub const VT_WORLDID: flatbuffers::VOffsetT = 4;
    pub const VT_LOBBYID: flatbuffers::VOffsetT = 6;
    pub const VT_MAXSLOT: flatbuffers::VOffsetT = 8;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 10;
    pub const VT_ROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 12;
    pub const VT_ROOMSEARCHABLEINTATTREXTERNAL: flatbuffers::VOffsetT = 14;
    pub const VT_ROOMSEARCHABLEBINATTREXTERNAL: flatbuffers::VOffsetT = 16;
    pub const VT_ROOMBINATTREXTERNAL: flatbuffers::VOffsetT = 18;
    pub const VT_ROOMPASSWORD: flatbuffers::VOffsetT = 20;
    pub const VT_GROUPCONFIG: flatbuffers::VOffsetT = 22;
    pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 24;
    pub const VT_ALLOWEDUSER: flatbuffers::VOffsetT = 26;
    pub const VT_BLOCKEDUSER: flatbuffers::VOffsetT = 28;
    pub const VT_JOINROOMGROUPLABEL: flatbuffers::VOffsetT = 30;
    pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 32;
    pub const VT_TEAMID: flatbuffers::VOffsetT = 34;
    pub const VT_SIGOPTPARAM: flatbuffers::VOffsetT = 36;

  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(CreateJoinRoomRequest::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn lobbyId(&self) -> u64 {
    self._tab.get::<u64>(CreateJoinRoomRequest::VT_LOBBYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn maxSlot(&self) -> u32 {
    self._tab.get::<u32>(CreateJoinRoomRequest::VT_MAXSLOT, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(CreateJoinRoomRequest::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(CreateJoinRoomRequest::VT_ROOMBINATTRINTERNAL, None)
  }
  #[inline]
  pub fn roomSearchableIntAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<IntAttr<'a>>>>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomSearchableBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(CreateJoinRoomRequest::VT_ROOMBINATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomPassword(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CreateJoinRoomRequest::VT_ROOMPASSWORD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn groupConfig(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GroupConfig<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<GroupConfig<'a>>>>>(CreateJoinRoomRequest::VT_GROUPCONFIG, None)
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(CreateJoinRoomRequest::VT_PASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn allowedUser(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(CreateJoinRoomRequest::VT_ALLOWEDUSER, None)
  }
  #[inline]
  pub fn blockedUser(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(CreateJoinRoomRequest::VT_BLOCKEDUSER, None)
  }
  #[inline]
  pub fn joinRoomGroupLabel(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CreateJoinRoomRequest::VT_JOINROOMGROUPLABEL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(CreateJoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, None)
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    self._tab.get::<u8>(CreateJoinRoomRequest::VT_TEAMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn sigOptParam(&self) -> Option<OptParam<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<OptParam<'a>>>(CreateJoinRoomRequest::VT_SIGOPTPARAM, None)
  }
}

pub struct CreateJoinRoomRequestArgs<'a> {
    pub worldId: u32,
    pub lobbyId: u64,
    pub maxSlot: u32,
    pub flagAttr: u32,
    pub roomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
    pub roomSearchableIntAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<IntAttr<'a >>>>>,
    pub roomSearchableBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
    pub roomBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
    pub roomPassword: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub groupConfig: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<GroupConfig<'a >>>>>,
    pub passwordSlotMask: u64,
    pub allowedUser: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub blockedUser: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub joinRoomGroupLabel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
    pub teamId: u8,
    pub sigOptParam: Option<flatbuffers::WIPOffset<OptParam<'a >>>,
}
impl<'a> Default for CreateJoinRoomRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        CreateJoinRoomRequestArgs {
            worldId: 0,
            lobbyId: 0,
            maxSlot: 0,
            flagAttr: 0,
            roomBinAttrInternal: None,
            roomSearchableIntAttrExternal: None,
            roomSearchableBinAttrExternal: None,
            roomBinAttrExternal: None,
            roomPassword: None,
            groupConfig: None,
            passwordSlotMask: 0,
            allowedUser: None,
            blockedUser: None,
            joinRoomGroupLabel: None,
            roomMemberBinAttrInternal: None,
            teamId: 0,
            sigOptParam: None,
        }
    }
}
pub struct CreateJoinRoomRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CreateJoinRoomRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(CreateJoinRoomRequest::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_lobbyId(&mut self, lobbyId: u64) {
    self.fbb_.push_slot::<u64>(CreateJoinRoomRequest::VT_LOBBYID, lobbyId, 0);
  }
  #[inline]
  pub fn add_maxSlot(&mut self, maxSlot: u32) {
    self.fbb_.push_slot::<u32>(CreateJoinRoomRequest::VT_MAXSLOT, maxSlot, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(CreateJoinRoomRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomBinAttrInternal(&mut self, roomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMBINATTRINTERNAL, roomBinAttrInternal);
  }
  #[inline]
  pub fn add_roomSearchableIntAttrExternal(&mut self, roomSearchableIntAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, roomSearchableIntAttrExternal);
  }
  #[inline]
  pub fn add_roomSearchableBinAttrExternal(&mut self, roomSearchableBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, roomSearchableBinAttrExternal);
  }
  #[inline]
  pub fn add_roomBinAttrExternal(&mut self, roomBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMBINATTREXTERNAL, roomBinAttrExternal);
  }
  #[inline]
  pub fn add_roomPassword(&mut self, roomPassword: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMPASSWORD, roomPassword);
  }
  #[inline]
  pub fn add_groupConfig(&mut self, groupConfig: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GroupConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_GROUPCONFIG, groupConfig);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(CreateJoinRoomRequest::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_allowedUser(&mut self, allowedUser: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ALLOWEDUSER, allowedUser);
  }
  #[inline]
  pub fn add_blockedUser(&mut self, blockedUser: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_BLOCKEDUSER, blockedUser);
  }
  #[inline]
  pub fn add_joinRoomGroupLabel(&mut self, joinRoomGroupLabel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_JOINROOMGROUPLABEL, joinRoomGroupLabel);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateJoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(CreateJoinRoomRequest::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn add_sigOptParam(&mut self, sigOptParam: flatbuffers::WIPOffset<OptParam<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<OptParam>>(CreateJoinRoomRequest::VT_SIGOPTPARAM, sigOptParam);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CreateJoinRoomRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CreateJoinRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateJoinRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum JoinRoomRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct JoinRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for JoinRoomRequest<'a> {
    type Inner = JoinRoomRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> JoinRoomRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        JoinRoomRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args JoinRoomRequestArgs<'args>) -> flatbuffers::WIPOffset<JoinRoomRequest<'bldr>> {
      let mut builder = JoinRoomRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.optData { builder.add_optData(x); }
      if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
      if let Some(x) = args.joinRoomGroupLabel { builder.add_joinRoomGroupLabel(x); }
      if let Some(x) = args.roomPassword { builder.add_roomPassword(x); }
      builder.add_teamId(args.teamId);
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_ROOMPASSWORD: flatbuffers::VOffsetT = 6;
    pub const VT_JOINROOMGROUPLABEL: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 10;
    pub const VT_OPTDATA: flatbuffers::VOffsetT = 12;
    pub const VT_TEAMID: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(JoinRoomRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomPassword(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(JoinRoomRequest::VT_ROOMPASSWORD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn joinRoomGroupLabel(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(JoinRoomRequest::VT_JOINROOMGROUPLABEL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(JoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, None)
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData<'a>>>(JoinRoomRequest::VT_OPTDATA, None)
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    self._tab.get::<u8>(JoinRoomRequest::VT_TEAMID, Some(0)).unwrap()
  }
}

pub struct JoinRoomRequestArgs<'a> {
    pub roomId: u64,
    pub roomPassword: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub joinRoomGroupLabel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a >>>,
    pub teamId: u8,
}
impl<'a> Default for JoinRoomRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        JoinRoomRequestArgs {
            roomId: 0,
            roomPassword: None,
            joinRoomGroupLabel: None,
            roomMemberBinAttrInternal: None,
            optData: None,
            teamId: 0,
        }
    }
}
pub struct JoinRoomRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> JoinRoomRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(JoinRoomRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_roomPassword(&mut self, roomPassword: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JoinRoomRequest::VT_ROOMPASSWORD, roomPassword);
  }
  #[inline]
  pub fn add_joinRoomGroupLabel(&mut self, joinRoomGroupLabel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JoinRoomRequest::VT_JOINROOMGROUPLABEL, joinRoomGroupLabel);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JoinRoomRequest::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(JoinRoomRequest::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(JoinRoomRequest::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> JoinRoomRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    JoinRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<JoinRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum LeaveRoomRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct LeaveRoomRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeaveRoomRequest<'a> {
    type Inner = LeaveRoomRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> LeaveRoomRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LeaveRoomRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LeaveRoomRequestArgs<'args>) -> flatbuffers::WIPOffset<LeaveRoomRequest<'bldr>> {
      let mut builder = LeaveRoomRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.optData { builder.add_optData(x); }
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_OPTDATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(LeaveRoomRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData<'a>>>(LeaveRoomRequest::VT_OPTDATA, None)
  }
}

pub struct LeaveRoomRequestArgs<'a> {
    pub roomId: u64,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a >>>,
}
impl<'a> Default for LeaveRoomRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        LeaveRoomRequestArgs {
            roomId: 0,
            optData: None,
        }
    }
}
pub struct LeaveRoomRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LeaveRoomRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(LeaveRoomRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(LeaveRoomRequest::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LeaveRoomRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LeaveRoomRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeaveRoomRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SetRoomDataExternalRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SetRoomDataExternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetRoomDataExternalRequest<'a> {
    type Inner = SetRoomDataExternalRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SetRoomDataExternalRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetRoomDataExternalRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetRoomDataExternalRequestArgs<'args>) -> flatbuffers::WIPOffset<SetRoomDataExternalRequest<'bldr>> {
      let mut builder = SetRoomDataExternalRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.roomBinAttrExternal { builder.add_roomBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableBinAttrExternal { builder.add_roomSearchableBinAttrExternal(x); }
      if let Some(x) = args.roomSearchableIntAttrExternal { builder.add_roomSearchableIntAttrExternal(x); }
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_ROOMSEARCHABLEINTATTREXTERNAL: flatbuffers::VOffsetT = 6;
    pub const VT_ROOMSEARCHABLEBINATTREXTERNAL: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMBINATTREXTERNAL: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(SetRoomDataExternalRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomSearchableIntAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<IntAttr<'a>>>>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomSearchableBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, None)
  }
  #[inline]
  pub fn roomBinAttrExternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(SetRoomDataExternalRequest::VT_ROOMBINATTREXTERNAL, None)
  }
}

pub struct SetRoomDataExternalRequestArgs<'a> {
    pub roomId: u64,
    pub roomSearchableIntAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<IntAttr<'a >>>>>,
    pub roomSearchableBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
    pub roomBinAttrExternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
}
impl<'a> Default for SetRoomDataExternalRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetRoomDataExternalRequestArgs {
            roomId: 0,
            roomSearchableIntAttrExternal: None,
            roomSearchableBinAttrExternal: None,
            roomBinAttrExternal: None,
        }
    }
}
pub struct SetRoomDataExternalRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetRoomDataExternalRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SetRoomDataExternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_roomSearchableIntAttrExternal(&mut self, roomSearchableIntAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEINTATTREXTERNAL, roomSearchableIntAttrExternal);
  }
  #[inline]
  pub fn add_roomSearchableBinAttrExternal(&mut self, roomSearchableBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataExternalRequest::VT_ROOMSEARCHABLEBINATTREXTERNAL, roomSearchableBinAttrExternal);
  }
  #[inline]
  pub fn add_roomBinAttrExternal(&mut self, roomBinAttrExternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataExternalRequest::VT_ROOMBINATTREXTERNAL, roomBinAttrExternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetRoomDataExternalRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SetRoomDataExternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetRoomDataExternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SetRoomDataInternalRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SetRoomDataInternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetRoomDataInternalRequest<'a> {
    type Inner = SetRoomDataInternalRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SetRoomDataInternalRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetRoomDataInternalRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetRoomDataInternalRequestArgs<'args>) -> flatbuffers::WIPOffset<SetRoomDataInternalRequest<'bldr>> {
      let mut builder = SetRoomDataInternalRequestBuilder::new(_fbb);
      builder.add_passwordSlotMask(args.passwordSlotMask);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.ownerPrivilegeRank { builder.add_ownerPrivilegeRank(x); }
      if let Some(x) = args.passwordConfig { builder.add_passwordConfig(x); }
      if let Some(x) = args.roomBinAttrInternal { builder.add_roomBinAttrInternal(x); }
      builder.add_flagAttr(args.flagAttr);
      builder.add_flagFilter(args.flagFilter);
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_FLAGFILTER: flatbuffers::VOffsetT = 6;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 8;
    pub const VT_ROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 10;
    pub const VT_PASSWORDCONFIG: flatbuffers::VOffsetT = 12;
    pub const VT_PASSWORDSLOTMASK: flatbuffers::VOffsetT = 14;
    pub const VT_OWNERPRIVILEGERANK: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(SetRoomDataInternalRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagFilter(&self) -> u32 {
    self._tab.get::<u32>(SetRoomDataInternalRequest::VT_FLAGFILTER, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(SetRoomDataInternalRequest::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(SetRoomDataInternalRequest::VT_ROOMBINATTRINTERNAL, None)
  }
  #[inline]
  pub fn passwordConfig(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'a>>>>>(SetRoomDataInternalRequest::VT_PASSWORDCONFIG, None)
  }
  #[inline]
  pub fn passwordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(SetRoomDataInternalRequest::VT_PASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn ownerPrivilegeRank(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SetRoomDataInternalRequest::VT_OWNERPRIVILEGERANK, None)
  }
}

pub struct SetRoomDataInternalRequestArgs<'a> {
    pub roomId: u64,
    pub flagFilter: u32,
    pub flagAttr: u32,
    pub roomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
    pub passwordConfig: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'a >>>>>,
    pub passwordSlotMask: u64,
    pub ownerPrivilegeRank: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u16>>>,
}
impl<'a> Default for SetRoomDataInternalRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetRoomDataInternalRequestArgs {
            roomId: 0,
            flagFilter: 0,
            flagAttr: 0,
            roomBinAttrInternal: None,
            passwordConfig: None,
            passwordSlotMask: 0,
            ownerPrivilegeRank: None,
        }
    }
}
pub struct SetRoomDataInternalRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetRoomDataInternalRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SetRoomDataInternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_flagFilter(&mut self, flagFilter: u32) {
    self.fbb_.push_slot::<u32>(SetRoomDataInternalRequest::VT_FLAGFILTER, flagFilter, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(SetRoomDataInternalRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomBinAttrInternal(&mut self, roomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataInternalRequest::VT_ROOMBINATTRINTERNAL, roomBinAttrInternal);
  }
  #[inline]
  pub fn add_passwordConfig(&mut self, passwordConfig: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroupPasswordConfig<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataInternalRequest::VT_PASSWORDCONFIG, passwordConfig);
  }
  #[inline]
  pub fn add_passwordSlotMask(&mut self, passwordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(SetRoomDataInternalRequest::VT_PASSWORDSLOTMASK, passwordSlotMask, 0);
  }
  #[inline]
  pub fn add_ownerPrivilegeRank(&mut self, ownerPrivilegeRank: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomDataInternalRequest::VT_OWNERPRIVILEGERANK, ownerPrivilegeRank);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetRoomDataInternalRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SetRoomDataInternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetRoomDataInternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SetRoomMemberDataInternalRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SetRoomMemberDataInternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetRoomMemberDataInternalRequest<'a> {
    type Inner = SetRoomMemberDataInternalRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SetRoomMemberDataInternalRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetRoomMemberDataInternalRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetRoomMemberDataInternalRequestArgs<'args>) -> flatbuffers::WIPOffset<SetRoomMemberDataInternalRequest<'bldr>> {
      let mut builder = SetRoomMemberDataInternalRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.roomMemberBinAttrInternal { builder.add_roomMemberBinAttrInternal(x); }
      builder.add_flagAttr(args.flagAttr);
      builder.add_flagFilter(args.flagFilter);
      builder.add_memberId(args.memberId);
      builder.add_teamId(args.teamId);
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_MEMBERID: flatbuffers::VOffsetT = 6;
    pub const VT_TEAMID: flatbuffers::VOffsetT = 8;
    pub const VT_FLAGFILTER: flatbuffers::VOffsetT = 10;
    pub const VT_FLAGATTR: flatbuffers::VOffsetT = 12;
    pub const VT_ROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(SetRoomMemberDataInternalRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn memberId(&self) -> u16 {
    self._tab.get::<u16>(SetRoomMemberDataInternalRequest::VT_MEMBERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn teamId(&self) -> u8 {
    self._tab.get::<u8>(SetRoomMemberDataInternalRequest::VT_TEAMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagFilter(&self) -> u32 {
    self._tab.get::<u32>(SetRoomMemberDataInternalRequest::VT_FLAGFILTER, Some(0)).unwrap()
  }
  #[inline]
  pub fn flagAttr(&self) -> u32 {
    self._tab.get::<u32>(SetRoomMemberDataInternalRequest::VT_FLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttr<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttr<'a>>>>>(SetRoomMemberDataInternalRequest::VT_ROOMMEMBERBINATTRINTERNAL, None)
  }
}

pub struct SetRoomMemberDataInternalRequestArgs<'a> {
    pub roomId: u64,
    pub memberId: u16,
    pub teamId: u8,
    pub flagFilter: u32,
    pub flagAttr: u32,
    pub roomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttr<'a >>>>>,
}
impl<'a> Default for SetRoomMemberDataInternalRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetRoomMemberDataInternalRequestArgs {
            roomId: 0,
            memberId: 0,
            teamId: 0,
            flagFilter: 0,
            flagAttr: 0,
            roomMemberBinAttrInternal: None,
        }
    }
}
pub struct SetRoomMemberDataInternalRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetRoomMemberDataInternalRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SetRoomMemberDataInternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_memberId(&mut self, memberId: u16) {
    self.fbb_.push_slot::<u16>(SetRoomMemberDataInternalRequest::VT_MEMBERID, memberId, 0);
  }
  #[inline]
  pub fn add_teamId(&mut self, teamId: u8) {
    self.fbb_.push_slot::<u8>(SetRoomMemberDataInternalRequest::VT_TEAMID, teamId, 0);
  }
  #[inline]
  pub fn add_flagFilter(&mut self, flagFilter: u32) {
    self.fbb_.push_slot::<u32>(SetRoomMemberDataInternalRequest::VT_FLAGFILTER, flagFilter, 0);
  }
  #[inline]
  pub fn add_flagAttr(&mut self, flagAttr: u32) {
    self.fbb_.push_slot::<u32>(SetRoomMemberDataInternalRequest::VT_FLAGATTR, flagAttr, 0);
  }
  #[inline]
  pub fn add_roomMemberBinAttrInternal(&mut self, roomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetRoomMemberDataInternalRequest::VT_ROOMMEMBERBINATTRINTERNAL, roomMemberBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetRoomMemberDataInternalRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SetRoomMemberDataInternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetRoomMemberDataInternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetRoomDataInternalRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetRoomDataInternalRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRoomDataInternalRequest<'a> {
    type Inner = GetRoomDataInternalRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetRoomDataInternalRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetRoomDataInternalRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetRoomDataInternalRequestArgs<'args>) -> flatbuffers::WIPOffset<GetRoomDataInternalRequest<'bldr>> {
      let mut builder = GetRoomDataInternalRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.attrId { builder.add_attrId(x); }
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(GetRoomDataInternalRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn attrId(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(GetRoomDataInternalRequest::VT_ATTRID, None)
  }
}

pub struct GetRoomDataInternalRequestArgs<'a> {
    pub roomId: u64,
    pub attrId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u16>>>,
}
impl<'a> Default for GetRoomDataInternalRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetRoomDataInternalRequestArgs {
            roomId: 0,
            attrId: None,
        }
    }
}
pub struct GetRoomDataInternalRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetRoomDataInternalRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(GetRoomDataInternalRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_attrId(&mut self, attrId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRoomDataInternalRequest::VT_ATTRID, attrId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetRoomDataInternalRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetRoomDataInternalRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRoomDataInternalRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomMemberUpdateInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomMemberUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMemberUpdateInfo<'a> {
    type Inner = RoomMemberUpdateInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomMemberUpdateInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomMemberUpdateInfo {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomMemberUpdateInfoArgs<'args>) -> flatbuffers::WIPOffset<RoomMemberUpdateInfo<'bldr>> {
      let mut builder = RoomMemberUpdateInfoBuilder::new(_fbb);
      if let Some(x) = args.optData { builder.add_optData(x); }
      if let Some(x) = args.roomMemberDataInternal { builder.add_roomMemberDataInternal(x); }
      builder.add_eventCause(args.eventCause);
      builder.finish()
    }

    pub const VT_ROOMMEMBERDATAINTERNAL: flatbuffers::VOffsetT = 4;
    pub const VT_EVENTCAUSE: flatbuffers::VOffsetT = 6;
    pub const VT_OPTDATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn roomMemberDataInternal(&self) -> Option<RoomMemberDataInternal<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'a>>>(RoomMemberUpdateInfo::VT_ROOMMEMBERDATAINTERNAL, None)
  }
  #[inline]
  pub fn eventCause(&self) -> u8 {
    self._tab.get::<u8>(RoomMemberUpdateInfo::VT_EVENTCAUSE, Some(0)).unwrap()
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData<'a>>>(RoomMemberUpdateInfo::VT_OPTDATA, None)
  }
}

pub struct RoomMemberUpdateInfoArgs<'a> {
    pub roomMemberDataInternal: Option<flatbuffers::WIPOffset<RoomMemberDataInternal<'a >>>,
    pub eventCause: u8,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a >>>,
}
impl<'a> Default for RoomMemberUpdateInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomMemberUpdateInfoArgs {
            roomMemberDataInternal: None,
            eventCause: 0,
            optData: None,
        }
    }
}
pub struct RoomMemberUpdateInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomMemberUpdateInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomMemberDataInternal(&mut self, roomMemberDataInternal: flatbuffers::WIPOffset<RoomMemberDataInternal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RoomMemberDataInternal>>(RoomMemberUpdateInfo::VT_ROOMMEMBERDATAINTERNAL, roomMemberDataInternal);
  }
  #[inline]
  pub fn add_eventCause(&mut self, eventCause: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberUpdateInfo::VT_EVENTCAUSE, eventCause, 0);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(RoomMemberUpdateInfo::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomMemberUpdateInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomMemberUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMemberUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomUpdateInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomUpdateInfo<'a> {
    type Inner = RoomUpdateInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomUpdateInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomUpdateInfo {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomUpdateInfoArgs<'args>) -> flatbuffers::WIPOffset<RoomUpdateInfo<'bldr>> {
      let mut builder = RoomUpdateInfoBuilder::new(_fbb);
      if let Some(x) = args.optData { builder.add_optData(x); }
      builder.add_errorCode(args.errorCode);
      builder.add_eventCause(args.eventCause);
      builder.finish()
    }

    pub const VT_EVENTCAUSE: flatbuffers::VOffsetT = 4;
    pub const VT_ERRORCODE: flatbuffers::VOffsetT = 6;
    pub const VT_OPTDATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn eventCause(&self) -> u8 {
    self._tab.get::<u8>(RoomUpdateInfo::VT_EVENTCAUSE, Some(0)).unwrap()
  }
  #[inline]
  pub fn errorCode(&self) -> i32 {
    self._tab.get::<i32>(RoomUpdateInfo::VT_ERRORCODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn optData(&self) -> Option<PresenceOptionData<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PresenceOptionData<'a>>>(RoomUpdateInfo::VT_OPTDATA, None)
  }
}

pub struct RoomUpdateInfoArgs<'a> {
    pub eventCause: u8,
    pub errorCode: i32,
    pub optData: Option<flatbuffers::WIPOffset<PresenceOptionData<'a >>>,
}
impl<'a> Default for RoomUpdateInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomUpdateInfoArgs {
            eventCause: 0,
            errorCode: 0,
            optData: None,
        }
    }
}
pub struct RoomUpdateInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomUpdateInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_eventCause(&mut self, eventCause: u8) {
    self.fbb_.push_slot::<u8>(RoomUpdateInfo::VT_EVENTCAUSE, eventCause, 0);
  }
  #[inline]
  pub fn add_errorCode(&mut self, errorCode: i32) {
    self.fbb_.push_slot::<i32>(RoomUpdateInfo::VT_ERRORCODE, errorCode, 0);
  }
  #[inline]
  pub fn add_optData(&mut self, optData: flatbuffers::WIPOffset<PresenceOptionData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PresenceOptionData>>(RoomUpdateInfo::VT_OPTDATA, optData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomUpdateInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomDataInternalUpdateInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomDataInternalUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomDataInternalUpdateInfo<'a> {
    type Inner = RoomDataInternalUpdateInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomDataInternalUpdateInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomDataInternalUpdateInfo {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomDataInternalUpdateInfoArgs<'args>) -> flatbuffers::WIPOffset<RoomDataInternalUpdateInfo<'bldr>> {
      let mut builder = RoomDataInternalUpdateInfoBuilder::new(_fbb);
      builder.add_prevRoomPasswordSlotMask(args.prevRoomPasswordSlotMask);
      builder.add_newRoomPasswordSlotMask(args.newRoomPasswordSlotMask);
      if let Some(x) = args.newRoomBinAttrInternal { builder.add_newRoomBinAttrInternal(x); }
      if let Some(x) = args.newRoomGroup { builder.add_newRoomGroup(x); }
      builder.add_prevFlagAttr(args.prevFlagAttr);
      builder.add_newFlagAttr(args.newFlagAttr);
      if let Some(x) = args.newRoomDataInternal { builder.add_newRoomDataInternal(x); }
      builder.finish()
    }

    pub const VT_NEWROOMDATAINTERNAL: flatbuffers::VOffsetT = 4;
    pub const VT_NEWFLAGATTR: flatbuffers::VOffsetT = 6;
    pub const VT_PREVFLAGATTR: flatbuffers::VOffsetT = 8;
    pub const VT_NEWROOMPASSWORDSLOTMASK: flatbuffers::VOffsetT = 10;
    pub const VT_PREVROOMPASSWORDSLOTMASK: flatbuffers::VOffsetT = 12;
    pub const VT_NEWROOMGROUP: flatbuffers::VOffsetT = 14;
    pub const VT_NEWROOMBINATTRINTERNAL: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn newRoomDataInternal(&self) -> Option<RoomDataInternal<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<RoomDataInternal<'a>>>(RoomDataInternalUpdateInfo::VT_NEWROOMDATAINTERNAL, None)
  }
  #[inline]
  pub fn newFlagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomDataInternalUpdateInfo::VT_NEWFLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn prevFlagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomDataInternalUpdateInfo::VT_PREVFLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn newRoomPasswordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(RoomDataInternalUpdateInfo::VT_NEWROOMPASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn prevRoomPasswordSlotMask(&self) -> u64 {
    self._tab.get::<u64>(RoomDataInternalUpdateInfo::VT_PREVROOMPASSWORDSLOTMASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn newRoomGroup(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RoomGroup<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RoomGroup<'a>>>>>(RoomDataInternalUpdateInfo::VT_NEWROOMGROUP, None)
  }
  #[inline]
  pub fn newRoomBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinAttrInternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BinAttrInternal<'a>>>>>(RoomDataInternalUpdateInfo::VT_NEWROOMBINATTRINTERNAL, None)
  }
}

pub struct RoomDataInternalUpdateInfoArgs<'a> {
    pub newRoomDataInternal: Option<flatbuffers::WIPOffset<RoomDataInternal<'a >>>,
    pub newFlagAttr: u32,
    pub prevFlagAttr: u32,
    pub newRoomPasswordSlotMask: u64,
    pub prevRoomPasswordSlotMask: u64,
    pub newRoomGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<RoomGroup<'a >>>>>,
    pub newRoomBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<BinAttrInternal<'a >>>>>,
}
impl<'a> Default for RoomDataInternalUpdateInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomDataInternalUpdateInfoArgs {
            newRoomDataInternal: None,
            newFlagAttr: 0,
            prevFlagAttr: 0,
            newRoomPasswordSlotMask: 0,
            prevRoomPasswordSlotMask: 0,
            newRoomGroup: None,
            newRoomBinAttrInternal: None,
        }
    }
}
pub struct RoomDataInternalUpdateInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomDataInternalUpdateInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_newRoomDataInternal(&mut self, newRoomDataInternal: flatbuffers::WIPOffset<RoomDataInternal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RoomDataInternal>>(RoomDataInternalUpdateInfo::VT_NEWROOMDATAINTERNAL, newRoomDataInternal);
  }
  #[inline]
  pub fn add_newFlagAttr(&mut self, newFlagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternalUpdateInfo::VT_NEWFLAGATTR, newFlagAttr, 0);
  }
  #[inline]
  pub fn add_prevFlagAttr(&mut self, prevFlagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomDataInternalUpdateInfo::VT_PREVFLAGATTR, prevFlagAttr, 0);
  }
  #[inline]
  pub fn add_newRoomPasswordSlotMask(&mut self, newRoomPasswordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternalUpdateInfo::VT_NEWROOMPASSWORDSLOTMASK, newRoomPasswordSlotMask, 0);
  }
  #[inline]
  pub fn add_prevRoomPasswordSlotMask(&mut self, prevRoomPasswordSlotMask: u64) {
    self.fbb_.push_slot::<u64>(RoomDataInternalUpdateInfo::VT_PREVROOMPASSWORDSLOTMASK, prevRoomPasswordSlotMask, 0);
  }
  #[inline]
  pub fn add_newRoomGroup(&mut self, newRoomGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RoomGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternalUpdateInfo::VT_NEWROOMGROUP, newRoomGroup);
  }
  #[inline]
  pub fn add_newRoomBinAttrInternal(&mut self, newRoomBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinAttrInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomDataInternalUpdateInfo::VT_NEWROOMBINATTRINTERNAL, newRoomBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomDataInternalUpdateInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomDataInternalUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomDataInternalUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomMemberDataInternalUpdateInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomMemberDataInternalUpdateInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMemberDataInternalUpdateInfo<'a> {
    type Inner = RoomMemberDataInternalUpdateInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomMemberDataInternalUpdateInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomMemberDataInternalUpdateInfo {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomMemberDataInternalUpdateInfoArgs<'args>) -> flatbuffers::WIPOffset<RoomMemberDataInternalUpdateInfo<'bldr>> {
      let mut builder = RoomMemberDataInternalUpdateInfoBuilder::new(_fbb);
      if let Some(x) = args.newRoomMemberBinAttrInternal { builder.add_newRoomMemberBinAttrInternal(x); }
      builder.add_prevFlagAttr(args.prevFlagAttr);
      builder.add_newFlagAttr(args.newFlagAttr);
      if let Some(x) = args.newRoomMemberDataInternal { builder.add_newRoomMemberDataInternal(x); }
      builder.add_newTeamId(args.newTeamId);
      builder.finish()
    }

    pub const VT_NEWROOMMEMBERDATAINTERNAL: flatbuffers::VOffsetT = 4;
    pub const VT_NEWFLAGATTR: flatbuffers::VOffsetT = 6;
    pub const VT_PREVFLAGATTR: flatbuffers::VOffsetT = 8;
    pub const VT_NEWTEAMID: flatbuffers::VOffsetT = 10;
    pub const VT_NEWROOMMEMBERBINATTRINTERNAL: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn newRoomMemberDataInternal(&self) -> Option<RoomMemberDataInternal<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<RoomMemberDataInternal<'a>>>(RoomMemberDataInternalUpdateInfo::VT_NEWROOMMEMBERDATAINTERNAL, None)
  }
  #[inline]
  pub fn newFlagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomMemberDataInternalUpdateInfo::VT_NEWFLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn prevFlagAttr(&self) -> u32 {
    self._tab.get::<u32>(RoomMemberDataInternalUpdateInfo::VT_PREVFLAGATTR, Some(0)).unwrap()
  }
  #[inline]
  pub fn newTeamId(&self) -> u8 {
    self._tab.get::<u8>(RoomMemberDataInternalUpdateInfo::VT_NEWTEAMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn newRoomMemberBinAttrInternal(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'a>>>>>(RoomMemberDataInternalUpdateInfo::VT_NEWROOMMEMBERBINATTRINTERNAL, None)
  }
}

pub struct RoomMemberDataInternalUpdateInfoArgs<'a> {
    pub newRoomMemberDataInternal: Option<flatbuffers::WIPOffset<RoomMemberDataInternal<'a >>>,
    pub newFlagAttr: u32,
    pub prevFlagAttr: u32,
    pub newTeamId: u8,
    pub newRoomMemberBinAttrInternal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'a >>>>>,
}
impl<'a> Default for RoomMemberDataInternalUpdateInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomMemberDataInternalUpdateInfoArgs {
            newRoomMemberDataInternal: None,
            newFlagAttr: 0,
            prevFlagAttr: 0,
            newTeamId: 0,
            newRoomMemberBinAttrInternal: None,
        }
    }
}
pub struct RoomMemberDataInternalUpdateInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomMemberDataInternalUpdateInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_newRoomMemberDataInternal(&mut self, newRoomMemberDataInternal: flatbuffers::WIPOffset<RoomMemberDataInternal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RoomMemberDataInternal>>(RoomMemberDataInternalUpdateInfo::VT_NEWROOMMEMBERDATAINTERNAL, newRoomMemberDataInternal);
  }
  #[inline]
  pub fn add_newFlagAttr(&mut self, newFlagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomMemberDataInternalUpdateInfo::VT_NEWFLAGATTR, newFlagAttr, 0);
  }
  #[inline]
  pub fn add_prevFlagAttr(&mut self, prevFlagAttr: u32) {
    self.fbb_.push_slot::<u32>(RoomMemberDataInternalUpdateInfo::VT_PREVFLAGATTR, prevFlagAttr, 0);
  }
  #[inline]
  pub fn add_newTeamId(&mut self, newTeamId: u8) {
    self.fbb_.push_slot::<u8>(RoomMemberDataInternalUpdateInfo::VT_NEWTEAMID, newTeamId, 0);
  }
  #[inline]
  pub fn add_newRoomMemberBinAttrInternal(&mut self, newRoomMemberBinAttrInternal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MemberBinAttrInternal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMemberDataInternalUpdateInfo::VT_NEWROOMMEMBERBINATTRINTERNAL, newRoomMemberBinAttrInternal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomMemberDataInternalUpdateInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomMemberDataInternalUpdateInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMemberDataInternalUpdateInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetPingInfoResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetPingInfoResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPingInfoResponse<'a> {
    type Inner = GetPingInfoResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetPingInfoResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetPingInfoResponse {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetPingInfoResponseArgs) -> flatbuffers::WIPOffset<GetPingInfoResponse<'bldr>> {
      let mut builder = GetPingInfoResponseBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      builder.add_rtt(args.rtt);
      builder.add_worldId(args.worldId);
      builder.add_serverId(args.serverId);
      builder.finish()
    }

    pub const VT_SERVERID: flatbuffers::VOffsetT = 4;
    pub const VT_WORLDID: flatbuffers::VOffsetT = 6;
    pub const VT_ROOMID: flatbuffers::VOffsetT = 8;
    pub const VT_RTT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn serverId(&self) -> u16 {
    self._tab.get::<u16>(GetPingInfoResponse::VT_SERVERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn worldId(&self) -> u32 {
    self._tab.get::<u32>(GetPingInfoResponse::VT_WORLDID, Some(0)).unwrap()
  }
  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(GetPingInfoResponse::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn rtt(&self) -> u32 {
    self._tab.get::<u32>(GetPingInfoResponse::VT_RTT, Some(0)).unwrap()
  }
}

pub struct GetPingInfoResponseArgs {
    pub serverId: u16,
    pub worldId: u32,
    pub roomId: u64,
    pub rtt: u32,
}
impl<'a> Default for GetPingInfoResponseArgs {
    #[inline]
    fn default() -> Self {
        GetPingInfoResponseArgs {
            serverId: 0,
            worldId: 0,
            roomId: 0,
            rtt: 0,
        }
    }
}
pub struct GetPingInfoResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetPingInfoResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_serverId(&mut self, serverId: u16) {
    self.fbb_.push_slot::<u16>(GetPingInfoResponse::VT_SERVERID, serverId, 0);
  }
  #[inline]
  pub fn add_worldId(&mut self, worldId: u32) {
    self.fbb_.push_slot::<u32>(GetPingInfoResponse::VT_WORLDID, worldId, 0);
  }
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(GetPingInfoResponse::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_rtt(&mut self, rtt: u32) {
    self.fbb_.push_slot::<u32>(GetPingInfoResponse::VT_RTT, rtt, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetPingInfoResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetPingInfoResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPingInfoResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SendRoomMessageRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SendRoomMessageRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SendRoomMessageRequest<'a> {
    type Inner = SendRoomMessageRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SendRoomMessageRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SendRoomMessageRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SendRoomMessageRequestArgs<'args>) -> flatbuffers::WIPOffset<SendRoomMessageRequest<'bldr>> {
      let mut builder = SendRoomMessageRequestBuilder::new(_fbb);
      builder.add_roomId(args.roomId);
      if let Some(x) = args.msg { builder.add_msg(x); }
      if let Some(x) = args.dst { builder.add_dst(x); }
      builder.add_option(args.option);
      builder.add_castType(args.castType);
      builder.finish()
    }

    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_CASTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DST: flatbuffers::VOffsetT = 8;
    pub const VT_MSG: flatbuffers::VOffsetT = 10;
    pub const VT_OPTION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn roomId(&self) -> u64 {
    self._tab.get::<u64>(SendRoomMessageRequest::VT_ROOMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn castType(&self) -> u8 {
    self._tab.get::<u8>(SendRoomMessageRequest::VT_CASTTYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn dst(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(SendRoomMessageRequest::VT_DST, None)
  }
  #[inline]
  pub fn msg(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SendRoomMessageRequest::VT_MSG, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn option(&self) -> u8 {
    self._tab.get::<u8>(SendRoomMessageRequest::VT_OPTION, Some(0)).unwrap()
  }
}

pub struct SendRoomMessageRequestArgs<'a> {
    pub roomId: u64,
    pub castType: u8,
    pub dst: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u16>>>,
    pub msg: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub option: u8,
}
impl<'a> Default for SendRoomMessageRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        SendRoomMessageRequestArgs {
            roomId: 0,
            castType: 0,
            dst: None,
            msg: None,
            option: 0,
        }
    }
}
pub struct SendRoomMessageRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SendRoomMessageRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_roomId(&mut self, roomId: u64) {
    self.fbb_.push_slot::<u64>(SendRoomMessageRequest::VT_ROOMID, roomId, 0);
  }
  #[inline]
  pub fn add_castType(&mut self, castType: u8) {
    self.fbb_.push_slot::<u8>(SendRoomMessageRequest::VT_CASTTYPE, castType, 0);
  }
  #[inline]
  pub fn add_dst(&mut self, dst: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendRoomMessageRequest::VT_DST, dst);
  }
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendRoomMessageRequest::VT_MSG, msg);
  }
  #[inline]
  pub fn add_option(&mut self, option: u8) {
    self.fbb_.push_slot::<u8>(SendRoomMessageRequest::VT_OPTION, option, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SendRoomMessageRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SendRoomMessageRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SendRoomMessageRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RoomMessageInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RoomMessageInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RoomMessageInfo<'a> {
    type Inner = RoomMessageInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RoomMessageInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RoomMessageInfo {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoomMessageInfoArgs<'args>) -> flatbuffers::WIPOffset<RoomMessageInfo<'bldr>> {
      let mut builder = RoomMessageInfoBuilder::new(_fbb);
      if let Some(x) = args.msg { builder.add_msg(x); }
      if let Some(x) = args.srcMember { builder.add_srcMember(x); }
      if let Some(x) = args.dst { builder.add_dst(x); }
      builder.add_castType(args.castType);
      builder.add_filtered(args.filtered);
      builder.finish()
    }

    pub const VT_FILTERED: flatbuffers::VOffsetT = 4;
    pub const VT_CASTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DST: flatbuffers::VOffsetT = 8;
    pub const VT_SRCMEMBER: flatbuffers::VOffsetT = 10;
    pub const VT_MSG: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn filtered(&self) -> bool {
    self._tab.get::<bool>(RoomMessageInfo::VT_FILTERED, Some(false)).unwrap()
  }
  #[inline]
  pub fn castType(&self) -> u8 {
    self._tab.get::<u8>(RoomMessageInfo::VT_CASTTYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn dst(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(RoomMessageInfo::VT_DST, None)
  }
  #[inline]
  pub fn srcMember(&self) -> Option<UserInfo2<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<UserInfo2<'a>>>(RoomMessageInfo::VT_SRCMEMBER, None)
  }
  #[inline]
  pub fn msg(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RoomMessageInfo::VT_MSG, None).map(|v| v.safe_slice())
  }
}

pub struct RoomMessageInfoArgs<'a> {
    pub filtered: bool,
    pub castType: u8,
    pub dst: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u16>>>,
    pub srcMember: Option<flatbuffers::WIPOffset<UserInfo2<'a >>>,
    pub msg: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for RoomMessageInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoomMessageInfoArgs {
            filtered: false,
            castType: 0,
            dst: None,
            srcMember: None,
            msg: None,
        }
    }
}
pub struct RoomMessageInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoomMessageInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_filtered(&mut self, filtered: bool) {
    self.fbb_.push_slot::<bool>(RoomMessageInfo::VT_FILTERED, filtered, false);
  }
  #[inline]
  pub fn add_castType(&mut self, castType: u8) {
    self.fbb_.push_slot::<u8>(RoomMessageInfo::VT_CASTTYPE, castType, 0);
  }
  #[inline]
  pub fn add_dst(&mut self, dst: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMessageInfo::VT_DST, dst);
  }
  #[inline]
  pub fn add_srcMember(&mut self, srcMember: flatbuffers::WIPOffset<UserInfo2<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserInfo2>>(RoomMessageInfo::VT_SRCMEMBER, srcMember);
  }
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RoomMessageInfo::VT_MSG, msg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoomMessageInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoomMessageInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RoomMessageInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

